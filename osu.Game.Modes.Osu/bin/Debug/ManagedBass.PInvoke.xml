<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ManagedBass.PInvoke</name>
    </assembly>
    <members>
        <member name="T:ManagedBass.Bass">
             <summary>
             Wraps bass.dll.
            
             <para>
             Supports: .mp3, .ogg, .wav, .mp2, .mp1, .aiff, .m2a, .mpa, .m1a, .mpg, .mpeg, .aif, .mp3pro, .bwf, .mus,
             .mod, .mo3, .s3m, .xm, .it, .mtm, .umx, .mdz, .s3z, .itz, .xmz
             </para>
             </summary>
             <remarks>
             <para>
             BASS is a multiplatform audio library.
             It's purpose is to provide the most powerful and efficient (yet easy to use),
             sample, stream, MOD music, and recording functions.
             All in a tiny DLL, under 100KB in size.
             </para>
             </remarks>
        </member>
        <member name="M:ManagedBass.Bass.GetDSoundObject(ManagedBass.DSInterface)">
            <summary>
            Retrieves a pointer to a DirectSound object interface. (Available only on Windows) (Not much useful in .Net)
            </summary>
            <param name="obj">The interface to retrieve.</param>
            <returns>
            If successful, then a pointer to the requested object is returned, otherwise <see cref="F:System.IntPtr.Zero"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.GetDSoundObject(System.Int32)">
            <summary>
            Retrieves a pointer to a DirectSound object interface. (Available only on Windows) (Not much useful in .Net)
            </summary>
            <param name="Channel">An HCHANNEL, HMUSIC or HSTREAM handle of which IDirectSoundBuffer is to be retrieved.</param>
            <returns>
            If successful, then a pointer to an IDirectSoundBuffer is returned, otherwise <see cref="F:System.IntPtr.Zero"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.GetEAXParameters(ManagedBass.EAXEnvironment@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Retrieves the current type of EAX environment and it's parameters.
            </summary>
            <param name="Environment">The EAX environment to get (one of the <see cref="T:ManagedBass.EAXEnvironment" /> values).</param>
            <param name="Volume">The volume of the reverb.</param>
            <param name="Decay">The decay duration.</param>
            <param name="Damp">The damping.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NoEAX">The current device does not support EAX.</exception>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.
            <para><b>Platform-specific</b></para>
            <para>EAX and this function are only available on Windows</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.SetEAXParameters(ManagedBass.EAXEnvironment,System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:ManagedBass.Bass.SetEAXPreset(ManagedBass.EAXEnvironment)">
            <summary>
            Sets the parameters of EAX from a Preset.
            </summary>
            <param name="Environment">The EAX Environment.</param>
            <returns></returns>
        </member>
        <member name="M:ManagedBass.Bass.SetEAXParameters(ManagedBass.EAXEnvironment,System.Single,System.Single,System.Single)">
            <summary>
            Sets the type of EAX environment and it's parameters.
            </summary>
            <param name="Environment">The EAX environment.</param>
            <param name="Volume">The volume of the reverb... 0.0 (off) - 1.0 (max), less than 0.0 = leave current.</param>
            <param name="Decay">The time in seconds it takes the reverb to diminish by 60dB... 0.1 (min) - 20.0 (max), less than 0.0 = leave current.</param>
            <param name="Damp">The damping, high or low frequencies decay faster... 0.0 = high decays quickest, 1.0 = low/high decay equally, 2.0 = low decays quickest, less than 0.0 = leave current.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NoEAX">The current device does not support EAX.</exception>
            <remarks>
            <para>
            The use of EAX requires that the output device supports EAX.
            <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> can be used to check that.
            EAX only affects 3D channels, but EAX functions do Not require <see cref="M:ManagedBass.Bass.Apply3D" /> to apply the changes.
            </para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            <para><b>Platform-specific</b></para>
            <para>This function is only available on Windows.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.GetEAXParameters(ManagedBass.EAXEnvironment@,System.Single@,System.Single@,System.Single@)"/>
            <seealso cref="F:ManagedBass.ChannelAttribute.EaxMix"/>
        </member>
        <member name="P:ManagedBass.Bass.VistaTruePlayPosition">
            <summary>
            Enable DirectSound's true play position mode on Windows Vista and newer? (default is true).
            </summary>
            <remarks>
            Unless this option is enabled, the reported playback position will advance in 10ms steps on Windows Vista and newer.
            As well as affecting the precision of <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)"/>, this also affects the timing of non-mixtime syncs.
            When this option is enabled, it allows finer position reporting but it also increases latency.
            Changes only affect channels that are created afterwards, not any that already exist.
            The <see cref="P:ManagedBass.BassInfo.Latency"/> and <see cref="P:ManagedBass.BassInfo.MinBufferLength"/> values
            in the <see cref="T:ManagedBass.BassInfo"/> structure reflect the setting at the time of the device's <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> call.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.IncludeDefaultDevice">
            <summary>
            Windows-only: Include a "Default" entry in the output device list? (default is false).
            </summary>
            <remarks>
            BASS does not usually include a "Default" entry in its device list,
            as that would ultimately map to one of the other devices and be a duplicate entry.
            When the default device is requested in a <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> call (with device = -1),
            BASS will check the default device at that time, and initialize it.
            But Windows 7 has the ability to automatically switch the default output to the new default device whenever it changes,
            and in order for that to happen, the default device (rather than a specific device) needs to be used.
            That is where this option comes in.
            When enabled, the "Default" device will also become the default device to <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> (with device = -1).
            When the "Default" device is used, the <see cref="P:ManagedBass.Bass.Volume"/> functions work a bit differently to usual;
            they deal with the "session" volume, which only affects the current process's output on the device, rather than the device's volume.
            This option can only be set before <see cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)"/> or <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has been called.
            <para>
            <b>Platform-specific</b>: This config option is only available on Windows.
            It is available on all Windows versions (not including CE), but only Windows 7 has the default output switching feature.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.VistaSpeakerAssignment">
            <summary>
            Enable speaker assignment with panning/balance control on Windows Vista and newer?
            </summary>
            <remarks>
            Panning/balance control via the <see cref="F:ManagedBass.ChannelAttribute.Pan"/> attribute is not available
            when speaker assignment is used on Windows due to the way that the speaker assignment needs to be implemented there.
            The situation is improved with Windows Vista, and speaker assignment can generally
            be done in a way that does permit panning/balance control to be used at the same time,
            but there may still be some drivers that it does not work properly with,
            so it is disabled by default and can be enabled via this config option.
            Changes only affect channels that are created afterwards, not any that already exist.
            <para>
            <b>Platform-specific</b>: This config option is only available on Windows.
            It is available on all Windows versions (not including CE), but only has effect on Windows Vista and newer.
            Speaker assignment with panning/balance control is always possible on other platforms,
            where BASS generates the final mix.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.UnicodeDeviceInformation">
            <summary>
            Gets or Sets the Unicode character set in device information.
            If true, device information will be in UTF-8 form.
            Otherwise it will be ANSI.
            </summary>
            <remarks>
            This config option determines what character set is used in the
            <see cref="T:ManagedBass.DeviceInfo"/> structure and by the <see cref="M:ManagedBass.Bass.RecordGetInputName(System.Int32)"/> function.
            The default setting is ANSI, and it can only be changed before <see cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)"/> or <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>
            or <see cref="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)"/> or <see cref="M:ManagedBass.Bass.RecordInit(System.Int32)"/> has been called.
            <para><b>Platform-specific</b>: This config option is only available on Windows.</para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.MFVideo">
            <summary>
            Play the audio from video files using Media Foundation?
            </summary>
            <remarks>
            This config option is only available on Windows, and only has effect on Windows Vista and newer.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NoTimerResolution">
            <summary>
            UNDOCUMENTED: Disables Bass from setting system timer resolution.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.Apply3D">
            <summary>
            Applies changes made to the 3D system.
            </summary>
            <remarks>
            <para>
            This function must be called to apply any changes made with <see cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>, <see cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>, <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/> or <see cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>.
            This allows multiple changes to be synchronized, and also improves performance.
            </para>
            <para>
            This function applies 3D changes on all the initialized devices.
            There's no need to re-call it for each individual device when using multiple devices.
            </para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
        </member>
        <member name="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)">
            <summary>
            Retrieves the factors that affect the calculations of 3D sound.
            </summary>
            <param name="Distance">The distance factor.</param>
            <param name="RollOff">The rolloff factor.</param>
            <param name="Doppler">The doppler factor.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</remarks>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)">
            <summary>
            Sets the factors that affect the calculations of 3D sound.
            </summary>
            <param name="Distance">
            The distance factor... less than 0.0 = leave current... examples: 1.0 = use meters, 0.9144 = use yards, 0.3048 = use feet.
            By default BASS measures distances in meters, you can change this setting if you are using a different unit of measurement.
            </param>
            <param name="RollOff">The rolloff factor, how fast the sound quietens with distance... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no rolloff, 1.0 = real world, 2.0 = 2x real.</param>
            <param name="Doppler">
            The doppler factor... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no doppler, 1.0 = real world, 2.0 = 2x real.
            The doppler effect is the way a sound appears to change pitch when it is moving towards or away from you (say hello to Einstein!).
            The listener and sound velocity settings are used to calculate this effect, this <paramref name="Doppler"/> value can be used to lessen or exaggerate the effect.
            </param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>
            <para>As with all 3D functions, use <see cref="M:ManagedBass.Bass.Apply3D" /> to apply the changes.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Apply3D"/>
            <seealso cref="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)"/>
        </member>
        <member name="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)">
            <summary>
            Retrieves the position, velocity, and orientation of the listener.
            </summary>
            <param name="Position">The position of the listener</param>
            <param name="Velocity">The listener's velocity</param>
            <param name="Front">The direction that the listener's front is pointing</param>
            <param name="Top">The direction that the listener's top is pointing</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>
            <para>The <paramref name="Front" /> and <paramref name="Top" /> parameters must both be retrieved in a single call, they can not be retrieved individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)">
            <summary>
            Sets the position, velocity, and orientation of the listener (i.e. the player).
            </summary>
            <param name="Position">The position of the listener... <see langword="null"/> = Leave Current.</param>
            <param name="Velocity">The listener's velocity... <see langword="null"/> = Leave Current.</param>
            <param name="Front">The direction that the listener's front is pointing... <see langword="null"/> = Leave Current.</param>
            <param name="Top">The direction that the listener's top is pointing... <see langword="null"/> = Leave Current.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>
            <para>The <paramref name="Front" /> and <paramref name="Top" /> parameters must both be set in a single call, they can not be set individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Apply3D"/>
            <seealso cref="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="P:ManagedBass.Bass.Algorithm3D">
            <summary>
            The 3D algorithm for software mixed 3D channels.
            </summary>
            <remarks>
            <para>
            These algorithms only affect 3D channels that are being mixed in software.
            <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)"/> can be used to check whether a channel is being software mixed.
            </para>
            <para>
            Changing the algorithm only affects subsequently created or loaded samples, musics, or streams;
            it does not affect any that already exist.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, DirectX 7 or above is required for this option to have effect.
            On other platforms, only the <see cref="F:ManagedBass.Algorithm3D.Default"/> and <see cref="F:ManagedBass.Algorithm3D.Off"/> options are available.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGet3DAttributes(System.Int32,ManagedBass.Mode3D@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Single@)">
            <summary>
            Retrieves the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Mode">The 3D processing mode (see <see cref="T:ManagedBass.Mode3D" />).</param>
            <param name="Min">The minimum distance.</param>
            <param name="Max">The maximum distance.</param>
            <param name="iAngle">The angle of the inside projection cone.</param>
            <param name="oAngle">The angle of the outside projection cone.</param>
            <param name="OutVol">The delta-volume outside the outer projection cone.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The <paramref name="iAngle"/> and <paramref name="oAngle"/> parameters must both be retrieved in a single call to this function (ie. you can't retrieve one without the other).</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DPosition(System.Int32,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            <seealso cref="F:ManagedBass.ChannelAttribute.EaxMix"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)">
            <summary>
            Sets the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Mode">The 3D processing mode</param>
            <param name="Min">The minimum distance. The channel's volume is at maximum when the listener is within this distance... less than 0.0 = leave current.</param>
            <param name="Max">The maximum distance. The channel's volume stops decreasing when the listener is beyond this distance... less than 0.0 = leave current.</param>
            <param name="iAngle">The angle of the inside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="oAngle">The angle of the outside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="OutVol">The delta-volume outside the outer projection cone... 0 (silent) - 100 (same as inside the cone), -1 = leave current.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One or more of the attribute values is invalid.</exception>
            <remarks>
            <para>The <paramref name="iAngle"/> and <paramref name="oAngle"/> parameters must both be set in a single call to this function (ie. you can't set one without the other).
            The <paramref name="iAngle"/> and <paramref name="oAngle"/> angles decide how wide the sound is projected around the orientation angle. Within the inside angle the volume level is the channel volume, as set with <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.
            Outside the outer angle, the volume changes according to the <paramref name="OutVol"/> value. Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels.
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.</para>
            <para>As with all 3D functions, use <see cref="M:ManagedBass.Bass.Apply3D" /> to apply the changes made.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DAttributes(System.Int32,ManagedBass.Mode3D@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>
            <seealso cref="F:ManagedBass.ChannelAttribute.EaxMix"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGet3DPosition(System.Int32,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)">
            <summary>
            Retrieves the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Position">Position of the sound.</param>
            <param name="Orientation">Orientation of the sound.</param>
            <param name="Velocity">Velocity of the sound.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DAttributes(System.Int32,ManagedBass.Mode3D@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)">
            <summary>
            Sets the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Position">Position of the sound.</param>
            <param name="Orientation">Orientation of the sound.</param>
            <param name="Velocity">Velocity of the sound. This is only used to calculate the doppler effect, and has no effect on the sound's position.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>As with all 3D functions, <see cref="M:ManagedBass.Bass.Apply3D" /> must be called to apply the changes made.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <seealso cref="M:ManagedBass.Bass.Apply3D"/>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DPosition(System.Int32,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="M:ManagedBass.Bass.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Bass.SupportedFormats">
            <summary>
            Gets the Formats supported by Bass.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.Update(System.Int32)">
            <summary>
            Updates the HSTREAM and HMUSIC channel playback buffers.
            </summary>
            <param name="Length">The amount of data to render, in milliseconds.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Updating is already in progress.</exception>
            <remarks>
            When automatic updating is disabled, this function (or <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)" />) needs to be called to keep the playback buffers updated.
            The <paramref name="Length"/> parameter should include some safety margin, in case the next update cycle gets delayed.
            For example, if calling this function every 100ms, 200 would be a reasonable <paramref name="Length"/> parameter.
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/>
            <seealso cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
            <seealso cref="P:ManagedBass.Bass.UpdateThreads"/>
        </member>
        <member name="P:ManagedBass.Bass.CPUUsage">
            <summary>
            Retrieves the current CPU usage of BASS as a percentage of total CPU time.
            </summary>
            <remarks>
            <para>
            This function includes the time taken to render stream (HSTREAM) and MOD music (HMUSIC) channels during playback, and any DSP functions set on those channels.
            It slso includes any FX that are not using the "with FX flag" DX8 effect implementation.
            </para>
            <para>
            The rendering of some add-on stream formats may not be entirely included, if they use additional decoding threads.
            See the add-on documentation for details.
            </para>
            <para>
            This function does not strictly tell the CPU usage, but rather how timely the processing is.
            For example, if it takes 10ms to render 100ms of data, that would be 10%.
            If the reported usage gets to 100%, that means the channel data is being played faster than it can be rendered, and Buffer underruns are likely to occur.
            </para>
            <para>
            If automatic updating is disabled, then the value returned by this function is only updated after each call to <see cref="M:ManagedBass.Bass.Update(System.Int32)" />.
            <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)" /> usage is not included.
            The CPU usage of an individual channel is available via the <see cref="F:ManagedBass.ChannelAttribute.CPUUsage"/> attribute.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, the CPU usage does not include sample channels (HCHANNEL), which are mixed by the output device/drivers (hardware mixing) or Windows (software mixing).
            On other platforms, the CPU usage does include sample playback as well as the generation of the final output mix.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.Version">
            <summary>
            Retrieves the version of BASS that is loaded
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.LastError">
            <summary>
            Gets the Error that occured on the Last Bass function that was called.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Info"><see cref="T:ManagedBass.ChannelInfo" /> instance where to store the channel information at.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetInfo(System.Int32)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>An instance of the <see cref="T:ManagedBass.ChannelInfo" /> structure. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)">
            <summary>
            Sets up a User DSP function on a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Procedure">The callback function (see <see cref="T:ManagedBass.DSPProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <param name="Priority">
            The priority of the new DSP, which determines it's position in the DSP chain.
            DSPs with higher priority are called before those with lower.
            </param>
            <returns>
            If succesful, then the new DSP's Handle is returned, else 0 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            <para>
            Equally, you can also remove them at any time.
            Use <see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)"/> to remove a DSP function.
            </para>
            <para>
            Multiple DSP functions may be used per channel, in which case the order that the functions are called is determined by their priorities.
            Any DSPs that have the same priority are called in the order that they were added.
            </para>
            <para>
            DSP functions can be applied to MOD musics and streams, but not samples.
            If you want to apply a DSP function to a sample, then you should stream the sample.
            </para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed or DSP is removed via <see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)">
            <summary>
            Removes a DSP function from a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="DSP">Handle of the DSP function to remove from the channel (return value of a previous <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" /> call).</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="DSP" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a MOD music, stream or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Type">The Type of sync (see <see cref="T:ManagedBass.SyncFlags" />).</param>
            <param name="Parameter">The sync parameters, depends on the sync Type (see <see cref="T:ManagedBass.SyncFlags"/>).</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>
            If succesful, then the new synchronizer's Handle is returned, else 0 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal <paramref name="Parameter" /> was specified.</exception>
            <remarks>
            <para>
            Multiple synchronizers may be used per channel, and they can be set before and while playing.
            Equally, synchronizers can also be removed at any time, using <see cref="M:ManagedBass.Bass.ChannelRemoveSync(System.Int32,System.Int32)" />.
            If the <see cref="F:ManagedBass.SyncFlags.Onetime"/> flag is used, then the sync is automatically removed after its first occurrence.
            </para>
            <para>The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag can be used with <see cref="F:ManagedBass.SyncFlags.End"/> or <see cref="F:ManagedBass.SyncFlags.Position"/>/<see cref="F:ManagedBass.SyncFlags.MusicPosition"/> syncs to implement custom looping, by using <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> in the callback.
            A <see cref="F:ManagedBass.SyncFlags.Mixtime"/> sync can also be used to add or remove DSP/FX at specific points, or change a HMUSIC channel's flags or attributes (see <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />).
            The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag can also be useful with a <see cref="F:ManagedBass.SyncFlags.Seeking"/> sync, to reset DSP states after seeking.</para>
            <para>
            Several of the sync types are triggered in the process of rendering the channel's sample data;
            for example, <see cref="F:ManagedBass.SyncFlags.Position"/> and <see cref="F:ManagedBass.SyncFlags.End"/> syncs, when the rendering reaches the sync position or the end, respectively.
            Those sync types should be set before starting playback or pre-buffering (ie. before any rendering), to avoid missing any early sync events.
            </para>
            <para>With recording channels, <see cref="F:ManagedBass.SyncFlags.Position"/> syncs are triggered just before the <see cref="T:ManagedBass.RecordProcedure" /> receives the block of data containing the sync position.</para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed or Sync is removed via <see cref="M:ManagedBass.Bass.ChannelRemoveSync(System.Int32,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a MOD music or stream channel.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> call).</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)">
            <summary>
            Starts (or resumes) playback of a sample, stream, MOD music, or recording.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD Handle.</param>
            <param name="Restart">
            Restart playback from the beginning? If Handle is a User stream, it's current Buffer contents are flushed.
            If it's a MOD music, it's BPM/etc are automatically reset to their initial values.
            </param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The output is paused/stopped, use <see cref="M:ManagedBass.Bass.Start" /> to start it.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The channel is not playable, it's a "decoding channel".</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window Handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.</exception>
            <exception cref="F:ManagedBass.Errors.NoHW">
            No hardware voices are available (HCHANNEL only).
            This only occurs if the sample was loaded/created with the <see cref="F:ManagedBass.BassFlags.VAM"/> flag,
            and <see cref="F:ManagedBass.VAMMode.Hardware"/> is set in the sample's VAM mode,
            and there are no hardware voices available to play it.
            </exception>
            <remarks>
            When streaming in blocks (<see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>), the restart parameter is ignored as it's not possible to go back to the start.
            The <paramref name="Restart" /> parameter is also of no consequence with recording channels.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelPause(System.Int32)">
            <summary>
            Pauses a sample, stream, MOD music, or recording.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD Handle.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing (or <paramref name="Handle" /> is not a valid channel).</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The channel is not playable, it's a "decoding channel".</exception>
            <exception cref="F:ManagedBass.Errors.Already">The channel is already paused.</exception>
            <remarks>
            Use <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> to resume a paused channel.
            <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> can be used to stop a paused channel.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelStop(System.Int32)">
            <summary>
            Stops a sample, stream, MOD music, or recording.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD Handle.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>
            Stopping a User stream (created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />) will clear its Buffer contents,
            and stopping a sample channel (HCHANNEL) will result in it being freed.
            Use <see cref="M:ManagedBass.Bass.ChannelPause(System.Int32)" /> instead if you wish to stop a User stream and then resume it from the same point.
            </para>
            <para>
            When used with a "decoding channel" (<see cref="F:ManagedBass.BassFlags.Decode"/> was used at creation),
            this function will end the channel at its current position, so that it's not possible to decode any more data from it.
            Any <see cref="F:ManagedBass.SyncFlags.End"/> syncs that have been set on the channel will not be triggered by this, they are only triggered when reaching the natural end.
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be used to reset the channel and start decoding again.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelLock(System.Int32,System.Boolean)">
            <summary>
            Locks a stream, MOD music or recording channel to the current thread.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC, HSTREAM or HRECORD Handle.</param>
            <param name="Lock">If <see langword="false" />, unlock the channel, else lock it.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            Locking a channel prevents other threads from performing most functions on it, including Buffer updates.
            Other threads wanting to access a locked channel will block until it is unlocked, so a channel should only be locked very briefly.
            A channel must be unlocked in the same thread that it was locked.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelIsActive(System.Int32)">
            <summary>
            Checks if a sample, stream, or MOD music is active (playing) or stalled. Can also check if a recording is in progress.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns><see cref="T:ManagedBass.PlaybackState" /> indicating whether the state of the channel.
            </returns>
            <remarks>
            <para>
            When using this function with a decoding channel, <see cref="F:ManagedBass.PlaybackState.Playing"/> will be returned while there is still data to decode.
            Once the end has been reached, <see cref="F:ManagedBass.PlaybackState.Stopped"/> will be returned.
            <see cref="F:ManagedBass.PlaybackState.Stalled"/> is never returned for decoding channels;
            you can tell a decoding channel is stalled if <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> returns less data than requested,
            and this function still returns <see cref="F:ManagedBass.PlaybackState.Playing"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetLink(System.Int32,System.Int32)">
            <summary>
            Links two MOD music or stream channels together.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC or HSTREAM.</param>
            <param name="Channel">The Handle of the channel to have linked with it... a HMUSIC or HSTREAM.</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is a "decoding channel", so can't be linked.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><paramref name="Channel" /> is already linked to <paramref name="Handle" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>
            Linked channels are started/stopped/paused/resumed together.
            Links are one-way, for example, channel <paramref name="Channel" /> will be started by channel <paramref name="Handle" />,
            but not vice versa unless another link has been set in that direction.
            </para>
            <para>
            If a linked channel has reached the end, it will not be restarted when a channel it is linked to is started.
            If you want a linked channel to be restarted, you need to have resetted it's position using <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> beforehand.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            Except for on Windows, linked channels on the same device are guaranteed to start playing simultaneously.
            On Windows, it is possible for there to be a slight gap between them, but it will generally be shorter (and never longer) than starting them individually.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveLink(System.Int32,System.Int32)">
            <summary>
            Removes a links between two MOD music or stream channels.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC or HSTREAM.</param>
            <param name="Channel">The Handle of the channel to have unlinked with it... a HMUSIC or HSTREAM.</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Already">Either <paramref name="Channel" /> is not a valid channel, or it is already not linked to <paramref name="Handle" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)">
            <summary>
            Modifies and retrieves a channel's flags.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flags">
            A combination of flags that can be toggled (see <see cref="T:ManagedBass.BassFlags" />).
            Speaker assignment flags can also be toggled (HSTREAM/HMUSIC).
            </param>
            <param name="Mask">
            The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 in order to just retrieve the current flags.
            To modify the speaker flags, any of the Speaker flags can be used in the mask (no need to include all of them).
            </param>
            <returns>
            If successful, the channel's updated flags are returned, else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>
            Some flags may not be adjustable in some circumstances, so the return value should be checked to confirm any changes.
            The flags listed above are just the flags that can be modified, and there may be additional flags present in the return value.
            See the <see cref="T:ManagedBass.ChannelInfo" /> documentation for a full list of flags.
            </para>
            <para>
            Streams that are created by add-ons may have additional flags available.
            There is a limited number of possible flag values though, so some add-ons may use the same flag value for different things.
            This means that when using add-on specific flags with a stream created via the plugin system,
            it is a good idea to first confirm that the add-on is handling the stream, by checking its ctype via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            During playback, the effects of flag changes are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> config option to reduce the Buffer Length.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelHasFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Checks if a flag is present on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flag">see <see cref="T:ManagedBass.BassFlags" /></param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelAddFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Adds a flag to a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flag">see <see cref="T:ManagedBass.BassFlags" /></param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Removes a flag from a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flag">see <see cref="T:ManagedBass.BassFlags" /></param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)">
            <summary>
            Retrieves the value of an attribute of a sample, stream or MOD music.
            Can also get the sample rate of a recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of (one of <see cref="T:ManagedBass.ChannelAttribute" />)</param>
            <param name="Value">Reference to a float to receive the attribute value.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute)">
            <summary>
            Retrieves the value of an attribute of a sample, stream or MOD music.
            Can also get the sample rate of a recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of (one of <see cref="T:ManagedBass.ChannelAttribute" />)</param>
            <returns>If successful, the attribute value is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the value of a channel's attribute.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to get the value of (e.g. <see cref="F:ManagedBass.ChannelAttribute.ScannedInfo"/>)</param>
            <param name="Value">Pointer to a buffer to receive the attribute data.</param>
            <param name="Size">The size of the attribute data... 0 = get the size of the attribute without getting the data.</param>
            <returns>If successful, the size of the attribute data is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This function also supports the floating-point attributes supported by <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <paramref name="Attribute" /> is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Value" /> content or <paramref name="Size" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)">
            <summary>
            Sets the value of an attribute of a sample, stream or MOD music.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of.</param>
            <param name="Value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The actual attribute value may not be exactly the same as requested, due to precision differences.
            For example, an attribute might only allow whole number values.
            <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" /> can be used to confirm what the value is.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Value" /> is not valid. See the attribute's documentation for the valid range of values.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Double)">
            <summary>
            Sets the value of an attribute of a sample, stream or MOD music.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of.</param>
            <param name="Value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The actual attribute value may not be exactly the same as requested, due to precision differences.
            For example, an attribute might only allow whole number values.
            <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute)" /> can be used to confirm what the value is.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Value" /> is not valid. See the attribute's documentation for the valid range of values.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.IntPtr,System.Int32)">
            <summary>
            Sets the value of a channel's attribute.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of. (e.g. <see cref="F:ManagedBass.ChannelAttribute.ScannedInfo"/>)</param>
            <param name="Value">The pointer to the new attribute data.</param>
            <param name="Size">The size of the attribute data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Value" /> is not valid. See the attribute's documentation for the valid range of values.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)">
            <summary>
            Retrieves the requested tags/headers from a channel, if they are available.
            </summary>
            <param name="Handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="Tags">The tags/headers wanted...</param>
            <returns>If succesful, a pointer to the data of the tags/headers is returned, else <see cref="F:System.IntPtr.Zero" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Some tags (eg. <see cref="F:ManagedBass.TagType.ID3"/>) are located at the end of the file, so when streaming a file from the internet, the tags will not be available until the download is complete.
            A <see cref="F:ManagedBass.SyncFlags.Downloaded"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be informed of when the download is complete.
            A <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/> sync can be used to be informed of new Shoutcast metadata, and a <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync for when a new logical bitstream begins in a chained OGG stream, which generally brings new OGG tags.
            <para>
            In a chained OGG file containing multiple bitstreams, each bitstream will have its own tags.
            To get the tags from a particular one, <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be first used to seek to it.
            </para>
            <para>When a Media Foundation codec is in use, the <see cref="F:ManagedBass.TagType.WaveFormat"/> tag can be used to find out what the source format is.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested tags are not available.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)">
            <summary>
            Retrieves the playback Length of a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM. HSAMPLE handles may also be used.</param>
            <param name="Mode">How to retrieve the Length (one of the <see cref="T:ManagedBass.PositionFlags" /> flags).</param>
            <returns>
            If succesful, then the channel's Length is returned, else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The Length is not available.</exception>
            <remarks>
            <para>
            The exact Length of a stream will be returned once the whole file has been streamed, but until then it is not always possible to 100% accurately estimate the Length.
            The Length is always exact for MP3/MP2/MP1 files when the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used in the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" /> call, otherwise it is an (usually accurate) estimation based on the file size.
            The Length returned for OGG files will usually be exact (assuming the file is not corrupt), but when streaming from the internet (or "buffered" User file), it can be a very rough estimation until the whole file has been downloaded.
            It will also be an estimate for chained OGG files that are not pre-scanned.
            </para>
            <para>Unless an OGG file contains a single bitstream, the number of bitstreams it contains will only be available if it was pre-scanned at the stream's creation.</para>
            <para>Retrieving the Length of a MOD music requires that the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag was used in the <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" /> call.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelBytes2Seconds(System.Int32,System.Int64)">
            <summary>
            Translates a byte position into time (seconds), based on a channel's format.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="Position">The position in Bytes to translate.</param>
            <returns>If successful, then the translated Length in seconds is returned, else a negative value is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>The translation is based on the channel's initial sample rate, when it was created.</remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSeconds2Bytes(System.Int32,System.Double)">
            <summary>
            Translates a time (seconds) position into bytes, based on a channel's format.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="Position">The position to translate (in seconds, e.g. 0.03 = 30ms).</param>
            <returns>
            If successful, then the translated Length in Bytes is returned, else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>The translation is based on the channel's initial sample rate, when it was created.</para>
            <para>The return value is rounded down to the position of the nearest sample.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)">
            <summary>
            Retrieves the playback position of a sample, stream, or MOD music. Can also be used with a recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Mode">How to retrieve the position</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If successful, the position is returned.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested position is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>With MOD music you might use the <see cref="M:ManagedBass.BitHelper.LoWord(System.Int32)" /> and <see cref="M:ManagedBass.BitHelper.HiWord(System.Int32)" /> methods to retrieve the order and the row values respectively.</remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)">
            <summary>
            Sets the playback position of a sample, MOD music, or stream.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HSTREAM or HMUSIC.</param>
            <param name="Position">The position, in units determined by the <paramref name="Mode" />.</param>
            <param name="Mode">How to set the position.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotFile">The stream is not a file stream.</exception>
            <exception cref="F:ManagedBass.Errors.Position">The requested position is invalid, eg. beyond the end.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The download has not yet reached the requested position.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>
            Setting the position of a MOD music in bytes (other than 0) requires that the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag was used in the <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" /> call.
            When setting the position in orders/rows, the channel's byte position (as reported by <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />) is reset to 0.
            This is because it's not possible to get the byte position of an order/row position - it's possible that a position may never be played in the normal cause of events, or it may be played multiple times.
            </para>
            <para>
            When changing the position of a MOD music, and the <see cref="F:ManagedBass.BassFlags.MusicPositionReset"/> flag is active on the channel, all notes that were playing before the position changed will be stopped.
            Otherwise, the notes will continue playing until they are stopped in the MOD music.
            When setting the position in bytes, the BPM, "speed" and "global volume" are updated to what they would normally be at the new position.
            Otherwise they are left as they were prior to the postion change, unless the seek position is 0 (the start), in which case they are also reset to the starting values (when using the <see cref="F:ManagedBass.BassFlags.MusicPositionReset"/> flag).
            When the <see cref="F:ManagedBass.BassFlags.MusicPositionResetEx"/> flag is active, the BPM, speed and global volume are reset with every seek.
            </para>
            <para>
            For MP3/MP2/MP1 streams, unless the file is scanned via the <see cref="F:ManagedBass.PositionFlags.Scan"/> or the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag at stream creation, seeking will be approximate but generally still quite accurate.
            Besides scanning, exact seeking can also be achieved with the <see cref="F:ManagedBass.PositionFlags.DecodeTo"/> flag.
            </para>
            <para>Seeking in internet file (and "buffered" User file) streams is possible once the download has reached the requested position, so long as the file is not being streamed in blocks <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>.</para>
            <para>User streams (created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />) are not seekable, but it is possible to reset a User stream (including its Buffer contents) by setting its position to byte 0.</para>
            <para>The <see cref="F:ManagedBass.PositionFlags.DecodeTo"/> flag can be used to seek forwards in streams that are not normally seekable, like custom streams or internet streams that are using the <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/> flag, but it will only go as far as what is currently available; it will not wait for more data to be downloaded, for example. <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> can be used to confirm what the new position actually is.</para>
            <para>In some cases, particularly when the <see cref="F:ManagedBass.PositionFlags.Inexact"/> flag is used, the new position may not be what was requested. <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> can be used to confirm what the new position actually is.</para>
            <para>The <see cref="F:ManagedBass.PositionFlags.Scan"/> flag works the same way as the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" /> <see cref="F:ManagedBass.BassFlags.Prescan"/> flag, and can be used to delay the scanning until after the stream has been created. When a position beyond the end is requested, the call will fail (<see cref="F:ManagedBass.Errors.Position"/> error code) but the seek table and exact Length will have been scanned.
            When a file has been scanned, all seeking (even without the <see cref="F:ManagedBass.PositionFlags.Scan"/> flag) within the scanned part of it will use the scanned infomation.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelIsSliding(System.Int32,ManagedBass.ChannelAttribute)">
            <summary>
            Checks if an attribute (or any attribute) of a sample, stream, or MOD music is sliding.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Attribute">The attribute to check for sliding (0 for any attribute).</param>
            <returns>If the attribute (or any) is sliding, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
        </member>
        <member name="M:ManagedBass.Bass.IsSlidableAttribute(ManagedBass.ChannelAttribute)">
            <summary>
            Checks whether a <see cref="T:ManagedBass.ChannelAttribute"/> is slidable via <see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)"/>.
            </summary>
            <param name="Attribute">The attribute to check</param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)">
            <summary>
            Slides a channel's attribute from its current value to a new value.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HSTREAM or HMUSIC, or HRECORD.</param>
            <param name="Attribute">The attribute to slide the value of.</param>
            <param name="Value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <param name="Time">The Length of time (in milliseconds) that it should take for the attribute to reach the <paramref name="Value" />.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <remarks>
            <para>This function is similar to <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />, except that the attribute is ramped to the value over the specified period of time.
            Another difference is that the value is not pre-checked. If it is invalid, the slide will simply end early.</para>
            <para>If an attribute is already sliding, then the old slide is stopped and replaced by the new one.</para>
            <para><see cref="M:ManagedBass.Bass.ChannelIsSliding(System.Int32,ManagedBass.ChannelAttribute)" /> can be used to check if an attribute is currently sliding. A BASS_SYNC_SLIDE sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered at the end of a slide.
            The sync will not be triggered in the case of an existing slide being replaced by a new one.</para>
            <para>Attribute slides are unaffected by whether the channel is playing, paused or stopped. They carry on regardless.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word.
            The level ranges linearly from 0 (silent) to 32768 (max).
            0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            <para>
            This function measures the level of the channel's sample data, not the level of the channel in the final output mix,
            so the channel's volume and panning/balance (as set with <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />, <see cref="F:ManagedBass.ChannelAttribute.Volume"/> or <see cref="F:ManagedBass.ChannelAttribute.Pan"/>) does not affect it.
            The effect of any DSP/FX set on the channel is present in the measurement, except for DX8 effects when using the "With FX flag" DX8 effect implementation.
            </para>
            <para>
            For channels that are more than stereo, the left level will include all left channels (eg. front-left, rear-left, center), and the right will include all right (front-right, rear-right, LFE).
            If there are an odd number of channels then the left and right levels will include all channels.
            If the level of each individual channel is required, that is available from the other overload(s).
            </para>
            <para>
            20ms of data is inspected to calculate the level.
            When used with a decoding channel, that means 20ms of data needs to be decoded from the channel in order to calculate the level, and that data is then gone, eg. it is not available to a subsequent <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The decoding channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevelLeft(System.Int32)">
            <summary>
            Gets the Level of the Left Channel.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevelRight(System.Int32)">
            <summary>
            Gets the Level of the Right Channel.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Levels">The array in which the levels are to be returned.</param>
            <param name="Length">How much data (in seconds) to look at to get the level (limited to 1 second).</param>
            <param name="Flags">What levels to retrieve.</param>
            <returns>
            On success <see langword="true" /> is returned - else <see langword="false" />, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>If successful, the requested levels are returned in the <paramref name="Levels" /> array.</para>
            </returns>
            <remarks>
            This function operates in the same way as <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" /> but has greater flexibility on how the level is measured.
            The levels are not clipped, so may exceed +/-1.0 on floating-point channels.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The decoding channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Length">How much data (in seconds) to look at to get the level (limited to 1 second).</param>
            <param name="Flags">What levels to retrieve.</param>
            <returns>Array of levels on success, else <see langword="null" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function operates in the same way as <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" /> but has greater flexibility on how the level is measured.
            The levels are not clipped, so may exceed +/-1.0 on floating-point channels.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The decoding channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as an <see cref="T:System.IntPtr"/> (can be <see cref="F:System.IntPtr.Zero" /> when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts.
            If you really do need large amounts, then increase the buffer lengths (<see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>).
            The <see cref="F:ManagedBass.DataFlags.Available"/> flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.
            </para>
            <para>When requesting data from a decoding channel, data is decoded directly from the channel's source (no playback buffer) and as much data as the channel has available can be decoded at a time.</para>
            <para>When retrieving sample data, 8-bit samples are unsigned (0 to 255), 16-bit samples are signed (-32768 to 32767), 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).
            That is unless the <see cref="F:ManagedBass.DataFlags.Float"/> flag is used, in which case, the sample data will be converted to 32-bit floating-point if it is not already, or if the DataFlags.Fixed flag is used, in which case the data will be coverted to 8.24 fixed-point.
            </para>
            <para>
            Unless complex data is requested via the <see cref="F:ManagedBass.DataFlags.FFTComplex"/> flag, the magnitudes of the first half of an FFT result are returned.
            For example, with a 2048 sample FFT, there will be 1024 floating-point values returned.
            If the DataFlags.Fixed flag is used, then the FFT values will be in 8.24 fixed-point form rather than floating-point.
            Each value, or "bin", ranges from 0 to 1 (can actually go higher if the sample data is floating-point and not clipped).
            The 1st bin contains the DC component, the 2nd contains the amplitude at 1/2048 of the channel's sample rate, followed by the amplitude at 2/2048, 3/2048, etc.
            A Hann window is applied to the sample data to reduce leakage, unless the <see cref="F:ManagedBass.DataFlags.FFTNoWindow"/> flag is used.
            When a window is applied, it causes the DC component to leak into the next bin, but that can be removed (reduced to 0) by using the <see cref="F:ManagedBass.DataFlags.FFTRemoveDC"/> flag.
            Doing so slightly increases the processing required though, so it should only be done when needed, which is when a window is applied and the 2nd bin value is important.
            </para>
            <para>
            Channels that have 2 or more sample channels (ie. stereo or above) may have FFT performed on each individual channel, using the <see cref="F:ManagedBass.DataFlags.FFTIndividual"/> flag.
            Without this flag, all of the channels are combined, and a single mono FFT is performed.
            Performing the extra individual FFTs of course increases the amount of processing required.
            The return values are interleaved in the same order as the channel's sample data, eg. stereo = left,right,left,etc.
            </para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para><b>Platform-specific:</b></para>
            <para>The DataFlags.Fixed flag is only available on Android and Windows CE.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.DataFlags.Available"/> flag was used with a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a byte[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a short[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a int[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a float[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)">
            <summary>
            Updates the playback buffer of a stream or MOD music.
            </summary>
            <param name="Handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="Length">
            The amount to render, in milliseconds... 0 = default (2 x <see cref="P:ManagedBass.Bass.UpdatePeriod" />).
            This is capped at the space available in the buffer.
            </param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            When starting playback of a stream or MOD music, after creating it or changing its position, there will be a slight delay while the initial data is decoded for playback.
            Usually the delay is not noticeable or important, but if you need playback to start instantly when you call <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />, then use this function first.
            The length parameter should be at least equal to the <see cref="P:ManagedBass.Bass.UpdatePeriod" />.
            </para>
            <para>
            It may not always be possible to render the requested amount of data, in which case this function will still succeed.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check how much data a channel has buffered for playback.
            </para>
            <para>
            When automatic updating is disabled (<see cref="P:ManagedBass.Bass.UpdatePeriod" /> = 0 or <see cref="P:ManagedBass.Bass.UpdateThreads" /> = 0),
            this function could be used instead of <see cref="M:ManagedBass.Bass.Update(System.Int32)" /> to implement different update periods for different channels,
            instead of a single update period for all.
            Unlike <see cref="M:ManagedBass.Bass.Update(System.Int32)" />, this function can also be used while automatic updating is enabled.
            </para>
            <para>The CPU usage of this function is not included in the <see cref="P:ManagedBass.Bass.CPUUsage" /> reading.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Decoding channels do not have playback buffers.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The channel has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.Float">
            <summary>
            Gets if Floating-Point audio is supported on the current platform.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.PlaybackBufferLength">
            <summary>
            The Buffer Length in milliseconds (default = 500).
            </summary>
            <remarks>
            <para>
            The minimum Length is 1ms above the update period (See <see cref="P:ManagedBass.Bass.UpdatePeriod"/>),
            the maximum is 5000 milliseconds.
            If the Length specified is outside this range, it is automatically capped.
            Increasing the Length, decreases
            the chance of the sound possibly breaking-up on slower computers, but also
            increases the latency for DSP/FX.
            </para>
            <para>
            Small Buffer lengths are only required if the sound is going to be changing in real-time, for example, in a soft-synth.
            If you need to use a small Buffer, then the <see cref="P:ManagedBass.BassInfo.MinBufferLength"/> should be used to get the recommended
            minimum Buffer Length supported by the device and it's drivers.
            Even at this default Length, it's still possible that the sound could break up on some systems,
            it's also possible that smaller buffers may be fine.
            So when using small buffers, you should have an option in your software for the User to finetune the Length used, for optimal performance.
            Using this config option only affects the HMUSIC/HSTREAM channels that you create afterwards, not the ones that have already been created.
            So you can have channels with differing Buffer lengths by using this config option each time before creating them.
            If automatic updating is disabled, make sure you call <see cref="M:ManagedBass.Bass.Update(System.Int32)"/>
            frequently enough to keep the buffers updated.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.UpdatePeriod">
            <summary>
            The update period of HSTREAM and HMUSIC channel playback buffers in milliseconds.
            </summary>
            <remarks>
            <para>
            0 = disable automatic updating.
            The minimum period is 5ms, the maximum is 100ms.
            If the period specified is outside this range, it is automatically capped.
            The default period is 100ms.
            </para>
            <para>
            The update period is the amount of time between updates of the playback buffers of HSTREAM/HMUSIC channels.
            Shorter update periods allow smaller buffers to be set with the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> option, but
            as the rate of updates increases, so the overhead of setting up the updates becomes a greater part of the CPU usage.
            The update period only affects HSTREAM and HMUSIC channels, it does not affect samples.
            Nor does it have any effect on decoding channels, as they are not played.
            BASS creates one or more threads (determined by <see cref="P:ManagedBass.Bass.UpdateThreads"/>)
            specifically to perform the updating, except when automatic updating is disabled
            (period=0) - then you must regularly call <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> or <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> instead.
            This allows you to synchronize BASS's CPU usage with your program's.
            For example, in a game loop you could call <see cref="M:ManagedBass.Bass.Update(System.Int32)"/>
            once per frame, which keeps all the processing in sync so that the frame rate is as smooth as possible.
            <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> should be called at least around 8 times per second, even more often if the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
            option is used to set smaller buffers.
            The update period can be altered at any time, including during playback.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.GlobalSampleVolume">
            <summary>
            Global sample volume level... 0 (silent) - 10000 (full).
            </summary>
            <remarks>
            This config option allows you to have control over the volume levels of all the samples,
            which is useful for setup options (eg. separate music and fx volume controls).
            A channel's final volume = channel volume * global volume / max volume.
            So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000,
            then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.GlobalStreamVolume">
            <summary>
            Global stream volume level... 0 (silent) - 10000 (full).
            </summary>
            <remarks>
            This config option allows you to have control over the volume levels of all streams,
            which is useful for setup options (eg. separate music and fx volume controls).
            A channel's final volume = channel volume * global volume / max volume.
            So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000,
            then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.GlobalMusicVolume">
            <summary>
            Global music volume level... 0 (silent) - 10000 (full).
            </summary>
            <remarks>
            This config option allows you to have control over the volume levels of all the MOD musics,
            which is useful for setup options (eg. separate music and fx volume controls).
            A channel's final volume = channel volume * global volume / max volume.
            So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000,
            then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.LogarithmicVolumeCurve">
            <summary>
            Volume translation curve... false = Linear (Default), true = Logarithmic.
            </summary>
            <remarks>
            DirectSound uses logarithmic volume and panning curves, which can be awkward to work with.
            For example, with a logarithmic curve, the audible difference between 10000 and 9000,
            is not the same as between 9000 and 8000.
            With a linear "curve" the audible difference is spread equally across the whole range of values,
            so in the previous example the audible difference between 10000 and 9000,
            and between 9000 and 8000 would be identical.
            When using the linear curve, the volume range is from 0% (silent) to 100% (full).
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full).
            For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.LogarithmicPanningCurve">
            <summary>
            Panning translation curve... false = Linear (Default), true = Logarithmic.
            </summary>
            <remarks>
            The panning curve affects panning in exactly the same way as the <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> affects the volume.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.FloatingPointDSP">
            <summary>
            Pass 32-bit floating-point sample data to all <see cref="T:ManagedBass.DSPProcedure"/> callback functions.
            </summary>
            <remarks>
            Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit.
            But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing
            it to DSP functions, and then convert it back after all the DSP functions are done.
            As well as simplifying the DSP code (no need for 8/16-bit processing),
            this also means that there is no degradation of quality as sample data passes through a chain of DSP.
            This config option also applies to effects set via <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>,
            except for DX8 effects when using the "With FX flag" DX8 effect implementation.
            Changing the setting while there are DSP or FX set could cause problems, so should be avoided.
            <para>
            <b>Platform-specific</b>: On Android and Windows CE, 8.24 bit fixed-point is used instead of floating-point.
            Floating-point DX8 effect processing requires DirectX 9 (or above) on Windows.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.UpdateThreads">
            <summary>
            The number of threads to use for updating playback buffers... 0 = Disable automatic updating.
            </summary>
            <remarks>
            The number of update threads determines how many HSTREAM/HMUSIC channel playback buffers can be updated in parallel;
            each thread can process one channel at a time.
            The default is to use a single thread, but additional threads can be used to take advantage of multiple CPU cores.
            There is generally nothing much to be gained by creating more threads than there are CPU cores,
            but one benefit of using multiple threads even with a single CPU core is that
            a slow updating channel need not delay the updating of other channels.
            When automatic updating is disabled (threads = 0), <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> or <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> should be used instead.
            The number of update threads can be changed at any time, including during playback.
            <para><b>Platform-specific</b>: The number of update threads is limited to 1 on Windows CE platforms.</para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.AsyncFileBufferLength">
            <summary>
            The Buffer Length (in bytes) for asynchronous file reading (default setting is 65536 bytes (64KB)).
            </summary>
            <remarks>
            This will be rounded up to the nearest 4096 byte (4KB) boundary.
            This determines the amount of file data that can be read ahead of time with asynchronous file reading.
            Changes only affect streams that are created afterwards, not any that already exist.
            So it is possible to have streams with differing Buffer lengths
            by using this config option before creating each of them.
            When asynchronous file reading is enabled, the Buffer level is available from <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.HandleCount">
            <summary>
            Gets the total number of HSTREAM/HSAMPLE/HMUSIC/HRECORD handles.
            </summary>
            <remarks>
            The Handle count may not only include the app-created stuff but also internal stuff.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetTimeOut">
            <summary>
            Time (in milliseconds) to wait for a server to respond to a connection request.
            The default timeout is 5 seconds (5000 milliseconds).
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetReadTimeOut">
            <summary>
            The time (in milliseconds) to wait for a server to deliver more data for an internet stream. (default=0, infinite).
            When the timeout is hit, the connection with the server will be closed.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetBufferLength">
            <summary>
            The internet download Buffer Length, in milliseconds.
            </summary>
            <remarks>
            Increasing the Buffer Length decreases the chance of the stream stalling,
            but also increases the time taken by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)"/>
            to create the stream, as it has to pre-Buffer more data (adjustable via the <see cref="P:ManagedBass.Bass.NetPreBuffer"/> option).
            Aside from the pre-buffering, this setting has no effect on streams without either the <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>
            or <see cref="F:ManagedBass.BassFlags.RestrictDownloadRate"/> flags.
            When streaming in blocks, this option determines the download Buffer Length.
            The effective Buffer Length can actually be a bit more than that specified,
            including data that has been read from the Buffer by the decoder but not yet decoded.
            This config option also determines the buffering used by "buffered" User file streams
            created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            The default Buffer Length is 5 seconds (5000 milliseconds).
            The net Buffer Length should be larger than the Length of the playback Buffer (<see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>),
            otherwise the stream is likely to briefly stall soon after starting playback.
            Using this config option only affects streams created afterwards, not any that have already been created.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.PauseNoPlay">
            <summary>
            Prevent channels being played when the output is paused? (default = true)
            </summary>
            <remarks>
            When the output is paused using <see cref="M:ManagedBass.Bass.Pause"/>, and this config option is enabled,
            channels can't be played until the output is resumed using <see cref="M:ManagedBass.Bass.Start"/>.
            Attempts to play a channel will give a <see cref="F:ManagedBass.Errors.Start"/> error.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetPreBuffer">
            <summary>
            Amount (percentage) to pre-Buffer when opening internet streams. (default = 75%)
            </summary>
            <remarks>
            This setting determines what percentage of the Buffer Length (<see cref="P:ManagedBass.Bass.NetBufferLength"/>)
            should be filled by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)"/>.
            Setting this lower (eg. 0) is useful if you want to display a "buffering progress" (using <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)"/>)
            when opening internet streams, but note that this setting is just a minimum.
            BASS will always pre-download a certain amount to verify the stream.
            As well as internet streams, this config setting also applies to "buffered" User file streams
            created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.FTPPassive">
            <summary>
            Use passive mode in FTP connections? (default = true)
            Changes take effect from the next internet stream creation call.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetPlaylist">
            <summary>
            Process URLs in PLS, M3U, WPL or ASX playlists?...
            0 = never (Default),
            1 = in <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)"/> only,
            2 = in <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)"/> and <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/> too.
            </summary>
            <remarks>
            When enabled, BASS will process PLS, M3U, WPL and ASX playlists,
            going through each entry until it finds a URL that it can play.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetAgent">
            <summary>
            The "User-Agent" request header sent to servers.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetProxy">
            <summary>
            Proxy server settings (in the form of "User:pass@server:port"... null = don't use a proxy). "" (empty string) = use the OS's default proxy settings.
            </summary>
            <remarks>
            If only the "User:pass@" part is specified, then those authorization credentials are used with the default proxy server.
            If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.
            Changes take effect from the next internet stream creation call.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.MusicVirtial">
            <summary>
            The maximum number of virtual channels to use in the rendering of IT files... 1 (min) to 512 (max). (default = 64).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            This setting only affects IT files, as the other MOD music formats do not have virtual channels.
            Changes only apply to subsequently loaded files, not any that are already loaded.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.FileVerificationBytes">
            <summary>
            The amount of data (in bytes) to check in order to verify/detect the file format... 1000 (min) to 100000 (max). (default = 16000 bytes).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats,
            but it may also be used by add-ons (see the documentation).
            For internet (and "buffered" User file) streams, a quarter of the Length is used, up to a minimum of 1000 bytes.
            The verification Length excludes any tags that may be at the start of the file.
            For internet (and "buffered" User file) streams, the <see cref="P:ManagedBass.Bass.NetVerificationBytes"/> setting determines how much data is checked.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetVerificationBytes">
            <summary>
            The amount of data to check (in bytes) in order to verify/detect the file format of internet streams... 1000 (min) to 1000000 (max),
            or 0 = 25% of the <see cref="P:ManagedBass.Bass.FileVerificationBytes"/> setting (with a minimum of 1000 bytes).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats,
            but it may also be used by add-ons (see the documentation).
            The verification Length excludes any tags that may be found at the start of the file.
            The default setting is 0, which means 25% of the <see cref="P:ManagedBass.Bass.FileVerificationBytes"/> setting.
            As well as internet streams, this config setting also applies to "buffered" User file streams
            created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.SuppressMP3ErrorCorruptionSilence">
            <summary>
            Suppress silencing for corrupted MP3 frames. (default is false).
            </summary>
            <remarks>
            When BASS is detecting some corruption in an MP3 file's Huffman coding,
            it silences the frame to avoid any unpleasent noises that can result from corruption.
            Set this parameter to true in order to suppress this behavior.
            This applies only to the regular BASS version and NOT the "mp3-free" version.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.SRCQuality">
            <summary>
            Gets or Sets the default sample rate conversion quality...
            0 = linear interpolation,
            1 = 8 point sinc interpolation (Default),
            2 = 16 point sinc interpolation,
            3 = 32 point sinc interpolation.
            Other values are also accepted.
            </summary>
            <remarks>
            This config option determines what sample rate conversion
            quality new channels will initially have, except for sample channels (HCHANNEL),
            which use the <see cref="P:ManagedBass.Bass.SampleSRCQuality"/> setting.
            A channel's sample rate conversion quality can subsequently
            be changed via the <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion"/> attribute (see <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.SampleSRCQuality">
            <summary>
            Gets or Sets the default sample rate conversion quality for samples...
            0 = linear interpolation (Default),
            1 = 8 point sinc interpolation,
            2 = 16 point sinc interpolation,
            3 = 32 point sinc interpolation.
            Other values are also accepted.
            </summary>
            <remarks>
            This config option determines what sample rate conversion quality a new sample
            channel will initially have, following a <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)"/> call.
            The channel's sample rate conversion quality can subsequently be changed
            via the <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion"/> attribute (see <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.OggPreScan">
            <summary>
            Pre-scan chained OGG files? (enabled by default)
            </summary>
            <remarks>
            This option is equivalent to including the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag
            in a <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)"/> call when opening an OGG file.
            It can be disabled if seeking and an accurate Length reading are not required from chained OGG files,
            for faster stream creation.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.DeviceNonStop">
            <summary>
            Do not stop the output device when nothing is playing on it?
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file.
            </summary>
            <param name="File">Filename for which a stream should be created.</param>
            <param name="Offset">File Offset to begin streaming from.</param>
            <param name="Length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASS has built-in support for MPEG, OGG, WAV and AIFF files.
            Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.
            </para>
            <para>
            MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported.
            Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded.
            So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used.
            64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used (or the <see cref="P:ManagedBass.Bass.OggPreScan"/> config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start.
            The <see cref="F:ManagedBass.PositionFlags.OGG"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> to get the number of bitstreams and with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> to seek to a particular one.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when a new bitstream begins during decoding/playback.
            </para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            If <paramref name="Length"/> = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will not be updated until the end is reached.
            The <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> return values will be updated during playback of the extra data though.
            </para>
            <para>
            To stream a file from the internet, use <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            To stream from other locations, see <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Length" /> must be specified when streaming from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>  
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported memory IntPtr.
            </summary>
            <param name="Memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="Offset">Offset to begin streaming from.</param>
            <param name="Length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASS has built-in support for MPEG, OGG, WAV and AIFF files.
            Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.
            </para>
            <para>
            MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported.
            Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded.
            So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used.
            64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used (or the <see cref="P:ManagedBass.Bass.OggPreScan"/> config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start.
            The <see cref="F:ManagedBass.PositionFlags.OGG"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> to get the number of bitstreams and with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> to seek to a particular one.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when a new bitstream begins during decoding/playback.
            </para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            If <paramref name="Length"/> = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will not be updated until the end is reached.
            The <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> return values will be updated during playback of the extra data though.
            </para>
            <para>
            When streaming from memory, the memory must not be freed before the stream is freed.
            There may be exceptions to that with some add-ons (see the documentation).
            </para>
            <para>
            To stream a file from the internet, use <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            To stream from other locations, see <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </para>
            <para>The Memory buffer must be pinned when using this overload.</para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Length" /> must be specified when streaming from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file in memory (byte[]).
            </summary>
            <param name="Memory">A byte[] containing file data.</param>
            <param name="Offset">Offset to begin streaming from.</param>
            <param name="Length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASS has built-in support for MPEG, OGG, WAV and AIFF files.
            Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.
            </para>
            <para>
            MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported.
            Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded.
            So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used.
            64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used (or the <see cref="P:ManagedBass.Bass.OggPreScan"/> config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start.
            The <see cref="F:ManagedBass.PositionFlags.OGG"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> to get the number of bitstreams and with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> to seek to a particular one.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when a new bitstream begins during decoding/playback.
            </para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            If <paramref name="Length"/> = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will not be updated until the end is reached.
            The <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> return values will be updated during playback of the extra data though.
            </para>
            <para>
            The <paramref name="Memory"/> is pinned by this overload and freed when the stream is freed.
            </para>
            <para>
            To stream a file from the internet, use <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            To stream from other locations, see <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Length" /> must be specified when streaming from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file via user callback functions.
            </summary>
            <param name="System">File system to use.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedures">The user defined file function (see <see cref="T:ManagedBass.FileProcedures" />).</param>
            <param name="User">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The buffered file system (<see cref="F:ManagedBass.StreamSystem.Buffer"/>) is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            As the name suggests, data from the file is buffered so that it's readily available for decoding - BASS creates a thread dedicated to "downloading" the data.
            This is ideal for when the data is coming from a source that has high latency, like the internet.
            It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.
            </para>
            <para>
            The push buffered file system (<see cref="F:ManagedBass.StreamSystem.BufferPush"/>) is the same, except that instead of the file data being pulled from the <see cref="T:ManagedBass.FileReadProcedure" /> function in a "download" thread, the data is pushed to BASS via <see cref="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)" />.
            A <see cref="T:ManagedBass.FileReadProcedure" /> function is still required, to get the initial data used in the creation of the stream.
            </para>
            <para>
            The unbuffered file system (<see cref="F:ManagedBass.StreamSystem.NoBuffer"/>) is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />.
            In this system, BASS does not do any intermediate buffering - it simply requests data from the file as and when it needs it.
            This means that reading (<see cref="T:ManagedBass.FileReadProcedure" />) must be quick, otherwise the decoding will be delayed and playback buffer underruns (old data repeated) are a possibility.
            It's not so important for seeking (<see cref="T:ManagedBass.FileSeekProcedure" />) to be fast, as that is generally not required during decoding, except when looping a file.
            </para>
            <para>In all cases, BASS will automatically stall playback of the stream when insufficient data is available, and resume it when enough data does become available.</para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            <para>
            A copy is made of the <paramref name="Procedures"/> callback function table, so it does not have to persist beyond this function call.
            Unlike Bass.Net, a reference to <paramref name="Procedures"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="System" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="Url">
            URL of the file to stream.
            Should begin with "http://", "https://" or "ftp://", or another add-on supported protocol.
            The URL can be followed by custom HTTP request headers to be sent to the server;
            the URL and each header should be terminated with a carriage return and line feed ("\r\n").
            </param>
            <param name="Offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown, for example a Shout/Icecast server.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags" /></param>
            <param name="Procedure">Callback function to receive the file as it is downloaded... <see langword="null" /> = no callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            When playing the stream, BASS will stall the playback if there is insufficient data to continue playing.
            Playback will automatically be resumed when sufficient data has been downloaded.
            <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if the playback is stalled, and the progress of the file download can be checked with <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" />.
            </para>
            <para>When streaming in blocks (<see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>), be careful not to stop/pause the stream for too long, otherwise the connection may timeout due to there being no activity and the stream will end prematurely.</para>
            <para>
            When streaming from Shoutcast servers, metadata (track titles) may be sent by the server.
            The data can be retrieved with <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            A sync can also be set (using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />) so that you are informed when metadata is received.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be used to be informed of when a new logical bitstream begins in an Icecast/OGG stream.
            </para>
            <para>
            When using an <paramref name="Offset" />, the file length returned by <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check that it was successful by comparing it with the original file length.
            Another way to check is to inspect the HTTP headers retrieved with <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            </para>
            <para>Custom HTTP request headers may be ignored by some plugins, notably BassWma.</para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC and WMA.
            On iOS and OSX, CoreAudio codecs are supported, including support for AAC and ALAC.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            Built-in support for IMA and Microsoft ADPCM WAV files is provided on Linux/Android/Windows CE, while they are supported via ACM and CoreAudio codecs on Windows and OSX/iOS.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.NoInternet">No internet connection could be opened. Can be caused by a bad proxy setting.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Url" /> is not a valid URL.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="F:ManagedBass.Bass.NoSoundDevice">
            <summary>
            Index of No Sound Device.
            </summary>
        </member>
        <member name="F:ManagedBass.Bass.DefaultDevice">
            <summary>
            Index of Default Device.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)">
            <summary>
            Initializes an output device.
            </summary>
            <param name="Device">The device to use... -1 = default device, 0 = no sound, 1 = first real output device.
            <see cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> or <see cref="P:ManagedBass.Bass.DeviceCount" /> can be used to get the total number of devices.
            </param>
            <param name="Frequency">Output sample rate.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.DeviceInitFlags"/>.</param>
            <param name="Win">The application's main window... <see cref="F:System.IntPtr.Zero" /> = the desktop window (use this for console applications).</param>
            <param name="ClsID">Class identifier of the object to create, that will be used to initialize DirectSound... <see langword="null" /> = use default</param>
            <returns>If the device was successfully initialized, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The device has already been initialized. You must call <see cref="M:ManagedBass.Bass.Free" /> before you can initialize it again.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">There is no available device driver... the device may already be in use.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The specified format is not supported by the device. Try changing the <paramref name="Frequency" /> and <paramref name="Flags" /> parameters.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device has no 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>This function must be successfully called before using any sample, stream or MOD music functions. The recording functions may be used without having called this function.</para>
            <para>Playback is not possible with the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device, but it does allow the use of "decoding channels", eg. to decode files.</para>
            <para>When specifying a class identifier (<paramref name="ClsID"/>), after successful initialization, you can use GetDSoundObject(DSInterface) to retrieve the DirectSound object, and through that access any special interfaces that the object may provide.</para>
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="P:ManagedBass.Bass.CurrentDevice" /> is used to switch the current device.
            When successful, <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> automatically sets the current thread's device to the one that was just initialized.
            </para>
            <para>
            When using the default device (device = -1), <see cref="P:ManagedBass.Bass.CurrentDevice" /> can be used to find out which device it was mapped to.
            On Windows, it'll always be the first device.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Linux, a 'Default' device is hardcoded to device number 1, which uses the default output set in the ALSA config; that could map directly to one of the other devices or it could use ALSA plugins.
            If the IncludeDefaultDevice config option has been enbled, a "Default" device is also available on Windows, who's output will follow default device changes on Windows 7.
            In both cases, the "Default" device will also be the default device (device = -1).
            </para>
            <para>
            The sample format specified in the <paramref name="Frequency" /> and <paramref name="Flags" /> parameters has no effect on the device output on iOS or OSX, and not on Windows unless VxD drivers are used (on Windows 98/95);
            with WDM drivers (on Windows XP/2000/Me/98SE), the output format is automatically set depending on the format of what is played and what the device supports, while on Vista and above, the output format is determined by the user's choice in the Sound control panel.
            On Linux the output device will use the specified format if possible, but will otherwise use a format as close to it as possible.
            If the <see cref="F:ManagedBass.DeviceInitFlags.Frequency"/> flag is specified on iOS or OSX, then the device's output rate will be set to the freq parameter (if possible).
            The <see cref="F:ManagedBass.DeviceInitFlags.Frequency"/> flag has no effect on other platforms.
            <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> can be used to check what the output format actually is.
            </para>
            <para>
            The <paramref name="Win" /> and <paramref name="ClsID" /> parameters are only used on Windows and are ignored on other platforms.
            That applies to the <see cref="F:ManagedBass.DeviceInitFlags.CPSpeakers"/> and <see cref="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment"/> flags too, as the number of available speakers is always accurately detected on the other platforms.
            The <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> flag is also ignored on Linux/OSX/Android/Windows CE, as latency information is available without it.
            The latency is also available without it on iOS, but not immediately following this function call unless the flag is used.
            </para>
            <para>
            The DeviceInitFlags.DMix flag is only available on Linux, and allows multiple applications to share the device (if they all use 'dmix').
            It may also be possible for multiple applications to use exclusive access if the device is capable of hardware mixing.
            If exclusive access initialization fails, the DeviceInitFlags.DMix flag will automatically be tried;
            if that happens, it can be detected via <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> and the <see cref="P:ManagedBass.BassInfo.InitFlags"/>.
            </para>
            <para>On Linux and Windows CE, the length of the device's buffer can be set via the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> config option.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Free"/>
            <seealso cref="P:ManagedBass.Bass.CPUUsage"/>
            <seealso cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)"/>
            <seealso cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)"/>
            <seealso cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.CreateSample(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)"/>
            <seealso cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)"/>
        </member>
        <member name="M:ManagedBass.Bass.Start">
            <summary>
            Starts (or resumes) the output.
            </summary>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called.</exception>
            <remarks>
            <para>The output is automatically started by <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>, so there is no need to use this function unless you have stopped or paused the output.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice"/>) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Pause"/>
            <seealso cref="M:ManagedBass.Bass.Stop"/>
        </member>
        <member name="M:ManagedBass.Bass.Pause">
            <summary>
            Stops the output, pausing all musics/samples/streams.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:ManagedBass.Bass.Start" /> to resume the output and paused channels.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Bass.Stop">
            <summary>
            Stops the output, stopping all musics/samples/streams.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function can be used after <see cref="M:ManagedBass.Bass.Pause" /> to stop the paused channels, so that they will not be resumed the next time <see cref="M:ManagedBass.Bass.Start" /> is called.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Bass.Free">
            <summary>
            Frees all resources used by the output device, including all it's samples, streams, and MOD musics.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized devices before your program exits. It's not necessary to individually free the samples/streams/musics as these are all automatically freed by this function.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetDevice(System.Int32)">
            <summary>
            Retrieves the device that the channel is using.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Recording devices are indicated by the HIWORD of the return value being 1, when this function is called with a HRECORD channel.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetDevice(System.Int32,System.Int32)">
            <summary>
            Changes the device that a stream, MOD music or sample is using.
            </summary>
            <param name="Handle">The channel or sample handle... only HMUSIC, HSTREAM or HSAMPLE are supported.</param>
            <param name="Device">The device to use...0 = no sound, 1 = first real output device.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            All of the channel's current settings are carried over to the new device, but if the channel is using the "with FX flag" DX8 effect implementation,
            the internal state (eg. buffers) of the DX8 effects will be reset. Using the "without FX flag" DX8 effect implementation, the state of the DX8 effects is preserved.
            <para>
            When changing a sample's device, all the sample's existing channels (HCHANNELs) are freed.
            It's not possible to change the device of an individual sample channel.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Device" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Init">The requested device has not been initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The channel is already using the requested device.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels are allowed to use the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The sample format is not supported by the device/drivers.
            If the channel is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.
            </exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.DeviceCount">
            <summary>
            Gets the number of Playback Devices available.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.Volume">
            <summary>
            Gets or sets the current output master volume level... 0 (silent) to 1 (max).
            </summary>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            <para>A return value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>The actual volume level may not be exactly the same as set, due to underlying precision differences.</para>
            <para>
            This function affects the volume level of all applications using the same output device.
            If you wish to only affect the level of your app's sounds, <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />
            and/or the <see cref="P:ManagedBass.Bass.GlobalMusicVolume"/>, <see cref="P:ManagedBass.Bass.GlobalSampleVolume"/> and <see cref="P:ManagedBass.Bass.GlobalStreamVolume"/> config options should be used instead.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no volume control when using the <see cref="F:ManagedBass.Bass.NoSoundDevice">No Sound Device</see>.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">Invalid volume.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.CurrentDevice">
            <summary>
            Gets or sets the device setting of the current thread... 0 = no sound, 1 = first real output device.
            </summary>
            <remarks>
            <para>A return value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system -
            instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </para>
            <para>The functions that use the device selection are the following:
            <see cref="M:ManagedBass.Bass.Free" />, GetDSoundObject(int), <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" />, <see cref="M:ManagedBass.Bass.Start" />, <see cref="M:ManagedBass.Bass.Stop" />, <see cref="M:ManagedBass.Bass.Pause" />, <see cref="P:ManagedBass.Bass.Volume" />, <see cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)" />, <see cref="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)" />, <see cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)" />, <see cref="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)" />, SetEAXParameters, GetEAXParameters.
            It also determines which device is used by a new sample/stream/music: <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" />, <see cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)" />, <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />, etc...
            </para>
            <para>
            When one of the above functions is called, BASS will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized.
            This means that when using a single device, there is no need to use this function;
            BASS will automatically use the device that is initialized.
            Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">A <see cref="T:ManagedBass.DeviceInfo" /> object to retrieve the information into.</param>
            <returns>
            If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog.
            Device 0 is always the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device, so if you should start at device 1 if you only want to list real devices.
            <para><b>Platform-specific</b></para>
            <para>
            On Linux, a "Default" device is hardcoded to device number 1, which uses the default output set in the ALSA config, and the real devices start at number 2.
            That is also the case on Windows when the IncludeDefaultDevice option is enabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.DeviceInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog.
            Device 0 is always the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device, so if you should start at device 1 if you only want to list real devices.
            <para><b>Platform-specific</b></para>
            <para>
            On Linux, a "Default" device is hardcoded to device number 1, which uses the default output set in the ALSA config, and the real devices start at number 2.
            That is also the case on Windows when the IncludeDefaultDevice option is enabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <param name="Info"><see cref="T:ManagedBass.BassInfo"/> object to receive the information.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called.</exception>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice"/>) determines which device this function call applies to.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.Info">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <returns><see cref="T:ManagedBass.BassInfo"/> structure with the retreived information. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called.</exception>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice"/>) determines which device this function call applies to.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)">
            <summary>
            Sets the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">Pointer to the parameters structure. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One or more of the parameters are invalid, make sure all the values are within the valid ranges.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXSetParameters(System.Int32,ManagedBass.IEffectParameter)">
            <summary>
            Sets the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">The parameters structure. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One or more of the parameters are invalid, make sure all the values are within the valid ranges.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)">
            <summary>
            Retrieves the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">Pointer to the parameters structure to fill. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXGetParameters(System.Int32,ManagedBass.IEffectParameter)">
            <summary>
            Retrieves the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">The parameters structure to fill. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXReset(System.Int32)">
            <summary>
            Resets the state of an effect or all effects on a channel.
            </summary>
            <param name="Handle">The effect or channel handle... a HFX, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <remarks>
            This function flushes the internal buffers of the effect(s).
            Effects are automatically reset by <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/>,
            except when called from a "<see cref="F:ManagedBass.SyncFlags.Mixtime"/>" <see cref="T:ManagedBass.SyncProcedure"/>.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)">
            <summary>
            Sets an effect on a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Type">Type of effect, one of <see cref="T:ManagedBass.EffectType" />.</param>
            <param name="Priority">
            The priority of the new FX, which determines it's position in the DSP chain.
            DSP/FX with higher priority are applied before those with lower.
            This parameter has no effect with DX8 effects when the "with FX flag" DX8 effect implementation is used.
            </param>
            <returns>
            If succesful, then the new effect's Handle is returned, else 0 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.NoFX">DX8 effects are unavailable.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The channel's format is not supported by the effect.
            It may be floating-point (without DX9) or more than stereo.
            </exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>
            Multiple effects may be used per channel. Use <see cref="M:ManagedBass.Bass.ChannelRemoveFX(System.Int32,System.Int32)" /> to remove an effect.
            Use <see cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)" /> to set an effect's parameters.
            </para>
            <para>
            Effects can be applied to MOD musics and streams, but not samples.
            If you want to apply an effect to a sample, you could use a stream instead.
            </para>
            <para>
            Depending on the DX8 effect implementation being used by the channel, the channel may have to be stopped before adding or removing DX8 effects on it.
            If necessary, that is done automatically and the channel is resumed afterwards.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DX8 effects are a Windows feature requiring DirectX 8, or DirectX 9 for floating-point support.
            On other platforms, they are emulated by BASS, except for the following which are currently unsupported: DXCompressor, DXGargle, and DX_I3DL2Reverb.
            On Windows CE, only PARAMEQ is supported.
            </para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelLock(System.Int32,System.Boolean)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelRemoveFX(System.Int32,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)"/>
            <seealso cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveFX(System.Int32,System.Int32)">
            <summary>
            Removes an effect from a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="FX">Handle of the effect to remove from the channel (return value of a previous <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" /> call).</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="FX" /> is not valid.</exception>
            <remarks>
            Depending on the DX8 effect implementation being used by the channel, the channel may have to be stopped before removing a DX8 effect on it.
            If necessary, that is done automatically and the channel is resumed afterwards.
            <para><see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)" /> can also be used to remove effects.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXSetPriority(System.Int32,System.Int32)">
            <summary>
            Sets the priority of an effect or DSP function, which determines its position in the DSP chain.
            </summary>
            <param name="Handle">The DSP/FX handle... a HDSP or HFX.</param>
            <param name="Priority">The new priority of the DSP/FX.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <remarks>If there are multiple DSP/FX with the same priority value, they will be applied in the order in which they were given that priority.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Priority is not supported on DX8 effects when the "with FX flag" DX8 effect implementation is used.</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicFree(System.Int32)">
            <summary>
            Frees a MOD music's resources, including any sync/DSP/FX it has.
            </summary>
            <param name="Handle">The MOD music handle.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            </summary>
            <param name="File">The file name from where to load the music.</param>
            <param name="Offset">File offset to load the MOD music from.</param>
            <param name="Length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>
            MO3s are treated and used in exactly the same way as normal MOD musics.
            The advantage of MO3s is that they can be a lot smaller with virtually identical quality.
            Playing a MO3 does not use any more CPU power than playing the original MOD version does.
            The only difference is a slightly longer load time as the samples are being decoded.
            MO3 files are created using the MO3 encoder available at the BASS website.
            </para>
            <para>
            DMO effects (the same as available with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker.
            This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy.
            Of course, the effects require some CPU, so should not be used carelessly if performance is key.
            DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.
            </para>
            <para>
            "Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes.
            The start of a sample may also be ramped-in.
            That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click.
            Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows.
            They are always available on other platforms, except for the following: DXCompressor, DXGargle, and DX_I3DL2Reverb.
            When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="File"/>'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicLoad(System.IntPtr,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats from memory.
            </summary>
            <param name="Memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="Offset">Memory offset to load the MOD music from.</param>
            <param name="Length">Data length.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>
            MO3s are treated and used in exactly the same way as normal MOD musics.
            The advantage of MO3s is that they can be a lot smaller with virtually identical quality.
            Playing a MO3 does not use any more CPU power than playing the original MOD version does.
            The only difference is a slightly longer load time as the samples are being decoded.
            MO3 files are created using the MO3 encoder available at the BASS website.
            </para>
            <para>
            DMO effects (the same as available with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker.
            This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy.
            Of course, the effects require some CPU, so should not be used carelessly if performance is key.
            DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.
            </para>
            <para>
            "Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes.
            The start of a sample may also be ramped-in.
            That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click.
            Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.
            </para>
            <para>
            When loading a MOD music from memory, Bass does not use the memory after it has loaded the MOD music.
            So you can do whatever you want with the memory after calling this function.
            This means there is no need to pin the memory buffer for this method.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows.
            They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb.
            When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen"><paramref name="Memory"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat"><paramref name="Memory"/>'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicLoad(System.Byte[],System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats from memory.
            </summary>
            <param name="Memory">byte[] containing the music data.</param>
            <param name="Offset">Memory offset to load the MOD music from.</param>
            <param name="Length">Data length.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>
            MO3s are treated and used in exactly the same way as normal MOD musics.
            The advantage of MO3s is that they can be a lot smaller with virtually identical quality.
            Playing a MO3 does not use any more CPU power than playing the original MOD version does.
            The only difference is a slightly longer load time as the samples are being decoded.
            MO3 files are created using the MO3 encoder available at the BASS website.
            </para>
            <para>
            DMO effects (the same as available with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker.
            This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy.
            Of course, the effects require some CPU, so should not be used carelessly if performance is key.
            DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.
            </para>
            <para>
            "Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes.
            The start of a sample may also be ramped-in.
            That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click.
            Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.
            </para>
            <para>
            When loading a MOD music from memory, Bass does not use the memory after it has loaded the MOD music.
            So you can do whatever you want with the memory after calling this function.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows.
            They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb.
            When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen"><paramref name="Memory"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat"><paramref name="Memory"/>'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginGetInfo(System.Int32)">
            <summary>
            Retrieves information on a plugin.
            </summary>
            <param name="Handle">The plugin handle - or 0 to retrieve native BASS information.</param>
            <returns>An instance of <see cref="T:ManagedBass.PluginInfo" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The plugin information does not change, so the returned info remains valid for as long as the plugin is loaded.
            <para>Note: There is no guarantee that the check is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginLoad(System.String)">
            <summary>
            Plugs on "add-on" into the standard stream and sample creation functions.
            </summary>
            <param name="FilePath">Filename of the add-on/plugin.</param>
            <returns>If successful, the loaded plugin's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            There are 2 ways in which add-ons can provide support for additional formats.
            They can provide dedicated functions to create streams of the specific format(s) they support and/or they can plug into the standard stream creation functions:
            <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />, <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />,
            and <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            This function enables the latter method.
            Both methods can be used side by side.
            The obvious advantage of the plugin system is convenience, while the dedicated functions can provide extra options that are not possible via the shared function interfaces.
            See an add-on's documentation for more specific details on it.
            </para>
            <para>As well as the stream creation functions, plugins also add their additional format support to <see cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)" />.</para>
            <para>Information on what file formats a plugin supports is available via the <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" /> function.</para>
            <para>
            When using multiple plugins, the stream/sample creation functions will try each of them in the order that they were loaded via this function, until one that accepts the file is found.
            When an add-on is already loaded (eg. if you are using functions from it), the plugin system will use the same instance (the reference count will just be incremented); there will not be 2 copies of the add-on in memory.
            </para>
            <para>Note: Only stream/music add-ons are loaded (e.g. BassFx or BassMix are NOT loaded).</para>
            <para><b>Platform-specific:</b></para>
            <para>
            Dynamic libraries are not permitted on iOS, so add-ons are provided as static libraries instead, which means this function has to work a little differently.
            The add-on needs to be linked into the executable, and a "plugin" symbol declared and passed to this function (instead of a filename).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="FilePath" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="FilePath" /> is not a plugin.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The <paramref name="FilePath" /> is already plugged in.</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginFree(System.Int32)">
            <summary>
            Unplugs an add-on.
            </summary>
            <param name="Handle">The plugin handle... 0 = all plugins.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            If there are streams created by a plugin in existence when it is being freed, the streams will automatically be freed too.
            Samples loaded by the plugin are unaffected as the plugin has nothing to do with them once they are loaded (the sample data is already fully decoded).
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginLoadDirectory(System.String)">
            <summary>
            Loads all BASS add-ons (bass*.dll or libbass*.so or libbass*.dylib) contained in the specified directory.
            </summary>
            <param name="Folder">The directory in which to search for BASS add-ons.</param>
            <returns>A Dictionary of filename and plugin handle.</returns>
        </member>
        <member name="M:ManagedBass.Bass.RecordInit(System.Int32)">
            <summary>
            Initializes a recording device.
            </summary>
            <param name="Device">The device to use... -1 = default device, 0 = first. <see cref="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> or <see cref="P:ManagedBass.Bass.RecordingDeviceCount" /> can be used to get the total number of devices.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <remarks>
            This function must be successfully called before using the recording features.
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            <see cref="P:ManagedBass.Bass.CurrentRecordingDevice" /> is used to switch the current recording device.
            When successful, <see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> automatically sets the current thread's device to the one that was just initialized
            </para>
            <para>
            When using the default device (device = -1), <see cref="P:ManagedBass.Bass.CurrentRecordingDevice" /> can be used to find out which device it was mapped to.
            On Windows, it'll always be the first device.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            Recording support requires DirectX 5 (or above) on Windows.
            On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config;
            that could map directly to one of the other devices or it could use ALSA plugins.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.DirectX">A sufficient version of DirectX is not installed.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Device" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The device has already been initialized. <see cref="M:ManagedBass.Bass.RecordFree" /> must be called before it can be initialized again.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">There is no available device driver.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordFree">
            <summary>
            Frees all resources used by the recording device.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized recording devices before your program exits.</para>
            <para>When using multiple recording devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentRecordingDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="Frequency">The sample rate to record at.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, etc.</param>
            <param name="Flags">Any combination of <see cref="F:ManagedBass.BassFlags.Byte"/>, <see cref="F:ManagedBass.BassFlags.Float"/> and <see cref="F:ManagedBass.BassFlags.RecordPause"/>.</param>
            <param name="Procedure">The user defined function to receive the recorded sample data... can be <see langword="null" /> if you do not wish to use a callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <remarks>
            Use <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> to stop the recording, and <see cref="M:ManagedBass.Bass.ChannelPause(System.Int32)" /> to pause it.
            Recording can also be started in a paused state (via the <see cref="F:ManagedBass.BassFlags.RecordPause"/> flag), allowing DSP/FX to be set on it before any data reaches the callback function.
            <para>The sample data will generally arrive from the recording device in blocks rather than in a continuous stream, so when specifying a very short period between callbacks, some calls may be skipped due to there being no new data available since the last call.</para>
            <para>
            When not using a callback (proc = <see langword="null" />), the recorded data is instead retrieved via <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            To keep latency at a minimum, the amount of data in the recording buffer should be monitored (also done via <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />, with the <see cref="F:ManagedBass.DataFlags.Available"/> flag) to check that there is not too much data;
            freshly recorded data will only be retrieved after the older data in the buffer is.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            Multiple simultaneous recordings can be made from the same device on Windows XP and later, but generally not on older Windows.
            Multiple simultaneous recordings are possible on iOS and OSX, but may not always be on Linux or Windows CE.
            On OSX and iOS, the device is instructed (when possible) to deliver data at the period set in the HIWORD of flags, even when a callback function is not used.
            On other platforms, it is up the the system when data arrives from the device.
            </para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Busy">
            The device is busy.
            An existing recording must be stopped before starting another one.
            Multiple simultaneous recordings can be made from the same device on Windows XP and Vista, but generally not on older Windows.
            </exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">
            The recording device is not available.
            Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.
            </exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The specified format is not supported.
            If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point recording is not supported.
            </exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int32,ManagedBass.RecordProcedure,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="Frequency">The sample rate to record at.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo.</param>
            <param name="Flags">Any combination of <see cref="F:ManagedBass.BassFlags.Byte"/>, <see cref="F:ManagedBass.BassFlags.Float"/> and <see cref="F:ManagedBass.BassFlags.RecordPause"/>.</param>
            <param name="Period">
            Set the period (in milliseconds) between calls to the callback function (<see cref="T:ManagedBass.RecordProcedure" />).
            The minimum period is 5ms, the maximum the maximum is half the <see cref="P:ManagedBass.Bass.RecordingBufferLength"/> setting.
            If the period specified is outside this range, it is automatically capped. The default is 100ms.
            </param>
            <param name="Procedure">The user defined function to receive the recorded sample data... can be <see langword="null" /> if you do not wish to use a callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Busy">
            The device is busy.
            An existing recording must be stopped before starting another one.
            Multiple simultaneous recordings can be made from the same device on Windows XP and Vista, but generally not on older Windows.
            </exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">
            The recording device is not available.
            Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.
            </exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The specified format is not supported.
            If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point recording is not supported.
            </exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.CurrentRecordingDevice">
            <summary>
            Gets or Sets the recording device setting in the current thread... 0 = first recording device.
            </summary>
            <remarks>
            <para>A value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.  Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The functions that use the recording device selection are the following:
            <see cref="M:ManagedBass.Bass.RecordFree" />, <see cref="M:ManagedBass.Bass.RecordGetInfo(ManagedBass.RecordInfo@)" />, <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)" />, <see cref="M:ManagedBass.Bass.RecordGetInputName(System.Int32)" />, <see cref="M:ManagedBass.Bass.RecordSetInput(System.Int32,ManagedBass.InputFlags,System.Single)" />, <see cref="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)" />.</para>
            <para>When one of the above functions is called, BASS will check the current thread's recording device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized.
            This means that when using a single device, there is no need to use this function - BASS will automatically use the device that's initialized.
            Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Device">Specified device number is invalid.</exception>
            <seealso cref="M:ManagedBass.Bass.RecordInit(System.Int32)"/>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">A <see cref="T:ManagedBass.DeviceInfo" /> object to retreive the information into.</param>
            <returns>
            If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            This function can be used to enumerate the available recording devices for a setup dialog.
            <para><b>Platform-specific</b></para>
            <para>
            Recording support requires DirectX 5 (or above) on Windows.
            On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.DirectX">A sufficient version of DirectX is not installed.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.DeviceInfo" /> structure is returned.A value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            Recording support requires DirectX 5 (or above) on Windows.
            On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.DirectX">A sufficient version of DirectX is not installed.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInfo(ManagedBass.RecordInfo@)">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <param name="info">A <see cref="T:ManagedBass.RecordInfo" /> object to retrieve the information into.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
        </member>
        <member name="P:ManagedBass.Bass.RecordingInfo">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <returns>An instance of the <see cref="T:ManagedBass.RecordInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
        </member>
        <member name="P:ManagedBass.Bass.RecordingBufferLength">
            <summary>
            The Buffer Length for recording channels in milliseconds... 1000 (min) - 5000 (max). default = 2000.
            </summary>
            <remarks>
            If the Length specified is outside this range, it is automatically capped.
            Unlike a playback Buffer, where the aim is to keep the Buffer full, a recording
            Buffer is kept as empty as possible and so this setting has no effect on latency.
            Unless processing of the recorded data could cause significant delays, or you want to
            use a large recording period with <see cref="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)"/>, there should be no need to increase this.
            Using this config option only affects the recording channels that are created afterwards,
            not any that have already been created.
            So you can have channels with differing Buffer lengths by using this config option each time before creating them.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.RecordingDeviceCount">
            <summary>
            No of Recording devices available.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)">
            <summary>
            Retrieves the settings of a recording input source.
            </summary>
            <param name="Input">The input to get the settings of... 0 = first, -1 = master.</param>
            <param name="Volume">Reference to a variable to receive the current volume.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If successful, then the settings are returned.
            The <see cref="F:ManagedBass.InputFlags.Off"/> flag will be set if the input is disabled, otherwise the input is enabled.
            The type of input (see <see cref="T:ManagedBass.InputTypeFlags" />) is also indicated in the high 8-bits.
            Use <see cref="F:ManagedBass.InputTypeFlags.InputTypeMask"/> to test the return value.
            If the volume is requested but not available, volume will receive -1.
            </returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            The input type information is only available on Windows.
            There is no "what you hear" type of input defined;
            if the device has one, it will typically come under <see cref="F:ManagedBass.InputTypeFlags.Analog"/> or <see cref="F:ManagedBass.InputTypeFlags.Undefined"/>.
            </para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">A master input is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInput(System.Int32)">
            <summary>
            Retrieves the settings of a recording input source (does not retrieve Volume).
            </summary>
            <param name="Input">The input to get the settings of... 0 = first, -1 = master.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If successful, then the settings are returned.
            The <see cref="F:ManagedBass.InputFlags.Off"/> flag will be set if the input is disabled, otherwise the input is enabled.
            The type of input (see <see cref="T:ManagedBass.InputTypeFlags" />) is also indicated in the high 8-bits.
            Use <see cref="F:ManagedBass.InputTypeFlags.InputTypeMask"/> to test the return value.
            If the volume is requested but not available, volume will receive -1.
            </returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            The input type information is only available on Windows.
            There is no "what you hear" type of input defined;
            if the device has one, it will typically come under <see cref="F:ManagedBass.InputTypeFlags.Analog"/> or <see cref="F:ManagedBass.InputTypeFlags.Undefined"/>.
            </para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">A master input is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInputName(System.Int32)">
            <summary>
            Retrieves the text description of a recording input source.
            </summary>
            <param name="Input">The input to get the description of... 0 = first, -1 = master.</param>
            <returns>If succesful, then the description is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            The returned string is in ANSI or UTF-8 form on Windows, depending on the UnicodeDeviceInformation setting.
            It is in UTF-16 form ("WCHAR" rather than "char") on Windows CE, and in UTF-8 form on other platforms.
            </para>
            <para>On OSX, there is no master input (-1).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">A master input is not available.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordSetInput(System.Int32,ManagedBass.InputFlags,System.Single)">
            <summary>
            Adjusts the settings of a recording input source.
            </summary>
            <param name="Input">The input to adjust the settings of... 0 = first, -1 = master.</param>
            <param name="Setting">The new setting... a combination of <see cref="T:ManagedBass.InputFlags"/>.</param>
            <param name="Volume">The volume level... 0 (silent) to 1 (max), less than 0 = leave current.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The actual volume level may not be exactly the same as requested, due to underlying precision differences.
            <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)" /> can be used to confirm what the volume is.
            </para>
            <para>The volume curve used by this function is always linear, the <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.</para>
            <para>Changes made by this function are system-wide, ie. other software using the device will be affected by it.</para>
            <para><b>Platform-specific</b></para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> or <paramref name="Volume" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundcard/driver doesn't allow you to change the input or it's volume.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)">
            <summary>
            Creates/initializes a playback channel for a sample.
            </summary>
            <param name="Sample">Handle of the sample to play.</param>
            <param name="OnlyNew">Do not recycle/override one of the sample's existing channels?</param>
            <returns>If successful, the handle of the new channel is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Use <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" /> and <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" /> to set a sample's default attributes, which are used when creating a channel.
            After creation, a channel's attributes can be changed via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />, <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)" /> and <see cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)" />.
            <see cref="M:ManagedBass.Bass.Apply3D" /> should be called before starting playback of a 3D sample, even if you just want to use the default settings.
            </para>
            <para>
            If a sample has a maximum number of simultaneous playbacks of 1 (the max parameter was 1 when calling <see cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Bass.CreateSample(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)" />), then the HCHANNEL handle returned will be identical to the HSAMPLE handle.
            That means you can use the HSAMPLE handle with functions that usually require a HCHANNEL handle, but you must still call this function first to initialize the channel.
            </para>
            <para>
            A sample channel is automatically freed when it's overridden by a new channel, or when stopped manually via <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" />, <see cref="M:ManagedBass.Bass.SampleStop(System.Int32)" /> or <see cref="M:ManagedBass.Bass.Stop" />.
            If you wish to stop a channel and re-use it, it should be paused (<see cref="M:ManagedBass.Bass.ChannelPause(System.Int32)" />) instead of stopped.
            Determining whether a channel still exists can be done by trying to use the handle in a function call, eg. <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" />.
            </para>
            <para>When channel overriding has been enabled via an override flag and there are multiple candidates for overriding (eg. with identical volume), the oldest of them will be chosen to make way for the new channel.</para>
            <para>
            The new channel will have an initial state of being paused (<see cref="F:ManagedBass.PlaybackState.Paused"/>).
            This prevents the channel being claimed by another call of this function before it has been played, unless it gets overridden due to a lack of free channels.
            </para>
            <para>All of a sample's channels share the same sample data, and just have their own individual playback state information (volume/position/etc).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Sample" /> is not a valid sample handle.</exception>
            <exception cref="F:ManagedBass.Errors.NoChannel">The sample has no free channels... the maximum number of simultaneous playbacks has been reached, and no override flag was specified for the sample or onlynew = <see langword="true" />.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The sample's minimum time gap (<see cref="T:ManagedBass.SampleInfo" />) has not yet passed since the last channel was created.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleFree(System.Int32)">
            <summary>
            Frees a sample's resources.
            </summary>
            <param name="Handle">The sample handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.IntPtr)">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">Pointer to the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Byte[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">byte[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Int32[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">int[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Int16[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">short[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Single[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">float[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateSample(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Initiates the creation of a user generated sample.
            </summary>
            <param name="Length">The sample's length, in bytes.</param>
            <param name="Frequency">The default sample rate.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, etc... More than stereo requires WDM drivers in Windows.</param>
            <param name="Max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the override flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The sample's initial content is undefined.
            <see cref="M:ManagedBass.Bass.SampleSetData(System.Int32,System.IntPtr)" /> should be used to set the sample's data.
            </para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Max" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.IntPtr)">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">Pointer to a buffer to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Byte[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">byte[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Int16[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">short[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Int32[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">int[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Single[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">float[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.SampleInfo" /> class to store the sample information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetInfo(System.Int32)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="Handle">The sample handle.</param>
            <returns>An instance of the <see cref="T:ManagedBass.SampleInfo" /> class is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)">
            <summary>
            Sets a sample's default attributes.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.SampleInfo" /> class containing the sample information to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Use this function and <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" /> to edit a sample's default attributes.
            Changing a sample's default attributes does not affect any existing channels, it only affects channels subsequently created via <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />.
            The exception is the VAM settings, changes to that apply to all the sample's channels at their next playback (<see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />).
            Use <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" /> and <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)" /> to change the attributes of an existing sample channel.
            </para>
            <para>
            The sample's maximum number of simultaneous playbacks can be changed via the <see cref="F:ManagedBass.SampleInfo.Max"/> member.
            If the new maximum is lower than the existing number of channels, the channels will remain existing until they are stopped.
            </para>
            <para>
            <see cref="F:ManagedBass.SampleInfo.Length"/>, <see cref="F:ManagedBass.SampleInfo.OriginalResolution"/> and <see cref="F:ManagedBass.SampleInfo.Channels"/> can't be modified - any changes are ignored.
            <see cref="F:ManagedBass.BassFlags.Byte"/>, <see cref="F:ManagedBass.BassFlags.Mono"/>, <see cref="F:ManagedBass.BassFlags.Bass3D"/>, <see cref="F:ManagedBass.BassFlags.MuteMax"/>, BassFlags.SoftwareMixing and <see cref="F:ManagedBass.BassFlags.VAM"/> also cannot be changed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetChannels(System.Int32)">
            <summary>
            Retrieves an array of a sample's existing channels.
            </summary>
            <param name="Handle">Handle of the sample.</param>
            <returns>
            If successful, the array of existing channels is returned (which might have zero elements), else <see langword="null" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            This overload only returns the existing channels in the array.
            <para>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid sample handle.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleStop(System.Int32)">
            <summary>
            Stops all instances of a sample.
            </summary>
            <param name="Handle">The sample handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid sample handle.</exception>
            <remarks>If a sample is playing simultaneously multiple times, calling this function will stop them all, which is obviously simpler than calling <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> multiple times.</remarks>
        </member>
        <member name="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            </summary>
            <param name="File">The file name to load the sample from.</param>
            <param name="Offset">File offset to load the sample from.</param>
            <param name="Length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="MaxNoOfPlaybacks">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />).</para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="MaxNoOfPlaybacks" /> and/or <paramref name="Length" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="File" />'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleLoad(System.IntPtr,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="Memory">An unmanaged IntPtr to the allocated memory block at which the sample data resides.</param>
            <param name="Offset">File offset to load the sample from.</param>
            <param name="Length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="MaxNoOfPlaybacks">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the override flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/> flags.</param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />).</para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)" />.</para>
            <para>There is no need to pin the memory buffer for this method, since after loading a sample from memory, the memory can safely be discarded, as a copy is made.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="MaxNoOfPlaybacks" /> and/or <paramref name="Length" /> is invalid. Specifying <paramref name="Length" /> is mandatory when loading from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="Memory" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="Memory" />'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleLoad(System.Byte[],System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="Memory">A byte[] with the sample data to load.</param>
            <param name="Offset">File offset to load the sample from.</param>
            <param name="Length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="MaxNoOfPlaybacks">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the override flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/> flags.</param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />).</para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)" />.</para>
            <para>The <paramref name="Memory"/> can be safely discarded after calling this method, as a copy of it is made by Bass.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="MaxNoOfPlaybacks" /> and/or <paramref name="Length" /> is invalid. Specifying <paramref name="Length" /> is mandatory when loading from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="Memory" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="Memory" />'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)">
            <summary>
            Retrieves the decoding/download/end position of a file stream.
            </summary>
            <param name="Handle">The stream's handle.</param>
            <param name="Mode">The file position to retrieve. One of <see cref="T:ManagedBass.FileStreamPosition" /> values.</param>
            <returns>If succesful, then the requested file position is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>ID3 tags (both v1 and v2) and WAVE headers, as well as any other rubbish at the start of the file, are excluded from the calculations of this function.</para>
            <para>This is useful for average bitrate calculations, but it means that the <see cref="F:ManagedBass.FileStreamPosition.Current"/> position may not be the actual file position - the <see cref="F:ManagedBass.FileStreamPosition.Start"/> position can be added to it to get the actual file position.</para>
            <para>
            When streaming a file from the internet or a "buffered" user file stream, the entire file is downloaded even if the audio data ends before that, in case there are tags to be read.
            This means that the <see cref="F:ManagedBass.FileStreamPosition.Download"/> position may go beyond the <see cref="F:ManagedBass.FileStreamPosition.End"/> position.
            </para>
            <para>
            It's unwise to use this function (with mode = <see cref="F:ManagedBass.FileStreamPosition.Current"/>) for syncing purposes because it returns the position that's being decoded, not the position that's being heard.
            Use <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> for syncing instead.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotFile">The stream is not a file stream.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested file position/status is not available.</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)">
            <summary>
            Creates a user sample stream.
            </summary>
            <param name="Frequency">The default sample rate. The sample rate can be changed using <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the Speaker flags are ignored.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedure">The user defined stream writing function (see <see cref="T:ManagedBass.StreamProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Sample streams allow any sample data to be played through Bass, and are particularly useful for playing a large amount of sample data without requiring a large amount of memory.
            If you wish to play a sample format that BASS does not support, then you can create a stream and decode the sample data into it.
            </para>
            <para>
            Bass can automatically stream MP3, MP2, MP1, OGG, WAV and AIFF files, using <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />, and also from HTTP and FTP servers,
            using <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />, <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> allows streaming from other sources too.
            </para>
            <para>However, the callback method must deliver PCM sample data as specified, so opening an MP3 file and just passing that file data will not work here.</para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)">
            <summary>
            Creates a Dummy or Push stream.
            </summary>
            <param name="Frequency">The default sample rate. The sample rate can be changed using <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="ProcedureType">The type of stream.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with <see cref="F:ManagedBass.BassFlags.Decode"/> flag) can be used to apply DSP/FX processing to any sample data,
            by setting DSP/FX on the stream and feeding the data through <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            <para>The dummy stream should have the same sample format as the data being fed through it.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">Pointer to the sample data (<see cref="F:System.IntPtr.Zero"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">byte sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">short sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">int sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">float sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">Pointer to the file data.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">byte buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">short buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">int buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">float buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamFree(System.Int32)">
            <summary>
            Frees a sample stream's resources, including any SYNC/DSP/FX it has.
            </summary>
            <param name="Handle"> The stream handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="T:ManagedBass.Enc.ACMFormatFlags">
            <summary>
            ACM Format flags to be used with <see cref="M:ManagedBass.Enc.BassEnc.GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,ManagedBass.Enc.ACMFormatFlags,ManagedBass.WaveFormatTag)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.ACMFormatFlags.Unicode">
            <summary>
            Unicode (16-bit characters) option.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.ACMFormatFlags.NoACM">
            <summary>
            No ACM.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.ACMFormatFlags.Default">
            <summary>
            Use the format as default selection.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.ACMFormatFlags.SameSampleRate">
            <summary>
            Only list formats with same sample rate as the source channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.ACMFormatFlags.SameChannels">
            <summary>
            Only list formats with same number of channels (eg. mono/stereo).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.ACMFormatFlags.Suggest">
            <summary>
            Suggest a format (HIWORD=format tag - use one of the WAVEFormatTag flags).
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.BassEnc">
            <summary>
            Wraps BassEnc: bassenc.dll
            </summary>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc.ACMLoad">
            <summary>
            ACM codec name to give priority for the formats it supports (e.g. 'l3codecp.acm').
            </summary>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,ManagedBass.Enc.ACMFormatFlags,ManagedBass.WaveFormatTag)">
            <summary>
            Presents the user with a list of available ACM (Audio Compression Manager) codec output formats to choose from.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Format">Pointer to the format buffer.</param>
            <param name="FormatLength">Size of the format buffer. If this is 0, then a suggested format buffer length is returned (which is the maximum length of all installed codecs), without displaying the codec selector.</param>
            <param name="Title">Window title for the selector... <see langword="null" /> = "Choose the output format".</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.ACMFormatFlags"/>.</param>
            <param name="Encoding">Can be used to restrict the choice to a particular format tag. This is required with <see cref="F:ManagedBass.Enc.ACMFormatFlags.Suggest"/>, and is optional otherwise.</param>
            <returns>
            If successful, the user-selected codec format details are put in the provided buffer and the length of the format details is returned, else 0 is returned. 
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If <paramref name="FormatLength"/> is 0, then the suggested format buffer size is returned.
            </returns>
            <remarks>
            This function presents the user with a list of available ACM codecs to choose from, given the sample format of the channel.
            The details of the chosen codec's output are returned in the Format buffer, which can then be used with <see cref="M:ManagedBass.Enc.BassEnc.EncodeStartACM(System.Int32,System.IntPtr,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Enc.BassEnc.EncodeStartACM(System.Int32,System.IntPtr,ManagedBass.Enc.EncodeFlags,System.String)" /> to begin encoding.
            <para>
            The <paramref name="Format" /> buffer contents are actually a WAVEFORMATEX or ACMFORMAT structure.
            If writing the encoder output to a WAVE file, the Format buffer contents would be the format chunk ("fmt") of the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There are no codecs available that will accept the channel's format.</exception>
            <exception cref="F:ManagedBass.Errors.AcmCancel">The user pressed the "cancel" button.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStartACM(System.Int32,System.IntPtr,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)">
            <summary>
            Sets up an encoder on a channel, using an ACM codec and sending the output to a user defined function.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Format">ACM codec output format (as returned by <see cref="M:ManagedBass.Enc.BassEnc.GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,ManagedBass.Enc.ACMFormatFlags,ManagedBass.WaveFormatTag)" />).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="Procedure">Callback function to receive the encoded data.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The ACM encoder allows installed ACM (Audio Compression Manager) codecs to be used for encoding.
            The codec used is determined by the contents of the Format parameter. 
            The <see cref="M:ManagedBass.Enc.BassEnc.GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,ManagedBass.Enc.ACMFormatFlags,ManagedBass.WaveFormatTag)" /> function can be used to initialize that.
            <para>
            Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel.
            That means when you play the channel (or call <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            The encoding is performed in the DSP callback.
            There isn't a separate process doing the encoding, as when using an external encoder via <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />.
            </para>
            <para>
            By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed.
            That can be changed using the <see cref="P:ManagedBass.Enc.BassEnc.DSPPriority"/> config option.
            </para>
            <para>
            Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> function.
            Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag or the <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetPaused(System.Int32,System.Boolean)" /> function.
            </para>
            <para>
            When queued encoding is enabled via the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> flag, the DSP system or <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> call will just buffer the data, and the data will then be fed to the encoder by another thread.
            The buffer will grow as needed to hold the queued data, up to a limit specified by the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> config option.
            If the limit is exceeded (or there is no free memory), data will be lost;
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to be notified of that occurrence.
            The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)" />.
            </para>
            <para>When done encoding, use <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> to close the encoder.</para>
            <para>
            Multiple encoders can be set on a channel.
            For simplicity, the encoder functions will accept either an encoder handle or a channel handle.
            When using a channel handle, the function is applied to all encoders that are set on that channel.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The codec specified in <paramref name="Format" /> couldn't be initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStartACM(System.Int32,System.IntPtr,ManagedBass.Enc.EncodeFlags,System.String)">
            <summary>
            Sets up an encoder on a channel, using an ACM codec and writing the output to a file.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Format">ACM codec output format (as returned by <see cref="M:ManagedBass.Enc.BassEnc.GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,ManagedBass.Enc.ACMFormatFlags,ManagedBass.WaveFormatTag)" />).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="FileName">The filename to write.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The ACM encoder allows installed ACM (Audio Compression Manager) codecs to be used for encoding.
            The codec used is determined by the contents of the Format parameter. 
            The <see cref="M:ManagedBass.Enc.BassEnc.GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,ManagedBass.Enc.ACMFormatFlags,ManagedBass.WaveFormatTag)" /> function can be used to initialize that.
            <para>
            Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel.
            That means when you play the channel (or call <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            The encoding is performed in the DSP callback.
            There isn't a separate process doing the encoding, as when using an external encoder via <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />.
            </para>
            <para>
            By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed.
            That can be changed using the <see cref="P:ManagedBass.Enc.BassEnc.DSPPriority"/> config option.
            </para>
            <para>
            Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> function.
            Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag or the <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetPaused(System.Int32,System.Boolean)" /> function.
            </para>
            <para>
            When queued encoding is enabled via the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> flag, the DSP system or <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> call will just buffer the data, and the data will then be fed to the encoder by another thread.
            The buffer will grow as needed to hold the queued data, up to a limit specified by the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> config option.
            If the limit is exceeded (or there is no free memory), data will be lost;
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to be notified of that occurrence.
            The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)" />.
            </para>
            <para>When done encoding, use <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> to close the encoder.</para>
            <para>
            Multiple encoders can be set on a channel.
            For simplicity, the encoder functions will accept either an encoder handle or a channel handle.
            When using a channel handle, the function is applied to all encoders that are set on that channel.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The codec specified in <paramref name="Format" /> couldn't be initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Create">The file couldn't be created.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc.Version">
            <summary>
            Gets the Version of BassEnc that is loaded.
            </summary>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc.DSPPriority">
            <summary>
            Encoder DSP priority (default -1000) which determines where in the DSP chain the encoding is performed. 
            </summary>
            <remarks>
            All DSP with a higher priority will be present in the encoding.
            Changes only affect subsequent encodings, not those that have already been started.
            </remarks>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc.Queue">
            <summary>
            The maximum queue Length of the async encoder (default 10000, 0 = Unlimited) in milliseconds.
            </summary>
            <remarks>
            When queued encoding is enabled, the queue's Buffer will grow as needed to hold the queued data, up to a limit specified by this config option.
            Changes only apply to new encoders, not any already existing encoders.
            </remarks>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc.CastTimeout">
            <summary>
            The time to wait (in milliseconds) to send data to a cast server (default 5000ms)
            </summary>
            <remarks>
            When an attempt to send data is timed-out, the data is discarded. 
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)"/> can be used to receive a notification of when this happens.
            Changes take immediate effect.
            </remarks>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc.CastProxy">
            <summary>
            Proxy server settings when connecting to Icecast and Shoutcast (in the form of "[User:Password@]server:port"... <see langword="null"/> (default) = don't use a proxy but a direct connection).
            </summary>
            <remarks>
            If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.
            This setting affects how the following functions connect to servers: <see cref="M:ManagedBass.Enc.BassEnc.CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/>, <see cref="M:ManagedBass.Enc.BassEnc.CastGetStats(System.Int32,ManagedBass.Enc.EncodeStats,System.String)"/>, <see cref="M:ManagedBass.Enc.BassEnc.CastSetTitle(System.Int32,System.String,System.String)"/>.
            When a proxy server is used, it needs to support the HTTP 'CONNECT' method.
            The default setting is <see langword="null"/> (do not use a proxy).
            Changes take effect from the next internet stream creation call.
            </remarks>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.ServerInit(System.Int32,System.String,System.Int32,System.Int32,ManagedBass.Enc.EncodeServer,ManagedBass.Enc.EncodeClientProcedure,System.IntPtr)">
            <summary>
            Initializes a server to send an encoder's output to connecting clients.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Port">
            The IP address and port number to accept client connections on... "xxx.xxx.xxx.xxx:port", <see langword="null" /> = an available port on all local addresses.
            The IP address should be local and the port number should be lower than 65536.
            If the address is "0.0.0.0" or omitted, then the server will accept connections on all local addresses.
            If the port is "0" or omitted, then an available port will be assigned.
            </param>
            <param name="Buffer">The server's buffer length in bytes.</param>
            <param name="Burst">The amount of buffered data to send to new clients. This will be capped at the size of the buffer.</param>
            <param name="Flags"><see cref="T:ManagedBass.Enc.EncodeServer"/> flags.</param>
            <param name="Procedure">Callback function to receive notification of clients connecting and disconnecting... <see langword="null" /> = no callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new server's port number is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function allows remote (or local) clients to receive the encoder's output by setting up a TCP server for them to connect to, using <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> for example. 
            Connections can be refused by the <see cref="T:ManagedBass.Enc.EncodeClientProcedure" /> callback function, and already connected clients can be kicked with the <see cref="M:ManagedBass.Enc.BassEnc.ServerKick(System.Int32,System.String)" /> function.
            </para>
            <para>
            The server buffers the data that it receives from the encoder, and the data is then sent from the buffer to the connected clients.
            The buffer should be at least big enough to account for the time that it takes for the clients to receive the data.
            If a client falls too far behind (beyond the buffer length), it will miss some data.
            When a client connects, buffered data can be "burst" to the client, allowing it to prebuffer and begin playback more quickly.
            </para>
            <para>
            An encoder needs to be started, but with no data yet sent to it, before using this function to setup the server.
            If <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" /> is used, the encoder should be setup to write its output to STDOUT.
            Due to the length restrictions of WAVE headers/files, the encoder should also be started with the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag, and the sample format details sent via the command-line.
            </para>
            <para>
            Normally, BASSenc will produce the encoded data (with the help of an encoder) that is sent to a clients, but it is also possible to send already encoded data (without first decoding and re-encoding it) via the PCM encoding option.
            The encoder can be set on any BASS channel, as rather than feeding on sample data from the channel, <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> would be used to feed in the already encoded data.
            BASSenc does not know what the data's bitrate is in that case, so it is up to the user to process the data at the correct rate (real-time speed).
            </para>
            <para><b>Platform-specific</b></para>
            <para>This function is not available on Windows CE.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">There is already a server set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Port" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Busy">The port is in use.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.ServerKick(System.Int32,System.String)">
            <summary>
            Kicks clients from a server.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Client">The client(s) to kick... "" (empty string) = all clients. Unless a port number is included, this string is compared with the start of the connected clients' IP address.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The clients may not be kicked immediately, but shortly after the call.
            If the server has been setup with an <see cref="T:ManagedBass.Enc.EncodeClientProcedure" /> callback function, that will receive notification of the disconnections.
            </para>
            <para><b>Platform-specific</b></para>
            <para>This function is not available on Windows CE.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No matching clients were found.</exception>
        </member>
        <member name="F:ManagedBass.Enc.BassEnc.MimeMp3">
            <summary>
            Mime type for Mp3.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.BassEnc.MimeOgg">
            <summary>
            Mime type for Ogg.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.BassEnc.MimeAac">
            <summary>
            Mime type for Aac.
            </summary>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.CastGetStats(System.Int32,ManagedBass.Enc.EncodeStats,System.String)">
            <summary>
            Retrieves stats from the Shoutcast or Icecast server.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Type">The type of stats to retrieve.</param>
            <param name="Password">Password when retrieving Icecast server stats... <see langword="null" /> = use the password provided in the <see cref="M:ManagedBass.Enc.BassEnc.CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)" /> call. A username can also be included in the form of "username:password". </param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The stats are returned in XML format.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There isn't a cast of the requested type set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with the <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Initializes sending an encoder's output to a Shoutcast or Icecast server.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Server">The server to send to, in the form of "address:port" (Shoutcast v1) resp. "address:port,sid" (Shoutcast v2) or "address:port/mount" (Icecast).</param>
            <param name="Password">The server password. A username can be included in the form of "username:password" when connecting to an Icecast or Shoutcast 2 server.</param>
            <param name="Content">
            The MIME type of the encoder output.
            <para><see cref="F:ManagedBass.Enc.BassEnc.MimeMp3"/>, <see cref="F:ManagedBass.Enc.BassEnc.MimeOgg"/> or <see cref="F:ManagedBass.Enc.BassEnc.MimeAac"/>.</para>
            </param>
            <param name="Name">The stream name... <see langword="null" /> = no name.</param>
            <param name="Url">The URL, for example, of the radio station's webpage... <see langword="null" /> = no URL.</param>
            <param name="Genre">The genre... <see langword="null" /> = no genre.</param>
            <param name="Description">Description... <see langword="null" /> = no description. This applies to Icecast only.</param>
            <param name="Headers">Other headers to send to the server... <see langword="null" /> = none. Each header should end with a carriage return and line feed ("\r\n").</param>
            <param name="Bitrate">The bitrate (in kbps) of the encoder output... 0 = undefined bitrate. In cases where the bitrate is a "quality" (rather than CBR) setting, the headers parameter can be used to communicate that instead, eg. "ice-bitrate: Quality 0\r\n".</param>
            <param name="Public">Public? If <see langword="true" />, the stream is added to the public directory of streams, at shoutcast.com or dir.xiph.org (or as defined in the server config).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function sets up a Shoutcast/Icecast source client, sending the encoder's output to a server, which listeners can then connect to and receive the data from. 
            The Shoutcast and Icecast server software is available from http://www.shoutcast.com/broadcast-tools and http://www.icecast.org/download.php, respectively.
            </para>
            <para>
            An encoder needs to be started (but with no data sent to it yet) before using this function to setup the sending of the encoder's output to a Shoutcast or Icecast server.
            If <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" /> is used, the encoder should be setup to write its output to STDOUT.
            Due to the length restrictions of WAVE headers/files, the encoder should also be started with the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag, and the sample format details sent via the command-line.
            </para>
            <para>
            Unless the <see cref="F:ManagedBass.Enc.EncodeFlags.UnlimitedCastDataRate"/> flag is set on the encoder, BASSenc automatically limits the rate that data is processed to real-time speed to avoid overflowing the server's buffer, which means that it is safe to simply try to process data as quickly as possible, eg. when the source is a decoding channel.
            Encoders set on recording channels are automatically exempt from the rate limiting, as they are inherently real-time.
            With BASS 2.4.6 or above, also exempt are encoders that are fed in a playback buffer update cycle (including <see cref="M:ManagedBass.Bass.Update(System.Int32)" /> and <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)" /> calls), eg. when the source is a playing channel;
            that is to avoid delaying the update thread, which could result in playback buffer underruns.
            </para>
            <para>
            Normally, BASSenc will produce the encoded data (with the help of an encoder) that is sent to a Shoutcast/Icecast server, but it is also possible to send already encoded data to a server (without first decoding and re-encoding it) via the PCM encoding option.
            The encoder can be set on any BASS channel, as rather than feeding on sample data from the channel, <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> would be used to feed in the already encoded data.
            BASSenc does not know what the data's bitrate is in that case, so it is up to the user to process the data at the correct rate (real-time speed).
            </para>
            <para><see cref="M:ManagedBass.Enc.BassEnc.ServerInit(System.Int32,System.String,System.Int32,System.Int32,ManagedBass.Enc.EncodeServer,ManagedBass.Enc.EncodeClientProcedure,System.IntPtr)" /> can be used to setup a server that listeners can connect to directly, without a Shoutcast/Icecast server intermediary.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">There is already a cast set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Server" /> doesn't include a port number.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">Couldn't connect to the server.</exception>
            <exception cref="F:ManagedBass.Errors.CastDenied"><paramref name="Password" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.CastSendMeta(System.Int32,ManagedBass.Enc.EncodeMetaDataType,System.Byte[])">
            <summary>
            Sends metadata to a Shoutcast 2 server.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Type">The type of metadata.</param>
            <param name="Buffer">The XML metadata as an UTF-8 encoded byte array.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There isn't a cast set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.CastSendMeta(System.Int32,ManagedBass.Enc.EncodeMetaDataType,System.String)">
            <summary>
            Sends metadata to a Shoutcast 2 server.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Type">The type of metadata.</param>
            <param name="Metadata">The XML metadata to send.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There isn't a cast set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.CastSetTitle(System.Int32,System.String,System.String)">
            <summary>
            Sets the title (ANSI) of a cast stream.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Title">The title to set.</param>
            <param name="Url">URL to go with the title... <see langword="null" /> = no URL. This applies to Shoutcast only (not Shoutcast 2).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The ISO-8859-1 (Latin-1) character set should be used with Shoutcast servers, and UTF-8 with Icecast and Shoutcast 2 servers.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There isn't a cast set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with the <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.CastSetTitle(System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Sets the title of a cast stream.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Title">encoded byte[] containing the title to set.</param>
            <param name="Url">encoded byte[] containing the URL to go with the title... <see langword="null" /> = no URL. This applies to Shoutcast only (not Shoutcast 2).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The ISO-8859-1 (Latin-1) character set should be used with Shoutcast servers, and UTF-8 with Icecast and Shoutcast 2 servers.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There isn't a cast set on the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with the <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeAddChunk(System.Int32,System.String,System.IntPtr,System.Int32)">
            <summary>
            Sends a RIFF chunk to an encoder.
            </summary>
            <param name="Handle">The encoder Handle... a HENCODE.</param>
            <param name="ID">The 4 character chunk id (e.g. 'bext').</param>
            <param name="Buffer">The buffer containing the chunk data (without the id).</param>
            <param name="Length">The number of bytes in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            BassEnc writes the minimum chunks required of a WAV file: "fmt" and "data", and "ds64" and "fact" when appropriate.
            This function can be used to add other chunks. 
            For example, a BWF "bext" chunk or "INFO" tags.
            <para>
            Chunks can only be added prior to sample data being sent to the encoder.
            The <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag can be used when starting the encoder to ensure that no sample data is sent before additional chunks have been set.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No RIFF headers/chunks are being sent to the encoder (due to the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag being in effect), or sample data encoding has started.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeAddChunk(System.Int32,System.String,System.Byte[],System.Int32)">
            <summary>
            Sends a RIFF chunk to an encoder.
            </summary>
            <param name="Handle">The encoder Handle... a HENCODE.</param>
            <param name="ID">The 4 character chunk id (e.g. 'bext').</param>
            <param name="Buffer">The buffer containing the chunk data (without the id).</param>
            <param name="Length">The number of bytes in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            BassEnc writes the minimum chunks required of a WAV file: "fmt" and "data", and "ds64" and "fact" when appropriate.
            This function can be used to add other chunks. 
            For example, a BWF "bext" chunk or "INFO" tags.
            <para>
            Chunks can only be added prior to sample data being sent to the encoder.
            The <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag can be used when starting the encoder to ensure that no sample data is sent before additional chunks have been set.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No RIFF headers/chunks are being sent to the encoder (due to the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag being in effect), or sample data encoding has started.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeGetChannel(System.Int32)">
            <summary>
            Retrieves the channel that an encoder is set on.
            </summary>
            <param name="Handle">The encoder to get the channel from.</param>
            <returns>If successful, the encoder's channel Handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)">
            <summary>
            Retrieves the amount of data queued, sent to or received from an encoder, or sent to a cast server.
            </summary>
            <param name="Handle">The encoder Handle.</param>
            <param name="Count">The count to retrieve (see <see cref="T:ManagedBass.Enc.EncodeCount"/>).</param>
            <returns>If successful, the requested count (in bytes) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The queue counts are based on the channel's sample format (floating-point if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled),
            while the <see cref="F:ManagedBass.Enc.EncodeCount.In"/> count is based on the sample format used by the encoder,
            which could be different if one of the Floating-point conversion flags is active or the encoder is using an ACM codec (which take 16-bit data).
            </para>
            <para>
            When the encoder output is being sent to a cast server, the <see cref="F:ManagedBass.Enc.EncodeCount.Cast"/> count will match the <see cref="F:ManagedBass.Enc.EncodeCount.Out"/> count,
            unless there have been problems (eg. network timeout) that have caused data to be dropped.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder does not have a queue.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Count" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeIsActive(System.Int32)">
            <summary>
            Checks if an encoder is running on a channel.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>The return value is one of <see cref="T:ManagedBass.PlaybackState"/> values.</returns>
            <remarks>
            <para>When checking if there's an encoder running on a channel, and there are multiple encoders on the channel, <see cref="F:ManagedBass.PlaybackState.Playing"/> will be returned if any of them are active.</para>
            <para>If an encoder stops running prematurely, <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeSetChannel(System.Int32,System.Int32)">
            <summary>
            Moves an encoder (or all encoders on a channel) to another channel.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Channel">The channel to move the encoder(s) to... a HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The new channel must have the same sample format (rate, channels, resolution) as the old channel, as that is what the encoder is expecting. 
            A channel's sample format is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> or <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The new channel's sample format is not the same as the old channel's.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)">
            <summary>
            Sets a callback function on an encoder (or all encoders on a channel) to receive notifications about its status.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Procedure">Callback function to receive the notifications... <see langword="null" /> = no callback.</param>
            <param name="User">User instance data to Password to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            When setting a notification callback on a channel, it only applies to the encoders that are currently set on the channel.
            Subsequent encoders will not automatically have the notification callback set on them, this function will have to be called again to set them up.
            </para>
            <para>
            An encoder can only have one notification callback set.
            Subsequent calls of this function can be used to change the callback function, or disable notifications (<paramref name="Procedure"/> = <see langword="null" />).
            </para>
            <para>
            The status of an encoder and its cast connection (if it has one) is checked when data is sent to the encoder or server, and by <see cref="M:ManagedBass.Enc.BassEnc.EncodeIsActive(System.Int32)" />.
            That means an encoder's death will not be detected automatically, and so no notification given, while no data is being encoded.
            </para>
            <para>If the encoder is already dead when setting up a notification callback, the callback will be triggered immediately.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeSetPaused(System.Int32,System.Boolean)">
            <summary>
            Pauses or resumes encoding on a channel.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Paused">Paused?</param>
            <returns>If no encoder has been started on the channel, <see langword="false" /> is returned, otherwise <see langword="true" /> is returned.</returns>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            When an encoder is paused, no sample data will be sent to the encoder "automatically".
            Data can still be sent to the encoder "manually" though, via the <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> function.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.s</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)">
            <summary>
            Starts encoding on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="CommandLine">The encoder command-line, including the executable filename and any options. Or the output filename if the <see cref="F:ManagedBass.Enc.EncodeFlags.PCM"/> flag is specified.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedure">Optional callback function to receive the encoded data... <see langword="null" /> = no callback. To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file).</param>
            <param name="User">User instance data to Password to the callback function.</param>
            <returns>The encoder process Handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
            <remarks>
            <para>
            The encoder must be told (via the command-line) to expect input from STDIN, rather than a file.
            The command-line should also tell the encoder what filename to write it's output to, unless you're using a callback function, in which case it should be told to write it's output to STDOUT.
            </para>
            <para>
            No user interaction with the encoder is possible, so anything that would cause the encoder to require the user to press any keys should be avoided.
            For example, if the encoder asks whether to overwrite files, the encoder should be instructed to always overwrite (via the command-line), or you should delete the existing file before starting the encoder.
            </para>
            <para>
            Standard RIFF files are limited to a little over 4GB in size.
            When writing a WAV file, BASSenc will automatically stop at that point, so that the file is valid.
            That does not apply when sending data to an encoder though, as the encoder may (possibly via a command-line option) ignore the size restriction, but if it does not, it could mean that the encoder stops after a few hours (depending on the sample format).
            If longer encodings are needed, the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag can be used to omit the WAVE header, and the encoder informed of the sample format via the command-line instead.
            The 4GB size limit can also be overcome with the <see cref="F:ManagedBass.Enc.EncodeFlags.RF64"/> flag, but most encoders are unlikely to support RF64.
            </para>
            <para>
            When writing an RF64 WAV file, a standard RIFF header will still be written initially, which will only be replaced by an RF64 header at the end if the file size has exceeded the standard limit.
            When an encoder is used, it is not possible to go back and change the header at the end, so the RF64 header is sent at the beginning in that case.
            </para>
            <para>
            Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel.
            That means when you play the channel (or call <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if you use the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option, then the sample data will be 32-bit floating-point, and you'll need to use one of the Floating-point flags if the encoder does not support floating-point sample data. 
            The <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> setting should not be changed while encoding is in progress.
            </para>
            <para>The encoder DSP has a priority setting of -1000, so if you want to set DSP/FX on the channel and have them present in the encoding, set their priority above that.</para>
            <para>
            Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> function.
            Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag or the <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetPaused(System.Int32,System.Boolean)" /> function.
            </para>
            <para>
            When queued encoding is enabled via the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> flag, the DSP system or <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> call will just buffer the data, and the data will then be fed to the encoder by another thread.
            The buffer will grow as needed to hold the queued data, up to a limit specified by the <see cref="P:ManagedBass.Enc.BassEnc.Queue"/> config option.
            If the limit is exceeded (or there is no free memory), data will be lost; <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to be notified of that occurrence.
            The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)" />.
            </para>
            <para>
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeIsActive(System.Int32)" /> can be used to check that the encoder is still running.
            When done encoding, use <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> to close the encoder.
            </para>
            <para>The returned process Handle can be used to do things like change the encoder's priority and get it's exit code.</para>
            <para>
            Multiple encoders can be set on a channel.
            For simplicity, the encoder functions will accept either an encoder Handle or a channel Handle.
            When using a channel Handle, the function is applied to all encoders that are set on that channel.
            </para>
            <para><b>Platform-specific</b></para>
            <para>External encoders are not supported on iOS or Windows CE, so only plain PCM file writing with the <see cref="F:ManagedBass.Enc.EncodeFlags.PCM"/> flag is possible on those platforms.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">Couldn't start the encoder. Check that the executable exists.</exception>
            <exception cref="F:ManagedBass.Errors.Create">The PCM file couldn't be created.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr,System.Int32)">
            <summary>
            Starts encoding on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="CommandLine">The encoder command-line, including the executable filename and any options. Or the output filename if the <see cref="F:ManagedBass.Enc.EncodeFlags.PCM"/> flag is specified.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedure">Optional callback function to receive the encoded data... <see langword="null" /> = no callback. To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file).</param>
            <param name="User">User instance data to Password to the callback function.</param>
            <param name="Limit">The maximum number of bytes that will be encoded (0 = no limit).</param>
            <returns>The encoder process Handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
            <remarks>
            <para>
            This function works exactly like <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />, but with a <paramref name="Limit" /> parameter added, which is the maximum number of bytes that will be encoded (0=no limit).
            Once the limit is hit, the encoder will die.
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to be notified of that occurrence.
            One thing to note is that the limit is applied after any conversion due to the floating-point flags.
            </para>
            <para>This can be useful in situations where the encoder needs to know in advance how much data it will be receiving. For example, when using a callback function with a file format that stores the length in the header, as the header cannot then be updated at the end of encoding. The length is communicated to the encoder via the WAVE header, so it requires that the BASS_ENCODE_NOHEAD flag is not used.</para>
            <para>
            The encoder must be told (via the command-line) to expect input from STDIN, rather than a file.
            The command-line should also tell the encoder what filename to write it's output to, unless you're using a callback function, in which case it should be told to write it's output to STDOUT.
            </para>
            <para>
            No user interaction with the encoder is possible, so anything that would cause the encoder to require the user to press any keys should be avoided.
            For example, if the encoder asks whether to overwrite files, the encoder should be instructed to always overwrite (via the command-line), or you should delete the existing file before starting the encoder.
            </para>
            <para>
            Standard RIFF files are limited to a little over 4GB in size.
            When writing a WAV file, BASSenc will automatically stop at that point, so that the file is valid.
            That does not apply when sending data to an encoder though, as the encoder may (possibly via a command-line option) ignore the size restriction, but if it does not, it could mean that the encoder stops after a few hours (depending on the sample format).
            If longer encodings are needed, the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag can be used to omit the WAVE header, and the encoder informed of the sample format via the command-line instead.
            The 4GB size limit can also be overcome with the <see cref="F:ManagedBass.Enc.EncodeFlags.RF64"/> flag, but most encoders are unlikely to support RF64.
            </para>
            <para>
            When writing an RF64 WAV file, a standard RIFF header will still be written initially, which will only be replaced by an RF64 header at the end if the file size has exceeded the standard limit.
            When an encoder is used, it is not possible to go back and change the header at the end, so the RF64 header is sent at the beginning in that case.
            </para>
            <para>
            Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel.
            That means when you play the channel (or call <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if you use the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option, then the sample data will be 32-bit floating-point, and you'll need to use one of the Floating-point flags if the encoder does not support floating-point sample data. 
            The <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> setting should not be changed while encoding is in progress.
            </para>
            <para>The encoder DSP has a priority setting of -1000, so if you want to set DSP/FX on the channel and have them present in the encoding, set their priority above that.</para>
            <para>
            Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> function.
            Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag or the <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetPaused(System.Int32,System.Boolean)" /> function.
            </para>
            <para>
            When queued encoding is enabled via the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> flag, the DSP system or <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> call will just buffer the data, and the data will then be fed to the encoder by another thread.
            The buffer will grow as needed to hold the queued data, up to a limit specified by the <see cref="P:ManagedBass.Enc.BassEnc.Queue"/> config option.
            If the limit is exceeded (or there is no free memory), data will be lost; <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to be notified of that occurrence.
            The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)" />.
            </para>
            <para>
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeIsActive(System.Int32)" /> can be used to check that the encoder is still running.
            When done encoding, use <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> to close the encoder.
            </para>
            <para>The returned process Handle can be used to do things like change the encoder's priority and get it's exit code.</para>
            <para>
            Multiple encoders can be set on a channel.
            For simplicity, the encoder functions will accept either an encoder Handle or a channel Handle.
            When using a channel Handle, the function is applied to all encoders that are set on that channel.
            </para>
            <para><b>Platform-specific</b></para>
            <para>External encoders are not supported on iOS or Windows CE, so only plain PCM file writing with the <see cref="F:ManagedBass.Enc.EncodeFlags.PCM"/> flag is possible on those platforms.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">Couldn't start the encoder. Check that the executable exists.</exception>
            <exception cref="F:ManagedBass.Errors.Create">The PCM file couldn't be created.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncoderProcedure,System.IntPtr)">
            <summary>
            Sets up a user-provided encoder on a channel.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Filename">Output filename... <see langword="null" /> = no output file.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="Procedure">Callback function to receive the sample data and return the encoded data.</param>
            <param name="User">User instance data to Password to the callback function.</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
            <remarks>
            <para>
            This function allows user-provided encoders to be used, which is most useful for platforms where external encoders are unavailable 
            for use with <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />.
            For example, the LAME library could be used with this function instead of the standalone LAME executable with <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />.
            </para>
            <para>
            Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel.
            That means when the channel is played (or <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> is called if it is a decoding channel), the sample data will be sent to the encoder at the same time.
            It also means that if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled, the sample data will be 32-bit floating-point, and one of the floating-point flags will be required if the encoder does not support floating-point sample data.
            The <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> setting should not be changed while encoding is in progress.
            </para>
            <para>
            By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed.
            That can be changed via the <see cref="P:ManagedBass.Enc.BassEnc.DSPPriority"/> config option.
            </para>
            <para>
            Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> function. 
            Both methods can be used together, but in general, the 'automatic' system ought to be paused when using the 'manual' system, via the <see cref="F:ManagedBass.Enc.EncodeFlags.Pause"/> flag or the <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetPaused(System.Int32,System.Boolean)" /> function.
            Data fed to the encoder manually does not go through the source channel's DSP chain, so any DSP/FX set on the channel will not be applied to the data.
            </para>
            <para>
            When queued encoding is enabled via the <see cref="F:ManagedBass.Enc.EncodeFlags.Queue"/> flag, the DSP system or <see cref="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> call will just buffer the data, and the data will then be fed to the encoder by another thread.
            The buffer will grow as needed to hold the queued data, up to a limit specified by the <see cref="P:ManagedBass.Enc.BassEnc.Queue"/> config option.
            If the limit is exceeded (or there is no free memory), data will be lost;
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to be notified of that occurrence. 
            The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)" />.
            </para>
            <para>When done encoding, use <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> or <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32,System.Boolean)" /> to close the encoder.</para>
            <para>
            Multiple encoders can be set on a channel.
            For convenience, most of the encoder functions will accept either an encoder handle or a channel handle. 
            When a channel handle is used, the function is applied to all encoders that are set on that channel.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Create">The file could not be created.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)">
            <summary>
            Stops encoding on a channel.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function will free an encoder immediately, without waiting for any data that may be remaining in the queue.
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32,System.Boolean)" /> can be used to have an encoder process the queue before it is freed.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32,System.Boolean)">
            <summary>
            Stops async encoding on a channel.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Queue">Process the queue first? If so, the encoder will not be freed until after any data remaining in the queue has been processed, and it will not accept any new data in the meantime.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            When an encoder is told to wait for its queue to be processed, this function will return immediately and the encoder will be freed in the background after the queued data has been processed.
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> can be used to request notification of when the encoder has been freed.
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> (or this function with queue = <see langword="false" />) can be used to cancel to queue processing and free the encoder immediately.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Buffer">A pointer to the buffer containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder.
            But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Buffer">byte[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder.
            But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Buffer">short[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder.
            But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Buffer">int[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder.
            But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc.EncodeWrite(System.Int32,System.Single[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="Handle">The encoder or channel Handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Buffer">float[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder.
            But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> option is enabled.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The encoder has died.</exception>
        </member>
        <member name="T:ManagedBass.Enc.EncodeClientProcedure">
            <summary>
            User defined callback function to receive notification of client connections and disconnections, and optionally refuse connections.
            </summary>
            <param name="Handle">The encoder/server that the client is connecting to or disconnecting from.</param>
            <param name="Connect">The client is connecting? true = connecting, false = disconnecting.</param>
            <param name="Client">The client's IP address and port number... "IP:port".</param>
            <param name="Headers">
            The request headers... <see langword="null" /> = the client is disconnecting or HTTP headers have been disabled via the <see cref="F:ManagedBass.Enc.EncodeServer.NoHTTP"/> flag.
            The headers are in the same form as would be given by <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />, which is a series of null-terminated strings, the final string ending with a double null.
            The request headers can optionally be replaced with response headers to send back to the client, each ending with a carriage return and line feed ("\r\n").
            The response headers should not exceed 1KB in length.
            </param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Enc.BassEnc.ServerInit(System.Int32,System.String,System.Int32,System.Int32,ManagedBass.Enc.EncodeServer,ManagedBass.Enc.EncodeClientProcedure,System.IntPtr)" /> was called.</param>
            <returns>If the client is connecting, <see langword="false" /> means the connection is denied, otherwise it is accepted. The return value is ignored if the client is disconnecting.</returns>
            <remarks>
            <para>
            This function can be used to keep track of how many clients are connected, and who is connected.
            The request headers can be used to authenticate clients, and response headers can be used to pass information back to the clients.
            By default, connecting clients will be sent an "HTTP/1.0 200 OK" status line if accepted, and an "HTTP/1.0 403 Forbidden" status line if denied.
            That can be overridden in the first response header.
            </para>
            <para>Disconnection notifications will be received for clients that have disconnected themselves or that have been kicked by <see cref="M:ManagedBass.Enc.BassEnc.ServerKick(System.Int32,System.String)" />, but there will no notification of any clients that are disconnected by the encoder being freed.</para>
            <para>Each server has its own thread that handles new connections and sends data to its clients. The notification callbacks also come from that thread, so the callback function should avoid introducing long delays as that could result in clients missing some data and delay other clients connecting.</para>
            <para>
            Use <see cref="M:ManagedBass.Extensions.ExtractMultiStringAnsi(System.IntPtr)"/> to get the <paramref name="Headers"/>.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Enc.EncodeNotifyProcedure">
            <summary>
            User defined callback function to receive notifications on an encoder's status.
            </summary>
            <param name="Handle">The encoder that the notification is from (returned by <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" />).</param>
            <param name="Status">The encoder's status.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            <para>
            When setting a notification callback on a channel, it only applies to the encoders that are currently set on the channel.
            Subsequent encoders will not automatically have the notification callback set on them, this function will have to be called again to set them up.
            </para>
            <para>
            An encoder can only have one notification callback set.
            Subsequent calls of this function can be used to change the callback function, or disable notifications.
            </para>
            <para>If the encoder is already dead when setting up a notification callback, the callback will be triggered immediately.</para>
            <para>It is safe to call <see cref="M:ManagedBass.Enc.BassEnc.EncodeStop(System.Int32)" /> to free an encoder from within a notification callback.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Enc.EncodeProcedure">
            <summary>
            User defined callback function to process (receive) encoded sample data.
            </summary>
            <param name="Handle">The encoder that the data is from (as returned by <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />).</param>
            <param name="Channel">The channel that the data is from.</param>
            <param name="Buffer">The pointer to the buffer containing the encoded data.</param>
            <param name="Length">The number of bytes in the buffer.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" /> was called.</param>
            <remarks>To have the encoded data received by this callback function, the encoder needs to be told to output to STDOUT (instead of a file).</remarks>
        </member>
        <member name="T:ManagedBass.Enc.EncoderProcedure">
            <summary>
            User defined callback function to encode sample data. 
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Channel">The channel that the encoder is set on.</param>
            <param name="Buffer">Buffer containing the sample data on input, and containing the encoded data on output.</param>
            <param name="Length">The number of bytes in the buffer... -1 = the encoder is being freed (no data in the buffer).</param>
            <param name="MaxOut">The maximum amount of encoded data that can be placed in the buffer.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncoderProcedure,System.IntPtr)" /> was called.</param>
            <returns>The number of bytes of encoded data placed in buffer... -1 = stop encoding.</returns>
            <remarks>
            If the encoder output exceeds the outmax value, then only the first outmax bytes should be delivered and the remainder retained.
            The function will be called again immediately to get the remainder.
            </remarks>
        </member>
        <member name="T:ManagedBass.Enc.EncodeCount">
            <summary>
            Used with <see cref="M:ManagedBass.Enc.BassEnc.EncodeGetCount(System.Int32,ManagedBass.Enc.EncodeCount)" /> to define the type of count you want to get.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeCount.In">
            <summary>
            Get the bytes sent to the encoder.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeCount.Out">
            <summary>
            Get the bytes received from the encoder.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeCount.Cast">
            <summary>
            Get the bytes sent to the cast server.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeCount.Queue">
            <summary>
            Data currently in the queue, waiting to be sent to the encoder (if async encoding is enabled).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeCount.QueueLimit">
            <summary>
            The queue's size limit (if async encoding is enabled).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeCount.QueueFail">
            <summary>
            Data not queued due to the queue being full or out of memory (if async encoding is enabled).
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.EncodeFlags">
            <summary>
            BassEnc Start flags for use with <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Unicode">
            <summary>
            Cmdline is Unicode (16-bit characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Default">
            <summary>
            Default option, incl. wave header, little-endian and no FP conversion.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.NoHeader">
            <summary>
            Do NOT send a WAV header to the encoder.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.ConvertFloatTo8BitInt">
            <summary>
            Convert floating-point sample data to 8-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.ConvertFloatTo16BitInt">
            <summary>
            Convert floating-point sample data to 16-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.ConvertFloatTo24Bit">
            <summary>
            Convert floating-point sample data to 24-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.ConvertFloatTo32Bit">
            <summary>
            Convert floating-point sample data to 32-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.ConvertFloatAuto">
            <summary>
            Convert floating-point sample data back to channel's format.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.BigEndian">
            <summary>
            Big-Endian sample data.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Pause">
            <summary>
            Start the encoder paused.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.PCM">
            <summary>
            Write PCM sample data (no encoder).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.RF64">
            <summary>
            Write RF64 WAV header (no encoder).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Mono">
            <summary>
            Convert to mono (if not already).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Queue">
            <summary>
            Queue data to feed encoder asynchronously.
            The queue Buffer will grow as needed to fit the data, but its size can be limited by the Queue config option (0 = no limit);
            The default is 10000ms.
            If the queue reaches the size limit and data is lost, the <see cref="F:ManagedBass.Enc.EncodeNotifyStatus.QueueFull"/> notification will be triggered.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.WaveFormatExtensible">
            <summary>
            Send the sample format information to the encoder in WAVEFORMATEXTENSIBLE form instead of WAVEFORMATEX form.
            This flag is ignored if the <see cref="F:ManagedBass.Enc.EncodeFlags.NoHeader"/> flag is used.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.UnlimitedCastDataRate">
            <summary>
            Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.
            With this option you might disable the rate limiting during casting (as it'll be limited by the playback rate anyway if the source channel is being played).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Limit">
            <summary>
            Limit data rate to real-time.
            Limit the data rate to real-time speed, by introducing a delay when the rate is too high.
            With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback Buffer update cycle (including <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> and <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> calls),
            to avoid possibly causing playback Buffer underruns.
            Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.AIFF">
            <summary>
            Send an AIFF header to the encoder instead of a WAVE header.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.Dither">
            <summary>
            Apply dither when converting floating-point sample data to integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeFlags.AutoFree">
            <summary>
            Free the encoder when the channel is freed.
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.EncodeMetaDataType">
            <summary>
            To be used with <see cref="M:ManagedBass.Enc.BassEnc.CastSendMeta(System.Int32,ManagedBass.Enc.EncodeMetaDataType,System.Byte[])" /> to define the type of metadata to send.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.XmlContent">
            <summary>
            SHOUTcast v2 Cacheable Metadata (Content Info Metadata).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.XmlUrl">
            <summary>
            SHOUTcast v2 Cacheable Metadata (Url Metadata).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.XmlAol">
            <summary>
            SHOUTcast v2 Cacheable Metadata (Aol Radio format).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.XmlShoutcast">
            <summary>
            SHOUTcast v2 Cacheable Metadata (SHOUTcast 2.0 format).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinStationLogoJpg">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/jpeg).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinStationLogoPng">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/png).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinStationLogoBmp">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/bmp).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinStationLogoGif">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/gif).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinAlbumArtJpg">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/jpeg).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinAlbumArtPng">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/png).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinAlbumArtBmp">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/bmp).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.BinAlbumArtGif">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/gif).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeMetaDataType.XmlTimeRemaining">
            <summary>
            SHOUTcast v2 Pass-through Metadata (Time Remaining).
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.EncodeNotifyStatus">
            <summary>
            To be used with <see cref="M:ManagedBass.Enc.BassEnc.EncodeSetNotify(System.Int32,ManagedBass.Enc.EncodeNotifyProcedure,System.IntPtr)" /> to receive notifications on an encoder's status.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeNotifyStatus.EncoderDied">
            <summary>
            Encoder died
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeNotifyStatus.CastServerConnectionDied">
            <summary>
            Cast server connection died
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeNotifyStatus.CastTimeout">
            <summary>
            Cast timeout
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeNotifyStatus.QueueFull">
            <summary>
            Queue is out of space
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeNotifyStatus.Free">
            <summary>
            Encoder has been freed
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.EncodeServer">
            <summary>
            To be used with <see cref="M:ManagedBass.Enc.BassEnc.ServerInit(System.Int32,System.String,System.Int32,System.Int32,ManagedBass.Enc.EncodeServer,ManagedBass.Enc.EncodeClientProcedure,System.IntPtr)" /> to define optional server flags.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeServer.Default">
            <summary>
            Default (no options).
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeServer.NoHTTP">
            <summary>
            No HTTP headers.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeServer.Meta">
            <summary>
            Shoutcast metadata
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.EncodeStats">
            <summary>
            Stats type to be used with <see cref="M:ManagedBass.Enc.BassEnc.CastGetStats(System.Int32,ManagedBass.Enc.EncodeStats,System.String)" /> to define the type of stats you want to get.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeStats.Shoutcast">
            <summary>
            Shoutcast stats.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeStats.Icecast">
            <summary>
            Icecast mount-point stats.
            </summary>
        </member>
        <member name="F:ManagedBass.Enc.EncodeStats.IcecastServer">
            <summary>
            Icecast server stats.
            </summary>
        </member>
        <member name="T:ManagedBass.Enc.BassEnc_Ogg">
            <summary>
            BassEnc_Ogg is an extension to the BassEnc add-on that allows BASS channels to be Ogg Vorbis encoded, with support for OGGENC options.
            </summary>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Ogg.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Ogg.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc_Ogg.Version">
            <summary>
            Gets the Version of BassEnc_Ogg that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Ogg.Start(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)">
            <summary>
            Start Ogg Encoding to <see cref="T:ManagedBass.Enc.EncodeProcedure"/>.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Options">
            Encoder options... null = use defaults.
            The following OGGENC style options are supported: -b / --bitrate, -m / --min-bitrate, -M / --max-bitrate, -q / --quality, -s / --serial, -t / --title, -a / --artist, -G / --genre, -d / --date, -l / --album, -N / --tracknum, -c / --comment.
            Anything else that is included will be ignored. 
            </param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="Procedure">Optional callback function to receive the encoded data... null = no callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code</returns>
            <remarks>
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncoderProcedure,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function. 
            
            <b>Platform-specific</b>
            Ogg Vorbis encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The channel's sample format is not supported by the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">This function is not available on platforms/architectures without an FPU.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem! </exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Ogg.Start(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,System.String)">
            <summary>
            Start Ogg Encoding to File.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Options">
            Encoder options... null = use defaults.
            The following OGGENC style options are supported: -b / --bitrate, -m / --min-bitrate, -M / --max-bitrate, -q / --quality, -s / --serial, -t / --title, -a / --artist, -G / --genre, -d / --date, -l / --album, -N / --tracknum, -c / --comment.
            Anything else that is included will be ignored. 
            </param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="FileName">Output filename... null = no output file.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code</returns>
            <remarks>
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncoderProcedure,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function. 
            
            <b>Platform-specific</b>
            Ogg Vorbis encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The channel's sample format is not supported by the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Create">The file could not be created.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">This function is not available on platforms/architectures without an FPU.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem! </exception>
        </member>
        <member name="T:ManagedBass.Enc.BassEnc_Opus">
            <summary>
            BassEnc_Opus is an extension to the BassEnc add-on that allows BASS channels to be Opus encoded, with support for OPUSENC options.
            </summary>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Opus.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Opus.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Enc.BassEnc_Opus.Version">
            <summary>
            Gets the Version of BassEnc_Opus that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Opus.Start(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncodeProcedure,System.IntPtr)">
            <summary>
            Start Opus Encoding to <see cref="T:ManagedBass.Enc.EncodeProcedure"/>.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Options">
            Encoder options... null = use defaults.
            The following OPUSENC style options are supported: --bitrate, --vbr, --cvbr, --hard-cbr, --comp / --complexity, --framesize, --expect-loss, --max-delay, --serial, --comment, --artist, --title, --album, --date, --genre, --padding.
            Anything else that is included will be ignored.
            </param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="Procedure">Optional callback function to receive the encoded data... null = no callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code</returns>
            <remarks>
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncoderProcedure,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function. 
            
            <b>Platform-specific</b>
            On Windows and Linux, an SSE supporting CPU is required for sample rates other than 48000/24000/16000/12000/8000 Hz.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The channel's sample format is not supported by the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem! </exception>
        </member>
        <member name="M:ManagedBass.Enc.BassEnc_Opus.Start(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,System.String)">
            <summary>
            Start Opus Encoding to File.
            </summary>
            <param name="Handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Options">
            Encoder options... null = use defaults.
            The following OPUSENC style options are supported: --bitrate, --vbr, --cvbr, --hard-cbr, --comp / --complexity, --framesize, --expect-loss, --max-delay, --serial, --comment, --artist, --title, --album, --date, --genre, --padding.
            Anything else that is included will be ignored.
            </param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Enc.EncodeFlags"/>.</param>
            <param name="FileName">Output filename... null = no output file.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code</returns>
            <remarks>
            <see cref="M:ManagedBass.Enc.BassEnc.EncodeStart(System.Int32,System.String,ManagedBass.Enc.EncodeFlags,ManagedBass.Enc.EncoderProcedure,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function. 
            
            <b>Platform-specific</b>
            On Windows and Linux, an SSE supporting CPU is required for sample rates other than 48000/24000/16000/12000/8000 Hz.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The channel's sample format is not supported by the encoder.</exception>
            <exception cref="F:ManagedBass.Errors.Create">The file could not be created.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem! </exception>
        </member>
        <member name="T:ManagedBass.DSInterface">
            <summary>
            Direct Sound interface flags for use with <see cref="M:ManagedBass.Bass.GetDSoundObject(ManagedBass.DSInterface)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DSInterface.IDirectSound">
            <summary>
            Retrieve the IDirectSound interface.
            </summary>
        </member>
        <member name="F:ManagedBass.DSInterface.IDirectSound3DListener">
            <summary>
            Retrieve the IDirectSound3DListener interface.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXCompressorParameters">
            <summary>
            Parameters for DX8 Compressor Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXCompressorParameters.fGain">
            <summary>
            Output gain of signal in dB after compression, in the range from -60 to 60. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXCompressorParameters.fAttack">
            <summary>
            Time in ms before compression reaches its full value, in the range from 0.01 to 500. The default value is 10 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXCompressorParameters.fRelease">
            <summary>
            Time (speed) in ms at which compression is stopped after input drops below <see cref="F:ManagedBass.DirectX8.DXCompressorParameters.fThreshold"/>, in the range from 50 to 3000. The default value is 200 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXCompressorParameters.fThreshold">
            <summary>
            Point at which compression begins, in dB, in the range from -60 to 0. The default value is -20 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXCompressorParameters.fRatio">
            <summary>
            Compression ratio, in the range from 1 to 100. The default value is 3, which means 3:1 compression.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXCompressorParameters.fPredelay">
            <summary>
            Time in ms after <see cref="F:ManagedBass.DirectX8.DXCompressorParameters.fThreshold"/> is reached before attack phase is started, in milliseconds, in the range from 0 to 4. The default value is 4 ms.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXCompressorParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXGargleParameters">
            <summary>
            Parameters for DX8 Gargle Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXGargleParameters.dwRateHz">
            <summary>
            Rate of modulation, in Hertz. Must be in the range from 1 through 1000. Default 500 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXGargleParameters.dwWaveShape">
            <summary>
            Shape of the modulation wave. Default = <see cref="F:ManagedBass.DXWaveform.Sine"/>.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXGargleParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters">
            <summary>
            Parameters for DX8 ID3L2 Reverb Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.lRoom">
            <summary>
            Attenuation of the room effect, in millibels (mB), in the range from -10000 to 0. The default value is -1000 mB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.lRoomHF">
            <summary>
            Attenuation of the room high-frequency effect, in mB, in the range from -10000 to 0. The default value is 0 mB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flRoomRolloffFactor">
            <summary>
            Rolloff factor for the reflected signals, in the range from 0 to 10. The default value is 0.0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flDecayTime">
            <summary>
            Decay time, in seconds, in the range from 0.1 to 20. The default value is 1.49 second.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flDecayHFRatio">
            <summary>
            Ratio of the decay time at high frequencies to the decay time at low frequencies, in the range from 0.1 to 2. The default value is 0.83.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.lReflections">
            <summary>
            Attenuation of early reflections relative to lRoom, in mB, in the range from -10000 to 1000. The default value is -2602 mB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flReflectionsDelay">
            <summary>
            Delay time of the first reflection relative to the direct path, in seconds, in the range from 0 to 0.3. The default value is 0.007 seconds.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.lReverb">
            <summary>
            Attenuation of late reverberation relative to lRoom, in mB, in the range from -10000 to 2000. The default value is 200 mB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flReverbDelay">
            <summary>
            Time limit between the early reflections and the late reverberation relative to the time of the first reflection, in seconds, in the range from 0 to 0.1. The default value is 0.011 seconds.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flDiffusion">
            <summary>
            Echo density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flDensity">
            <summary>
            Modal density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.flHFReference">
            <summary>
            Reference high frequency, in hertz, in the range from 20 to 20000. The default value is 5000.0 Hz.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DX_ID3DL2ReverbParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXChorusParameters">
            <summary>
            Parameters for DX8 Chorus Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.lWaveform">
            <summary>
            Waveform of the LFO. Default = <see cref="F:ManagedBass.DXWaveform.Sine"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.lPhase">
            <summary>
            Phase differential between left and right LFOs. Default is <see cref="F:ManagedBass.DXPhase.Zero"/>.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXChorusParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXDistortionParameters">
            <summary>
            Parameters for DX8 Distortion Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fGain">
            <summary>
            Amount of signal change after distortion, in the range from -60 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fEdge">
            <summary>
            Percentage of distortion intensity, in the range in the range from 0 through 100. The default value is 50 percent.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fPostEQCenterFrequency">
            <summary>
            Center frequency of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fPostEQBandwidth">
            <summary>
            Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fPreLowpassCutoff">
            <summary>
            Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXDistortionParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXEchoParameters">
            <summary>
            Parameters for DX8 Echo Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fFeedback">
            <summary>
            Percentage of output fed back into input, in the range from 0 through 100. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fLeftDelay">
            <summary>
            Delay for left channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fRightDelay">
            <summary>
            Delay for right channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.lPanDelay">
            <summary>
            Value that specifies whether to swap left and right delays with each successive echo. The default value is <see langword="false" />, meaning no swap.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXEchoParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXFlangerParameters">
            <summary>
            Parameters for DX8 Flanger Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.lWaveform">
            <summary>
            Waveform of the LFO. Default = <see cref="F:ManagedBass.DXWaveform.Sine"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.lPhase">
            <summary>
            Phase differential between left and right LFOs. Default = <see cref="F:ManagedBass.DXPhase.Zero"/>.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXFlangerParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXParamEQParameters">
            <summary>
            Parameters for DX8 ParamEQ Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXParamEQParameters.fCenter">
            <summary>
            Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the channel. Default 100 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXParamEQParameters.fBandwidth">
            <summary>
            Bandwidth, in semitones, in the range from 1 to 36. Default 18 semitones.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXParamEQParameters.fGain">
            <summary>
            Gain, in the range from -15 to 15. Default 0 dB.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXParamEQParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXReverbParameters">
            <summary>
            Parameters for DX8 Reverb Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fInGain">
            <summary>
            Input gain of signal, in decibels (dB), in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fReverbMix">
            <summary>
            Reverb mix, in dB, in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fReverbTime">
            <summary>
            Reverb time, in milliseconds, in the range from 0.001 through 3000. The default value is 1000.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fHighFreqRTRatio">
            <summary>
            In the range from 0.001 through 0.999. The default value is 0.001.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXReverbParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.EAXEnvironment">
            <summary>
            EAX environment constants to be used with <see cref="M:ManagedBass.Bass.SetEAXParameters(ManagedBass.EAXEnvironment,System.Single,System.Single,System.Single)" />
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.LeaveCurrent">
            <summary>
            -1 = leave current EAX environment as is
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Generic">
            <summary>
            Generic
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.PaddedCell">
            <summary>
            Padded Cell
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Room">
            <summary>
            Room
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Bathroom">
            <summary>
            Bathroom
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Livingroom">
            <summary>
            Livingroom
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Stoneroom">
            <summary>
            Stoneroom
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Auditorium">
            <summary>
            Auditorium
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.ConcertHall">
            <summary>
            Concert Hall
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Cave">
            <summary>
            Cave
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Arena">
            <summary>
            Arena
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Hangar">
            <summary>
            Hangar
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.CarpetedHallway">
            <summary>
            Carpeted Hallway
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Hallway">
            <summary>
            Hallway
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.StoneCorridor">
            <summary>
            Stone Corridor
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Alley">
            <summary>
            Alley
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Forest">
            <summary>
            Forest
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.City">
            <summary>
            City
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Mountains">
            <summary>
            Mountains
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Quarry">
            <summary>
            Quarry
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Plain">
            <summary>
            Plain
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.ParkingLot">
            <summary>
            Parkinglot
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.SewerPipe">
            <summary>
            Sewer Pipe
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Underwater">
            <summary>
            Underwater
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Drugged">
            <summary>
            Drugged
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Dizzy">
            <summary>
            Dizzy
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Psychotic">
            <summary>
            Psychotic
            </summary>
        </member>
        <member name="F:ManagedBass.EAXEnvironment.Count">
            <summary>
            Total number of environments
            </summary>
        </member>
        <member name="T:ManagedBass.BassException">
            <summary>
            An Exception wrapping <see cref="P:ManagedBass.Bass.LastError"/> or BassAsio.LastError.
            </summary>
        </member>
        <member name="M:ManagedBass.BassException.#ctor">
            <summary>
            Creates a new instance of <see cref="T:ManagedBass.BassException"/> with <see cref="P:ManagedBass.Bass.LastError"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.BassException.#ctor(ManagedBass.Errors)">
            <summary>
            Creates a new instance of <see cref="T:ManagedBass.BassException"/> with provided Error code.
            </summary>
        </member>
        <member name="P:ManagedBass.BassException.ErrorCode">
            <summary>
            Gets the Bass Error Code.
            </summary>
        </member>
        <member name="T:ManagedBass.DownloadProcedure">
            <summary>
            Internet stream download callback function (to be used with <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />).
            </summary>
            <param name="Buffer">The pointer to the Buffer containing the downloaded data... <see cref="F:System.IntPtr.Zero" /> = finished downloading.</param>
            <param name="Length">The number of bytes in the Buffer... 0 = HTTP or ICY tags.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            <para>
            The callback will be called before the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> call returns (if it's successful), with the initial downloaded data.
            So any initialization (eg. creating the file if writing to disk) needs to be done either before the call, or in the callback function.
            </para>
            <para>
            When the <see cref="F:ManagedBass.BassFlags.StreamStatus"/> flag is specified in the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> call,
            HTTP and ICY tags may be passed to the callback during connection, before any stream data is received.
            The tags are given exactly as would be returned by <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            You can destinguish between HTTP and ICY tags by checking what the first string starts with ("HTTP" or "ICY").
            </para>
            <para>
            A download callback function could be used in conjunction with a <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/> sync set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />,
            to save individual tracks to disk from a Shoutcast stream.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.DSPProcedure">
            <summary>
            User defined DSP callback function (to be used with <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" />).
            </summary>
            <param name="Handle">The DSP Handle (as returned by <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" />).</param>
            <param name="Channel">Channel that the DSP is being applied to.</param>
            <param name="Buffer">
            The pointer to the Buffer to apply the DSP to.
            The sample data is in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range).
            </param>
            <param name="Length">The number of bytes to process.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" /> was called.</param>
            <remarks>
            <para>A DSP function should obviously be as quick as possible... playing streams, MOD musics and other DSP functions can not be processed until it has finished.</para>
            <para>
            Some functions can cause problems if called from within a DSP (or stream) function.
            Do not call these functions from within a DSP callback:
            </para>
            <para>
            <see cref="M:ManagedBass.Bass.Stop" />, <see cref="M:ManagedBass.Bass.Free" />, <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" />,
            <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> (or any other stream creation functions).
            </para>
            <para>Also, do not call <see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)" /> with the same DSP Handle as received by the callback,
            or <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" />, <see cref="M:ManagedBass.Bass.MusicFree(System.Int32)" />, <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" /> with the same channel Handle as received by the callback.</para>
            <para>If the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> config option is set, then DSP callback functions will always be passed 32-bit floating-point sample data, regardless of what the channels' actual sample format is.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.FileCloseProcedure">
            <summary>
            User file stream close callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <remarks>With a buffered file stream, this function is called as soon as reading reaches the end of the file.
            If the stream is freed before then, this function could be called while its <see cref="T:ManagedBass.FileReadProcedure" /> function is in progress.
            If that happens, the <see cref="T:ManagedBass.FileReadProcedure" /> function call should be immediately cancelled.
            </remarks>
        </member>
        <member name="T:ManagedBass.FileLengthProcedure">
            <summary>
            User file stream Length callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <returns>The Length of the file in bytes.
            Returning 0 for a buffered file stream, makes BASS stream the file in blocks, and is equivalent to using the <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/> flag
            in the <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> call.</returns>
            <remarks>This function is called first thing, and is only used the once with buffered streams.
            With unbuffered streams, it may be used again when testing for EOF (end of file),
            allowing the file to grow in size.
            </remarks>
        </member>
        <member name="T:ManagedBass.FileReadProcedure">
            <summary>
            User file stream read callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="Buffer">Pointer to the Buffer to put the data in.</param>
            <param name="Length">Maximum number of bytes to read.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <returns>The number of bytes read... -1 = end of file, 0 = end of file (buffered file stream only).</returns>
            <remarks>During creation of the stream, this function should try to return the amount of data requested.
            After that, it can just return whatever is available up to the requested amount.
            <para>For an unbuffered file stream during playback, this function should be as quick as possible -
            any delays will not only affect the decoding of the current stream, but also all other streams and MOD musics that are playing.
            It is better to return less data (even none) rather than wait for more data.
            A buffered file stream isn't affected by delays like this, as this function runs in its own thread then.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.FileSeekProcedure">
            <summary>
            User file stream seek callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="Offset">Position in bytes to seek to.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <returns><see langword="true" /> if successful, else <see langword="false" />.</returns>
        </member>
        <member name="T:ManagedBass.RecordProcedure">
            <summary>
            User defined callback function to process recorded sample data.
            </summary>
            <param name="Handle">The recording Handle that the data is from.</param>
            <param name="Buffer">
            The pointer to the Buffer containing the recorded sample data.
            The sample data is in standard Windows PCM format, that is 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1.
            </param>
            <param name="Length">The number of bytes in the Buffer.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)" /> was called.</param>
            <returns>Return <see langword="true" /> to stop recording, and anything else to continue recording.</returns>
            <remarks>
            <see cref="M:ManagedBass.Bass.RecordFree" /> should not be used to free the recording device within a recording callback function.
            Nor should <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> be used to stop the recording; return <see langword="false" /> to do that instead.
            </remarks>
        </member>
        <member name="T:ManagedBass.StreamProcedure">
            <summary>
            User stream writing callback delegate (to be used with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />).
            </summary>
            <param name="Handle">The stream that needs writing.</param>
            <param name="Buffer">The pointer to the Buffer to write the sample data in. The sample data must be written in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1.</param>
            <param name="Length">The number of bytes to write.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> was called.</param>
            <returns>The number of bytes written by the function, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> (<see cref="T:ManagedBass.StreamProcedure" />) flag to signify that the end of the stream is reached.</returns>
            <remarks>
            <para>A stream writing function should obviously be as quick as possible, because other streams (and MOD musics) can't be updated until it's finished.</para>
            <para>It is better to return less data quickly, rather than spending a long time delivering the amount BASS requested.</para>
            <para>Although a STREAMPROC may return less data than BASS requests, be careful not to do so by too much, too often. If the Buffer level gets too low, BASS will automatically stall playback of the stream, until the whole Buffer has refilled.</para>
            <para><see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> <see cref="T:ManagedBass.DataFlags"/> can be used to check the Buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.</para>
            <para>A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.</para>
            <para>If you do return less than the requested amount of data, the number of bytes should still equate to a whole number of samples.</para>
            <para>Some functions can cause problems if called from within a stream (or DSP) function. Do not call these functions from within a stream callback:</para>
            <para><see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" />, <see cref="M:ManagedBass.Bass.Free" />, <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" />, <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> or any other stream creation functions.</para>
            <para>Also, do not call <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" /> or <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> with the same Handle as received by the callback.</para>
            <para>When streaming multi-channel sample data, the channel order of each sample is as follows:</para>
            <para>3 channels: left-front, right-front, center.</para>
            <para>4 channels: left-front, right-front, left-rear/side, right-rear/side.</para>
            <para>6 channels(5.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side.</para>
            <para>8 channels(7.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.SyncProcedure">
            <summary>
            User defined synchronizer callback function (see <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> for details).
            </summary>
            <param name="Handle">The sync Handle that has occured (as returned by <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />).</param>
            <param name="Channel">The channel that the sync occured on.</param>
            <param name="Data">Additional data associated with the sync's occurance.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            <para>
            BASS creates a single thread dedicated to executing sync callback functions, so a callback function should be quick as other syncs cannot be processed until it has finished.
            Attribute slides (<see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)" />) are also performed by the sync thread, so are also affected if a sync callback takes a long time.</para>
            <para>"Mixtime" syncs <see cref="F:ManagedBass.SyncFlags.Mixtime"/> are not executed in the sync thread, but immediately in whichever thread triggers them.
            In most cases that will be an update thread, and so the same restrictions that apply to stream callbacks (<see cref="T:ManagedBass.StreamProcedure" />) also apply here.</para>
            <para>
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be used in a mixtime sync to implement custom looping,
            eg. set a <see cref="F:ManagedBass.SyncFlags.Position"/> sync at the loop end position and seek to the loop start position in the callback.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Algorithm3D">
            <summary>
            Software 3D mixing algorithm modes to be used with <see cref="P:ManagedBass.Bass.Algorithm3D"/>.
            <remarks>
            On Windows, DirectX 7 or above is required for this option to have effect.
            On other platforms, only the <see cref="F:ManagedBass.Algorithm3D.Default"/> and <see cref="F:ManagedBass.Algorithm3D.Off"/> options are available.
            </remarks>
            </summary>
        </member>
        <member name="F:ManagedBass.Algorithm3D.Default">
            <summary>
            Default algorithm (currently translates to <see cref="F:ManagedBass.Algorithm3D.Off"/>)
            </summary>
        </member>
        <member name="F:ManagedBass.Algorithm3D.Off">
            <summary>
            Uses normal left and right panning.
            The vertical axis is ignored except for scaling of volume due to distance.
            <para>
            Doppler shift and volume scaling are still applied, but the 3D filtering is not performed.
            This is the most CPU efficient software implementation, but provides no virtual 3D audio effect.
            Head Related Transfer Function processing will not be done.
            Since only normal stereo panning is used, a channel using this algorithm may be accelerated by a 2D hardware voice if no free 3D hardware voices are available.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.Algorithm3D.Full">
            <summary>
            This algorithm gives the highest quality 3D audio effect, but uses more CPU.
            <para>
            Requires Windows 98 2nd Edition or Windows 2000 that uses WDM drivers,
            if this mode is not available then <see cref="F:ManagedBass.Algorithm3D.Off"/> will be used instead.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.Algorithm3D.Light">
            <summary>
            This algorithm gives a good 3D audio effect, and uses less CPU than the FULL mode.
            <para>
            Requires Windows 98 2nd Edition or Windows 2000 that uses WDM drivers,
            if this mode is not available then <see cref="F:ManagedBass.Algorithm3D.Off"/> will be used instead.
            </para>
            </summary>
        </member>
        <member name="T:ManagedBass.BassFlags">
            <summary>
            Stream/Sample/Music/Recording/AddOn create flags to be used with Stream Creation functions.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Default">
            <summary>
            0 = default create stream: 16 Bit, stereo, no Float, hardware mixing, no Loop, no 3D, no speaker assignments...
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Byte">
            <summary>
            Use 8-bit resolution. If neither this or the <see cref="F:ManagedBass.BassFlags.Float"/> flags are specified, then the stream is 16-bit.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Mono">
            <summary>
            Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo).
            This flag is automatically applied if <see cref="F:ManagedBass.DeviceInitFlags.Mono"/> was specified when calling <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Loop">
            <summary>
            Loop the file. This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Bass3D">
            <summary>
            Use 3D functionality.
            This is ignored if <see cref="F:ManagedBass.DeviceInitFlags.Device3D"/> wasn't specified when calling <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.
            3D streams must be mono (chans=1).
            The Speaker flags can not be used together with this flag.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SoftwareMixing">
            <summary>
            Force the stream to not use hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FX">
            <summary>
            Enable the old implementation of DirectX 8 effects.
            Use <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/> to add effects to the stream.
            Requires DirectX 8 or above.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Float">
            <summary>
            Use 32-bit floating-point sample data (see Floating-Point Channels for details).
            WDM drivers or the <see cref="F:ManagedBass.BassFlags.Decode"/> flag are required to use this flag.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Prescan">
            <summary>
            Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream or MOD music.
            This also increases the time taken to create the stream,
            due to the entire file being pre-scanned for the seek points.
            Note: This flag is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AutoFree">
            <summary>
            Automatically free the music or stream's resources when it has reached the end,
            or when <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)"/> or <see cref="M:ManagedBass.Bass.Stop"/> is called.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RestrictDownloadRate">
            <summary>
            Restrict the download rate of the file to the rate required to sustain playback.
            If this flag is not used, then the file will be downloaded as quickly as possible.
            This flag has no effect on "unbuffered" streams (Buffer=false).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.StreamDownloadBlocks">
            <summary>
            Download and play the file in smaller chunks.
            Uses a lot less memory than otherwise,
            but it's not possible to seek or loop the stream - once it's ended,
            the file must be opened again to play it again.
            This flag will automatically be applied when the file Length is unknown.
            This flag also has the effect of resticting the download rate.
            This flag has no effect on "unbuffered" streams (Buffer=false).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Decode">
            <summary>
            Decode the sample data, without outputting it.
            Use <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data.
            Bass.SoftwareMixing/<see cref="F:ManagedBass.BassFlags.Bass3D"/>/BassFlags.FX/<see cref="F:ManagedBass.BassFlags.AutoFree"/> are all ignored when using this flag, as are the Speaker flags.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.StreamStatus">
            <summary>
            Pass status info (HTTP/ICY tags) from the server to the <see cref="T:ManagedBass.DownloadProcedure"/> callback during connection.
            This can be useful to determine the reason for a failure.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AsyncFile">
            <summary>
            Use an async look-ahead cache.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Unicode">
            <summary>
            File is a Unicode (16-bit characters) filename
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxBpmBackground">
            <summary>
            BassFx add-on: If in use, then you can do other stuff while detection's in process.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FXBpmMult2">
            <summary>
            BassFx add-on: If in use, then will auto multiply bpm by 2 (if BPM &lt; MinBPM*2)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxTempoAlgorithmLinear">
            <summary>
            BassFx add-on (<see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/>): Uses a linear interpolation mode (simple).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxTempoAlgorithmCubic">
            <summary>
            BassFx add-on (<see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/>): Uses a cubic interpolation mode (recommended, default).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxTempoAlgorithmShannon">
            <summary>
            BassFx add-on (<see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/>):
            Uses a 8-tap band-limited Shannon interpolation (complex, but not much better than cubic).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxFreeSource">
            <summary>
            BassFx add-on: Free the source Handle as well?
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoHeader">
            <summary>
            BASSMIDI add-on: Don't send a WAVE header to the encoder.
            If this flag is used then the sample format (mono 16-bit)
            must be passed to the encoder some other way, eg. via the command-line.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Midi16Bit">
            <summary>
            BASSMIDI add-on: Reduce 24-bit sample data to 16-bit before encoding.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoSystemReset">
            <summary>
            BASSMIDI add-on: Ignore system reset events (<see cref="F:ManagedBass.Midi.MidiEventType.System"/>) when the system mode is unchanged.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiDecayEnd">
            <summary>
            BASSMIDI add-on: Let the sound decay naturally (including reverb) instead of stopping it abruptly at the end of the file.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/> methods.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoFx">
            <summary>
            BASSMIDI add-on: Disable the MIDI reverb/chorus processing.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiDecaySeek">
            <summary>
            BASSMIDI add-on: Let the old sound decay naturally (including reverb) when changing the position, including looping.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>, and can also be used in <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/>
            calls to have it apply to particular position changes.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoCrop">
            <summary>
            BASSMIDI add-on: Do not remove empty space (containing no events) from the end of the file.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoteOff1">
            <summary>
            BASSMIDI add-on: Only release the oldest instance upon a note off event (<see cref="F:ManagedBass.Midi.MidiEventType.Note"/> with velocity=0)
            when there are overlapping instances of the note.
            Otherwise all instances are released.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiFontMemoryMap">
            <summary>
            BASSMIDI add-on: Map the file into memory.
            This flag is ignored if the soundfont is packed as the sample data cannot be played directly from a mapping;
            it needs to be decoded.
            This flag is also ignored if the file is too large to be mapped into memory.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiFontXGDRUMS">
            <summary>
            Use bank 127 in the soundfont for XG drum kits.
            When an XG drum kit is needed, bank 127 in soundfonts that have this flag set will be checked first,
            before falling back to bank 128 (the standard SF2 drum kit bank) if it is not available there.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SincInterpolation">
            <summary>
            Music and BASSMIDI add-on: Use sinc interpolated sample mixing.
            This increases the sound quality, but also requires more CPU.
            Otherwise linear interpolation is used.
            Music: If neither this or the <see cref="F:ManagedBass.BassFlags.MusicNonInterpolated"/> flag is specified, linear interpolation is used.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicRamp">
            <summary>
            Music: Use "normal" ramping (as used in FastTracker 2).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicSensitiveRamping">
            <summary>
            Music: Use "sensitive" ramping.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicSurround">
            <summary>
            Music: Apply XMPlay's surround sound to the music (ignored in mono).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicSurround2">
            <summary>
            Music: Apply XMPlay's surround sound mode 2 to the music (ignored in mono).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicFT2Mod">
            <summary>
            Music: Play .MOD file as FastTracker 2 would.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicFT2PAN">
            <summary>
            Apply FastTracker 2 panning to XM files.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicPT1Mod">
            <summary>
            Music: Play .MOD file as ProTracker 1 would.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicPositionReset">
            <summary>
            Music: Stop all notes when seeking (using <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/>).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicNonInterpolated">
            <summary>
            Music: Use non-interpolated mixing.
            This generally reduces the sound quality, but can be good for chip-tunes.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicStopBack">
            <summary>
            Music: Stop the music when a backward jump effect is played.
            This stops musics that never reach the end from going into endless loops.
            Some MOD musics are designed to jump all over the place,
            so this flag would cause those to be stopped prematurely.
            If this flag is used together with the <see cref="F:ManagedBass.BassFlags.Loop"/> flag,
            then the music would not be stopped but any <see cref="F:ManagedBass.SyncFlags.End"/> sync would be triggered.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicNoSample">
            <summary>
            Music: Don't load the samples.
            This reduces the time taken to load the music, notably with MO3 files,
            which is useful if you just want to get the name and Length of the music without playing it.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicPositionResetEx">
            <summary>
            Music: Stop all notes and reset bpm/etc when seeking.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MuteMax">
            <summary>
            Sample: muted at max distance (3D only)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.VAM">
            <summary>
            Sample: uses the DX7 voice allocation and management
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SampleOverrideLowestVolume">
            <summary>
            Sample: override lowest volume
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SampleOverrideLongestPlaying">
            <summary>
            Sample: override longest playing
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SampleOverrideDistance">
            <summary>
            Sample: override furthest from listener (3D only)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.CDSubChannel">
            <summary>
            BASSCD add-on: Read sub-channel data.
            96 bytes of de-interleaved sub-channel data will be returned after each 2352 bytes of audio.
            This flag can not be used with the <see cref="F:ManagedBass.BassFlags.Float"/> flag,
            and is ignored if the <see cref="F:ManagedBass.BassFlags.Decode"/> flag is not used.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.CDSubchannelNoHW">
            <summary>
            BASSCD add-on: Read sub-channel data, without using any hardware de-interleaving.
            This is identical to the <see cref="F:ManagedBass.BassFlags.CDSubChannel"/> flag, except that the
            de-interleaving is always performed by BASSCD even if the drive is apparently capable of de-interleaving itself.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.CdC2Errors">
            <summary>
            BASSCD add-on: Include C2 error info.
            296 bytes of C2 error info is returned after each 2352 bytes of audio (and optionally 96 bytes of sub-channel data).
            This flag cannot be used with the <see cref="F:ManagedBass.BassFlags.Float"/> flag, and is ignored if the <see cref="F:ManagedBass.BassFlags.Decode"/> flag is not used.
            The first 294 bytes contain the C2 error bits (one bit for each byte of audio),
            followed by a byte containing the logical OR of all 294 bytes,
            which can be used to quickly check if there were any C2 errors.
            The final byte is just padding.
            Note that if you request both sub-channel data and C2 error info, the C2 info will come before the sub-channel data!
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SplitSlave">
            <summary>
            BASSmix add-on: only read buffered data.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerResume">
            <summary>
            BASSmix add-on: resume a stalled mixer immediately upon new/unpaused source
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerPositionEx">
            <summary>
            BASSmix add-on: enable <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags,System.Int32)"/> support.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerBuffer">
            <summary>
            BASSmix add-on: Buffer source data for <see cref="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerLimit">
            <summary>
            BASSmix add-on: Limit mixer processing to the amount available from this source.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerEnd">
            <summary>
            BASSmix add-on: end the stream when there are no sources
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerMatrix">
            <summary>
            BASSmix add-on: Matrix mixing
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerNonStop">
            <summary>
            BASSmix add-on: don't stall when there are no sources
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerPause">
            <summary>
            BASSmix add-on: don't process the source
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerDownMix">
            <summary>
            BASSmix add-on: downmix to stereo (or mono if mixer is mono)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerNoRampin">
            <summary>
            BASSmix add-on: don't ramp-in the start
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RecordPause">
            <summary>
            Recording: Start the recording paused. Use <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)"/> to start it.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RecordEchoCancel">
            <summary>
            Recording: Enable Echo Cancellation (only available on certain devices, like iOS).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RecordAGC">
            <summary>
            Recording: Enable Automatic Gain Control (only available on certain devices, like iOS).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerFront">
            <summary>
            Front speakers (channel 1/2)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRear">
            <summary>
            Rear/Side speakers (channel 3/4)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerCenterLFE">
            <summary>
            Center and LFE speakers (5.1, channel 5/6)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearCenter">
            <summary>
            Rear Center speakers (7.1, channel 7/8)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair1">
            <summary>
            Speakers Pair 1
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair2">
            <summary>
            Speakers Pair 2
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair3">
            <summary>
            Speakers Pair 3
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair4">
            <summary>
            Speakers Pair 4
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair5">
            <summary>
            Speakers Pair 5
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair6">
            <summary>
            Speakers Pair 6
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair7">
            <summary>
            Speakers Pair 7
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair8">
            <summary>
            Speakers Pair 8
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair9">
            <summary>
            Speakers Pair 9
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair10">
            <summary>
            Speakers Pair 10
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair11">
            <summary>
            Speakers Pair 11
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair12">
            <summary>
            Speakers Pair 12
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair13">
            <summary>
            Speakers Pair 13
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair14">
            <summary>
            Speakers Pair 14
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair15">
            <summary>
            Speakers Pair 15
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerLeft">
            <summary>
            Speaker Modifier: left channel only
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRight">
            <summary>
            Speaker Modifier: right channel only
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerFrontLeft">
            <summary>
            Front Left speaker only (channel 1)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearLeft">
            <summary>
            Rear/Side Left speaker only (channel 3)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerCenter">
            <summary>
            Center speaker only (5.1, channel 5)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearCenterLeft">
            <summary>
            Rear Center Left speaker only (7.1, channel 7)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerFrontRight">
            <summary>
            Front Right speaker only (channel 2)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearRight">
            <summary>
            Rear/Side Right speaker only (channel 4)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerLFE">
            <summary>
            LFE speaker only (5.1, channel 6)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearCenterRight">
            <summary>
            Rear Center Right speaker only (7.1, channel 8)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AacFrame960">
            <summary>
            BassAac add-on: use 960 samples per frame
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AacStereo">
            <summary>
            BassAac add-on: Downmatrix to Stereo
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DSDOverPCM">
            <summary>
            BassDSD add-on: Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the <see cref="F:ManagedBass.BassFlags.Float"/> flag is required.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DSDRaw">
            <summary>
            BassDSD add-on: Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest.
            DSD data is not playable by BASS, so the <see cref="F:ManagedBass.BassFlags.Decode"/> flag is required.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DownmixStereo">
            <summary>
            BassAC3 add-on: downmix to stereo
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DownmixQuad">
            <summary>
            BASS_AC3 add-on: downmix to quad
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DownmixDolby">
            <summary>
            BASS_AC3 add-on: downmix to dolby
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DRC">
            <summary>
            BASS_AC3 add-on: enable dynamic range compression
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowNoAudioProcessing">
            <summary>
            DSHOW add-on: Use this flag to disable audio processing.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowStreamMix">
            <summary>
            DSHOW add-on: Use this flag to enable mixing video on a channel.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowAutoDVD">
            <summary>
            DSHOW add-on: Use this flag to enable auto dvd functions(on mouse down, keys etc).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowLoop">
            <summary>
            DSHOW add-on: Use this flag to restart the stream when it's finished.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowVideoProcessing">
            <summary>
            DSHOW add-on: Use this to enable video processing.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.WVStereo">
            <summary>
            BassWV add-on: Limit to stereo
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.None">
            <summary>
            None of the flags are set
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.ContinuousRate">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.EmulatedDrivers">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated.
            Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Certified">
            <summary>
            The device driver has been certified by Microsoft.
            This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Mono">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Stereo">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Secondary8Bit">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Secondary16Bit">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:ManagedBass.ChannelAttribute">
            <summary>
            Channel attribute options used by <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" /> and <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Frequency">
             <summary>
             The sample rate of a channel... 0 = original rate (when the channel was created).
             <para>
             This attribute applies to playback of the channel, and does not affect the
             channel's sample data, so has no real effect on decoding channels.
             It is still adjustable though, so that it can be used by the BassMix add-on,
             and anything else that wants to use it.
             </para>
             <para>
             It is not possible to change the sample rate of a channel if the "with FX
             flag" DX8 effect implementation enabled on it, unless DirectX 9 or above is installed.
             </para>
             <para>
             Increasing the sample rate of a stream or MOD music increases its CPU usage,
             and reduces the Length of its playback Buffer in terms of time.
             If you intend to raise the sample rate above the original rate, then you may also need
             to increase the Buffer Length via the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
             config option to avoid break-ups in the sound.
             </para>
            
             <para><b>Platform-specific</b></para>
             <para>On Windows, the sample rate will get rounded down to a whole number during playback.</para>
             </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Volume">
            <summary>
            The volume level of a channel... 0 (silent) to 1 (full).
            <para>This can go above 1.0 on decoding channels.</para>
            <para>
            This attribute applies to playback of the channel, and does not affect the
            channel's sample data, so has no real effect on decoding channels.
            It is still adjustable though, so that it can be used by the BassMix add-on,
            and anything else that wants to use it.
            </para>
            <para>
            When using <see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)"/>
            to slide this attribute, a negative volume value can be used to fade-out and then stop the channel.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Pan">
             <summary>
             The panning/balance position of a channel... -1 (Full Left) to +1 (Full Right), 0 = Centre.
             <para>
             This attribute applies to playback of the channel, and does not affect the
             channel's sample data, so has no real effect on decoding channels.
             It is still adjustable though, so that it can be used by the <see cref="T:ManagedBass.Mix.BassMix"/> add-on,
             and anything else that wants to use it.
             </para>
             <para>
             It is not possible to set the pan position of a 3D channel.
             It is also not possible to set the pan position when using speaker assignment, but if needed,
             it can be done via a <see cref="T:ManagedBass.DSPProcedure"/> instead (not on mono channels).
             </para>
            
             <para><b>Platform-specific</b></para>
             <para>
             On Windows, this attribute has no effect when speaker assignment is used,
             except on Windows Vista and newer with the Bass.VistaSpeakerAssignment config option enabled.
             Balance control could be implemented via a <see cref="T:ManagedBass.DSPProcedure"/> instead
             </para>
             </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.EaxMix">
            <summary>
            The wet (reverb) / dry (no reverb) mix ratio... 0 (full dry) to 1 (full wet), -1 = automatically calculate the mix based on the distance (the default).
            <para>For a sample, stream, or MOD music channel with 3D functionality.</para>
            <para>
            Obviously, EAX functions have no effect if the output device does not support EAX.
            <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)"/> can be used to check that.
            </para>
            <para>
            EAX only affects 3D channels, but EAX functions do not require <see cref="M:ManagedBass.Bass.Apply3D"/> to apply the changes.
            LastError.NoEAX: The channel does not have EAX support.
            EAX only applies to 3D channels that are mixed by the hardware/drivers.
            <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)"/> can be used to check if a channel is being mixed by the hardware.
            EAX is only supported on Windows.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.NoBuffer">
            <summary>
            Non-Windows: Disable playback buffering?... 0 = no, else yes..
            <para>
            A playing channel is normally asked to render data to its playback Buffer in advance,
            via automatic Buffer updates or the <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> and <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> functions,
            ready for mixing with other channels to produce the final mix that is given to the output device.
            </para>
            <para>
            When this attribute is switched on (the default is off), that buffering is skipped and
            the channel will only be asked to produce data as it is needed during the generation of the final mix.
            This allows the lowest latency to be achieved, but also imposes tighter timing requirements
            on the channel to produce its data and apply any DSP/FX (and run mixtime syncs) that are set on it;
            if too long is taken, there will be a break in the output, affecting all channels that are playing on the same device.
            </para>
            <para>
            The channel's data is still placed in its playback Buffer when this attribute is on,
            which allows <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)"/> to be used, although there is
            likely to be less data available to them due to the Buffer being less full.
            </para>
            <para>This attribute can be changed mid-playback.</para>
            <para>If switched on, any already buffered data will still be played, so that there is no break in sound.</para>
            <para>This attribute is not available on Windows, as BASS does not generate the final mix.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.CPUUsage">
            <summary>
            The CPU usage of a channel. (in percentage).
            <para>
            This attribute gives the percentage of CPU that the channel is using,
            including the time taken by decoding and DSP processing, and any FX that are
            not using the "with FX flag" DX8 effect implementation.
            It does not include the time taken to add the channel's data to the final output mix during playback.
            The processing of some add-on stream formats may also not be entirely included,
            if they use additional decoding threads; see the add-on documentation for details.
            </para>
            <para>
            Like <see cref="P:ManagedBass.Bass.CPUUsage"/>, this function does not strictly tell the CPU usage, but rather how timely the processing is.
            For example, if it takes 10ms to generate 100ms of data, that would be 10%.
            </para>
            <para>
            If the reported usage exceeds 100%, that means the channel's data is taking longer to generate than to play.
            The duration of the data is based on the channel's current sample rate (<see cref="F:ManagedBass.ChannelAttribute.Frequency"/>).
            A channel's CPU usage is updated whenever it generates data.
            That could be during a playback Buffer update cycle, or a <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> call, or a <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> call.
            For a decoding channel, it would be in a <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)"/> call.
            </para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.SampleRateConversion">
            <summary>
            The sample rate conversion quality of a channel
            <para>
            0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation.
            Other values are also accepted but will be interpreted as 0 or 3, depending on whether they are lower or higher.
            </para>
            <para>
            When a channel has a different sample rate to what the output device is using,
            the channel's sample data will need to be converted to match the output device's rate during playback.
            This attribute determines how that is done.
            The linear interpolation option uses less CPU, but the sinc interpolation gives better sound quality (less aliasing),
            with the quality and CPU usage increasing with the number of points.
            A good compromise for lower spec systems could be to use sinc interpolation for music playback and linear interpolation for sound effects.
            </para>
            <para>
            Whenever possible, a channel's sample rate should match the output device's rate to avoid the need for any sample rate conversion.
            The device's sample rate could be used in <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />
            or <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" /> or <see cref="T:ManagedBass.Midi.BassMidi" /> stream creation calls, for example.
            </para>
            <para>
            The sample rate conversion occurs (when required) during playback,
            after the sample data has left the channel's playback Buffer, so it does not affect the data delivered by <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            Although this attribute has no direct effect on decoding channels,
            it is still available so that it can be used by the <see cref="T:ManagedBass.Mix.BassMix" /> add-on and anything else that wants to use it.
            </para>
            <para>
            This attribute can be set at any time, and changes take immediate effect.
            A channel's initial setting is determined by the <see cref="P:ManagedBass.Bass.SRCQuality" /> config option,
            or <see cref="P:ManagedBass.Bass.SampleSRCQuality" /> in the case of a sample channel.
            </para>
            <para><b>Platform-specific</b></para>
            <para>On Windows, sample rate conversion is handled by Windows or the output device/driver rather than BASS, so this setting has no effect on playback there.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.NetworkResumeBufferLevel">
            <summary>
            The download Buffer level required to resume stalled playback in percent... 0 - 100 (the default is 50%).
            <para>
            This attribute determines what percentage of the download Buffer (<see cref="P:ManagedBass.Bass.NetBufferLength"/>)
            needs to be filled before playback of a stalled internet stream will resume.
            It also applies to 'buffered' User file streams created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.ScannedInfo">
            <summary>
            The scanned info of a channel.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicAmplify">
            <summary>
            The amplification level of a MOD music... 0 (min) to 100 (max).
            <para>This will be rounded down to a whole number.</para>
            <para>
            As the amplification level get's higher, the sample data's range increases, and therefore, the resolution increases.
            But if the level is set too high, then clipping can occur, which can result in distortion of the sound.
            You can check the current level of a MOD music at any time by <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)"/>.
            By doing so, you can decide if a MOD music's amplification level needs adjusting.
            The default amplification level is 50.
            </para>
            <para>
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicPanSeparation">
            <summary>
            The pan separation level of a MOD music... 0 (min) to 100 (max), 50 = linear.
            <para>
            This will be rounded down to a whole number.
            By default BASS uses a linear panning "curve".
            If you want to use the panning of FT2, use a pan separation setting of around 35.
            To use the Amiga panning (ie. full left and right) set it to 100.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicPositionScaler">
            <summary>
            The position scaler of a MOD music... 1 (min) to 256 (max).
            <para>
            This will be rounded down to a whole number.
            When calling <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)"/>, the row (HIWORD) will be scaled by this value.
            By using a higher scaler, you can get a more precise position indication.
            The default scaler is 1.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicBPM">
            <summary>
            The BPM of a MOD music... 1 (min) to 255 (max).
            <para>
            This will be rounded down to a whole number.
            This attribute is a direct mapping of the MOD's BPM, so the value can be changed via effects in the MOD itself.
            Note that by changing this attribute, you are changing the playback Length.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicSpeed">
            <summary>
            The speed of a MOD music... 0 (min) to 255 (max).
            <para>
            This will be rounded down to a whole number.
            This attribute is a direct mapping of the MOD's speed, so the value can be changed via effects in the MOD itself.
            The "speed" is the number of ticks per row.
            Setting it to 0, stops and ends the music.
            Note that by changing this attribute, you are changing the playback Length.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicVolumeGlobal">
            <summary>
            The global volume level of a MOD music... 0 (min) to 64 (max, 128 for IT format).
            <para>
            This will be rounded down to a whole number.
            This attribute is a direct mapping of the MOD's global volume, so the value can be changed via effects in the MOD itself.
            The "speed" is the number of ticks per row.
            Setting it to 0, stops and ends the music.
            Note that by changing this attribute, you are changing the playback Length.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicActiveChannelCount">
            <summary>
            The number of active channels in a MOD music.
            <para>
            This attribute gives the number of channels (including virtual) that are currently active in the decoder,
            which may not match what is being heard during playback due to buffering.
            To reduce the time difference, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicVolumeChannel">
            <summary>
            The volume level... 0 (silent) to 1 (full) of a channel in a MOD music + channel#.
            <para>channel: The channel to set the volume of... 0 = 1st channel.</para>
            <para>
            The volume curve used by this attribute is always linear, eg. 0.5 = 50%.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.
            The volume level of all channels is initially 1 (full).
            This attribute can also be used to count the number of channels in a MOD Music.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicVolumeInstrument">
            <summary>
            The volume level... 0 (silent) to 1 (full) of an instrument in a MOD music + inst#.
            <para>inst: The instrument to set the volume of... 0 = 1st instrument.</para>
            <para>
            The volume curve used by this attribute is always linear, eg. 0.5 = 50%.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.
            The volume level of all instruments is initially 1 (full).
            For MOD formats that do not use instruments, read "sample" for "instrument".
            This attribute can also be used to count the number of instruments in a MOD music.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Tempo">
            <summary>
            BassFx Tempo: The Tempo in percents (-95%..0..+5000%).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Pitch">
            <summary>
            BassFx Tempo: The Pitch in semitones (-60..0..+60).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoFrequency">
            <summary>
            BassFx Tempo: The Samplerate in Hz, but calculates by the same % as <see cref="F:ManagedBass.ChannelAttribute.Tempo"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoUseAAFilter">
            <summary>
            BassFx Tempo Option: Use FIR low-pass (anti-alias) filter (gain speed, lose quality)? true=1 (default), false=0.
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            <para>On iOS, Android, WinCE and Linux ARM platforms this is by default disabled for lower CPU usage.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoAAFilterLength">
            <summary>
            BassFx Tempo Option: FIR low-pass (anti-alias) filter Length in taps (8 .. 128 taps, default = 32, should be %4).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoUseQuickAlgorithm">
            <summary>
            BassFx Tempo Option: Use quicker tempo change algorithm (gain speed, lose quality)? true=1, false=0 (default).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoSequenceMilliseconds">
            <summary>
            BassFx Tempo Option: Tempo Sequence in milliseconds (default = 82).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoSeekWindowMilliseconds">
            <summary>
            BassFx Tempo Option: SeekWindow in milliseconds (default = 14).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoOverlapMilliseconds">
            <summary>
            BassFx Tempo Option: Tempo Overlap in milliseconds (default = 12).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoPreventClick">
            <summary>
            BassFx Tempo Option: Prevents clicks with tempo changes (default = FALSE).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.ReverseDirection">
            <summary>
            Playback direction (-1 = Reverse or 1 = Forward).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiPPQN">
            <summary>
            BASSMIDI: Gets the Pulses Per Quarter Note (or ticks per beat) value of the MIDI file.
            <para>
            This attribute is the number of ticks per beat as defined by the MIDI file;
            it will be 0 for MIDI streams created via <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)"/>,
            It is read-only, so can't be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiCPU">
            <summary>
            BASSMIDI: The maximum percentage of CPU time that a MIDI stream can use... 0 to 100, 0 = unlimited.
            <para>
            It is not strictly the CPU usage that is measured, but rather how timely the stream is able to render data.
            For example, a limit of 50% would mean that the rendering would need to be at least 2x real-time speed.
            When the limit is exceeded, <see cref="T:ManagedBass.Midi.BassMidi"/> will begin killing voices, starting with the  most quiet.
            When the CPU usage is limited, the stream's samples are loaded asynchronously
            so that any loading delays (eg. due to slow disk) do not hold up the stream for too long.
            If a sample cannot be loaded in time, then it will be silenced
            until it is available and the stream will continue playing other samples as normal in the meantime.
            This does not affect sample loading via <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)"/>, which always operates synchronously.
            By default, a MIDI stream will have no CPU limit.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiChannels">
            <summary>
            BASSMIDI: The number of MIDI channels in a MIDI stream... 1 (min) - 128 (max).
            <para>
            For a MIDI file stream, the minimum is 16.
            New channels are melodic by default.
            Any notes playing on a removed channel are immediately stopped.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiVoices">
            <summary>
            BASSMIDI: The maximum number of samples to play at a time (polyphony) in a MIDI stream... 1 (min) - 1000 (max).
            <para>
            If there are currently more voices active than the new limit, then some voices will be killed to meet the limit.
            The number of voices currently active is available via the Voices attribute.
            A MIDI stream will initially have a default number of voices as determined by the Voices config option.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiVoicesActive">
            <summary>
            BASSMIDI: The number of samples (voices) currently playing in a MIDI stream.
            <para>This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiTrackVolume">
            <summary>
            BASSMIDI: The volume level (0.0=silent, 1.0=normal/default) of a track in a MIDI file stream + track#.
            <para>track#: The track to set the volume of... 0 = first track.</para>
            <para>
            The volume curve used by this attribute is always linear, eg. 0.5 = 50%.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            This attribute can also be used to count the number of tracks in a MIDI file stream.
            MIDI streams created via <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)"/> do not have any tracks.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.OpusOriginalFrequency">
            <summary>
            BassOpus: The sample rate of an Opus stream's source material.
            <para>
            Opus streams always have a sample rate of 48000 Hz, and an Opus encoder will resample the source material to that if necessary.
            This attribute presents the original sample rate, which may be stored in the Opus file header.
            This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.DSDGain">
            <summary>
            BassDSD: The gain (in decibels) applied when converting to PCM.
            </summary>
            <remarks>
            This attribute is only applicable when converting to PCM, and is unavailable when producing DSD-over-PCM or raw DSD data.
            The default setting is determined by the <see cref="F:ManagedBass.ChannelAttribute.DSDGain" /> config option
            </remarks>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.DSDRate">
            <summary>
            BassDSD: The DSD sample rate.
            </summary>
            <remarks>This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.</remarks>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MixerLatency">
            <summary>
            BassMix: Custom output latency in seconds... default = 0 (no accounting for latency). Changes take immediate effect.
            </summary>
            <remarks>
            When a mixer is played by BASS, the <see cref="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)"/>, <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)"/>, and <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)"/> functions will get the output latency and account for that so that they reflect what is currently being heard, but that cannot be done when a different output system is used, eg. ASIO or WASAPI.
            In that case, this attribute can be used to tell the mixer what the output latency is, so that those functions can still account for it.
            The mixer needs to have the <see cref="F:ManagedBass.BassFlags.Decode"/> and <see cref="F:ManagedBass.BassFlags.MixerPositionEx"/> flags set to use this attribute. 
            </remarks>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Bitrate">
            <summary>
            The average bitrate of a file stream. 
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.NoRamp">
            <summary>
            Disable playback ramping? 
            </summary>
        </member>
        <member name="T:ManagedBass.ChannelType">
            <summary>
            Channel Type flags to be used with <see cref="T:ManagedBass.ChannelInfo" /> (see also <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Unknown">
            <summary>
            Unknown channel format.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Sample">
            <summary>
            Sample channel. (HCHANNEL)
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Recording">
            <summary>
            Recording channel. (HRECORD)
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MO3">
            <summary>
            MO3 format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.ZXTune">
            <summary>
            ZXTune.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Stream">
            <summary>
            User sample stream.
            This can also be used as a flag to test if the channel is any kind of HSTREAM.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.OGG">
            <summary>
            OGG format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP1">
            <summary>
            MP1 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP2">
            <summary>
            MP2 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP3">
            <summary>
            MP3 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AIFF">
            <summary>
            WAV format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MF">
            <summary>
            Media Foundation codec stream. Additional information is avaliable via the <see cref="F:ManagedBass.TagType.MF"/> tag.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.CD">
            <summary>
            Audio-CD, CDA
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WMA">
            <summary>
            WMA format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WMA_MP3">
            <summary>
            MP3 over WMA format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WINAMP">
            <summary>
            Winamp Input format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV">
            <summary>
            WavPack Lossless format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV_H">
            <summary>
            WavPack Hybrid Lossless format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV_L">
            <summary>
            WavPack Lossy format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV_LH">
            <summary>
            WavPack Hybrid Lossy format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.OFR">
            <summary>
            Optimfrog format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.APE">
            <summary>
            APE format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Mixer">
            <summary>
            BassMix mixer stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Split">
            <summary>
            BassMix splitter stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.FLAC">
            <summary>
            FLAC format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.FLAC_OGG">
            <summary>
            FLAC OGG format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MPC">
            <summary>
            MPC format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AAC">
            <summary>
            AAC format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP4">
            <summary>
            MP4 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.SPX">
            <summary>
            Speex format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MIDI">
            <summary>
            MIDI sound format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.ALAC">
            <summary>
            Apple Lossless (ALAC) format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.TTA">
            <summary>
            TTA format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AC3">
            <summary>
            AC3 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Video">
            <summary>
            Video format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.OPUS">
            <summary>
            Opus format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.DSD">
            <summary>
            Direct Stream Digital (DSD) format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.ADX">
            <summary>
            ADX format stream.
            <para>
            ADX is a lossy proprietary audio storage and compression format developed
            by CRI Middleware specifically for use in video games, it is derived from ADPCM.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AIX">
            <summary>
            AIX format stream.
            Only for ADX of all versions (with AIXP support).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Tempo">
            <summary>
            BassFx tempo stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Reverse">
            <summary>
            BassFx reverse stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MOD">
            <summary>
            MOD format music.
            This can also be used as a flag to test if the channel is any kind of HMusic.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MTM">
            <summary>
            MTM format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.S3M">
            <summary>
            S3M format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.XM">
            <summary>
            XM format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.IT">
            <summary>
            IT format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Wave">
            <summary>
            Wave format stream, LoWord = codec.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WavePCM">
            <summary>
            Wave format stream, PCM 16-bit.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WaveFloat">
            <summary>
            Wave format stream, Float 32-bit.
            </summary>
        </member>
        <member name="T:ManagedBass.DataFlags">
            <summary>
            Flags to be used with <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.Available">
            <summary>
            Query how much data is buffered
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTIndividual">
            <summary>
            FFT flag: FFT for each channel, else all combined
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTNoWindow">
            <summary>
            FFT flag: no Hanning window
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTRemoveDC">
            <summary>
            FFT flag: pre-remove DC bias
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTComplex">
            <summary>
            FFT flag: return complex data
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.Float">
            <summary>
            flag: return floating-point sample data
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT256">
            <summary>
            256 sample FFT (returns 128 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT512">
            <summary>
            512 sample FFT (returns 256 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT1024">
            <summary>
            1024 sample FFT (returns 512 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT2048">
            <summary>
            2048 sample FFT (returns 1024 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT4096">
            <summary>
            4096 sample FFT (returns 2048 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT8192">
            <summary>
            8192 sample FFT (returns 4096 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT16384">
            <summary>
            16384 sample FFT (returns 8192 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT32768">
            <summary>
            32768 FFT
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.None">
            <summary>
            The device is not enabled and not initialized.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.Enabled">
            <summary>
            The device is enabled.
            It will not be possible to initialize the device if this flag is not present.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.Default">
            <summary>
            The device is the system default.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.Initialized">
            <summary>
            The device is initialized, ie. <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> or <see cref="M:ManagedBass.Bass.RecordInit(System.Int32)"/> has been called.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.TypeMask">
            <summary>
            Bitmask to identify the device Type.
            </summary>
        </member>
        <member name="T:ManagedBass.DeviceInitFlags">
            <summary>
            Initialization flags to be used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Default">
            <summary>
            0 = 16 bit, stereo, no 3D, no Latency calc, no Speaker Assignments
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Byte">
            <summary>
            Use 8 bit resolution, else 16 bit.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Mono">
            <summary>
            Use mono, else stereo.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Device3D">
            <summary>
            Enable 3D functionality.
            Note: If this is not specified when initilizing BASS,
            then the <see cref="F:ManagedBass.BassFlags.Bass3D"/> is ignored when loading/creating a sample/stream/music.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Latency">
            <summary>
            Calculate device latency (<see cref="T:ManagedBass.BassInfo"/> struct).
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.CPSpeakers">
            <summary>
            Use the Windows control panel setting to detect the number of speakers.
            Only use this option if BASS doesn't detect the correct number of supported
            speakers automatically and you want to force BASS to use the number of speakers
            as configured in the windows control panel.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment">
            <summary>
            Force enabling of speaker assignment (always 8 speakers will be used regardless if the soundcard supports them).
            Only use this option if BASS doesn't detect the correct number of supported
            speakers automatically and you want to force BASS to use 8 speakers.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.NoSpeakerAssignment">
            <summary>
            Ignore speaker arrangement
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Frequency">
            <summary>
            Set the device's output rate to freq, otherwise leave it as it is.
            </summary>
        </member>
        <member name="T:ManagedBass.DeviceType">
            <summary>
            Device Type to be used with <see cref="T:ManagedBass.DeviceInfo" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Network">
            <summary>
            An audio endpoint Device that the User accesses remotely through a network.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Speakers">
            <summary>
            A set of speakers.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Line">
            <summary>
            An audio endpoint Device that sends a line-level analog signal to
            a line-Input jack on an audio adapter or that receives a line-level analog signal
            from a line-output jack on the adapter.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Headphones">
            <summary>
            A set of headphones.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Microphone">
            <summary>
            A microphone.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Headset">
            <summary>
            An earphone or a pair of earphones with an attached mouthpiece for two-way communication.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Handset">
            <summary>
            The part of a telephone that is held in the hand and
            that contains a speaker and a microphone for two-way communication.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Digital">
            <summary>
            An audio endpoint Device that connects to an audio adapter through a connector
            for a digital interface of unknown Type.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.SPDIF">
            <summary>
            An audio endpoint Device that connects to an audio adapter through
            a Sony/Philips Digital Interface (S/PDIF) connector.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.HDMI">
            <summary>
            An audio endpoint Device that connects to an audio adapter through
            a High-Definition Multimedia Interface (HDMI) connector.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.DisplayPort">
            <summary>
            An audio endpoint Device that connects to an audio adapter through a DisplayPort connector.
            </summary>
        </member>
        <member name="T:ManagedBass.DXPhase">
            <summary>
            DX8 effect phase.
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Negative180">
            <summary>
            Phase differential between left and right LFOs (-180)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Negative90">
            <summary>
            Phase differential between left and right LFOs (-90)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Zero">
            <summary>
            Phase differential between left and right LFOs (+/-0)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Positive90">
            <summary>
            Phase differential between left and right LFOs (+90)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Positive180">
            <summary>
            Phase differential between left and right LFOs (+180)
            </summary>
        </member>
        <member name="T:ManagedBass.DXWaveform">
            <summary>
            DirectX Effect Waveform.
            </summary>
        </member>
        <member name="F:ManagedBass.DXWaveform.Triangle">
            <summary>
            Triangle Wave.
            </summary>
        </member>
        <member name="F:ManagedBass.DXWaveform.Sine">
            <summary>
            Sine Wave.
            </summary>
        </member>
        <member name="T:ManagedBass.EffectType">
            <summary>
            FX effect types, use with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXChorus">
            <summary>
            DX8 Chorus.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXCompressor">
            <summary>
            DX8 Compressor
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXDistortion">
            <summary>
            DX8 Distortion.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXEcho">
            <summary>
            DX8 Echo.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXFlanger">
            <summary>
            DX8 Flanger.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXGargle">
            <summary>
            DX8 Gargle.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DX_I3DL2Reverb">
            <summary>
            DX8 I3DL2 (Interactive 3D Audio Level 2) reverb.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXParamEQ">
            <summary>
            DX8 Parametric equalizer.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXReverb">
            <summary>
            DX8 Reverb.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Rotate">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Channel Volume Ping-Pong (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Volume">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Volume control (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.PeakEQ">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Peaking Equalizer (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Mix">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Channel Swap/Remap/Downmix (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Damp">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Dynamic Amplification (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.AutoWah">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Auto WAH (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Phaser">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Phaser (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Chorus">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Chorus (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Distortion">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Distortion (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Compressor">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Dynamic Range Compressor (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.VolumeEnvelope">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Volume Envelope (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.BQF">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: BiQuad filters (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Echo">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Echo/Reverb 4 (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.PitchShift">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Pitch Shift using FFT (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Freeverb">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Pitch Shift using FFT (multi channel).
            </summary>
        </member>
        <member name="T:ManagedBass.FileStreamPosition">
            <summary>
            Stream File Position modes to be used with <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" />
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Current">
            <summary>
            Position that is to be decoded for playback next.
            This will be a bit ahead of the position actually being heard due to buffering.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Download">
            <summary>
            Download progress of an internet file stream or "buffered" User file stream.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.End">
            <summary>
            End of the file, in other words the file Length.
            When streaming in blocks, the file Length is unknown, so the download Buffer Length is returned instead.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Start">
            <summary>
            Start of stream data in the file.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Connected">
            <summary>
            Internet file stream or "buffered" User file stream is still connected? 0 = no, 1 = yes.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Buffer">
            <summary>
            The amount of data in the Buffer of an internet file stream or "buffered" User file stream.
            Unless streaming in blocks, this is the same as <see cref="F:ManagedBass.FileStreamPosition.Download"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Socket">
            <summary>
            Returns the socket hanlde used for streaming.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.AsyncBuffer">
            <summary>
            The amount of data in the asynchronous file reading Buffer.
            This requires that the <see cref="F:ManagedBass.BassFlags.AsyncFile"/> flag was used at the stream's creation.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.WmaBuffer">
            <summary>
            WMA add-on: internet buffering progress (0-100%)
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.HlsSegment">
            <summary>
            Segment Sequence number.
            </summary>
        </member>
        <member name="T:ManagedBass.FXChannelFlags">
            <summary>
            DSP channels flags.
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.All">
            <summary>
            All channels at once (as by default).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.None">
            <summary>
            Disable an effect for all channels (resp. set the global volume of the Volume effect).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel1">
            <summary>
            left-front channel
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel2">
            <summary>
            right-front channel
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel3">
            <summary>
            Channel 3: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel4">
            <summary>
            Channel 4: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel5">
            <summary>
            Channel 5: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel6">
            <summary>
            Channel 6: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel7">
            <summary>
            Channel 7: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel8">
            <summary>
            Channel 8: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel9">
            <summary>
            Channel 9: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel10">
            <summary>
            Channel 10: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel11">
            <summary>
            Channel 11: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel12">
            <summary>
            Channel 12: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel13">
            <summary>
            Channel 13: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel14">
            <summary>
            Channel 14: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel15">
            <summary>
            Channel 15: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel16">
            <summary>
            Channel 16: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel17">
            <summary>
            Channel 17: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel18">
            <summary>
            Channel 18: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel19">
            <summary>
            Channel 19: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel20">
            <summary>
            Channel 20: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel21">
            <summary>
            Channel 21: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel22">
            <summary>
            Channel 22: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel23">
            <summary>
            Channel 23: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel24">
            <summary>
            Channel 24: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel25">
            <summary>
            Channel 25: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel26">
            <summary>
            Channel 26: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel27">
            <summary>
            Channel 27: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel28">
            <summary>
            Channel 28: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel29">
            <summary>
            Channel 29: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel30">
            <summary>
            Channel 30: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="T:ManagedBass.InputFlags">
            <summary>
            <see cref="M:ManagedBass.Bass.RecordSetInput(System.Int32,ManagedBass.InputFlags,System.Single)" /> flags.
            </summary>
        </member>
        <member name="F:ManagedBass.InputFlags.None">
            <summary>
            Don't change any setting. 
            Use this flag, if you only want to set the volume.
            </summary>
        </member>
        <member name="F:ManagedBass.InputFlags.Off">
            <summary>
            Disable the Input.
            This flag can't be used when the device supports only one Input at a time.
            </summary>
        </member>
        <member name="F:ManagedBass.InputFlags.On">
            <summary>
            Enable the Input.
            If the device only allows one Input at a time, then any previously enabled Input will be disabled by this.
            </summary>
        </member>
        <member name="T:ManagedBass.InputTypeFlags">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)"/> applying <see cref="F:ManagedBass.InputTypeFlags.InputTypeMask"/> on the return value;
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.InputTypeMask">
            <summary>
            The Type of Input is also indicated in the high 8-bits of <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)"/> (use this to test the return value).
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Error">
            <summary>
            The Type of Input is errorness.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Undefined">
            <summary>
            Anything that is not covered by the other types
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Digital">
            <summary>
            Digital Input source, for example, a DAT or audio CD.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Line">
            <summary>
            Line-in. On some devices, "Line-in" may be combined with other analog sources into a single Analog Input.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Microphone">
            <summary>
            Microphone.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.MIDISynthesizer">
            <summary>
            Internal MIDI synthesizer.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.AnalogCD">
            <summary>
            Analog audio CD.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Phone">
            <summary>
            Telephone.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Speaker">
            <summary>
            PC speaker.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Wave">
            <summary>
            The device's WAVE/PCM output.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Auxiliary">
            <summary>
            Auxiliary. Like "Line-in", "Aux" may be combined with other analog sources into a single Analog Input on some devices.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Analog">
            <summary>
            Analog, typically a mix of all analog sources (what you hear).
            </summary>
        </member>
        <member name="T:ManagedBass.LevelRetrievalFlags">
            <summary>
            Level retrieval flags (to be used with <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)" />).
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.All">
            <summary>
            Retrieves mono levels
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.Mono">
            <summary>
            Retrieves mono levels
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.Stereo">
            <summary>
            Retrieves stereo levels
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.RMS">
            <summary>
            Optional Flag: If set it returns RMS levels instead of peak leavels
            </summary>
        </member>
        <member name="T:ManagedBass.Mode3D">
            <summary>
            3D Channel Mode flags used with <see cref="T:ManagedBass.SampleInfo" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.LeaveCurrent">
            <summary>
            To be used with <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            in order to leave the current 3D processing mode unchanged.
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.Normal">
            <summary>
            Normal 3D processing
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.Relative">
            <summary>
            The channel's 3D position (position/velocity/orientation) are relative to the listener.
            When the listener's position/velocity/orientation is changed with <see cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>,
            the channel's position relative to the listener does not change.
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.Off">
            <summary>
            Turn off 3D processing on the channel, the sound will be played in the center.
            </summary>
        </member>
        <member name="T:ManagedBass.PlaybackState">
            <summary>
            <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> return values.
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Stopped">
            <summary>
            The channel is not active, or Handle is not a valid channel.
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Playing">
            <summary>
            The channel is playing (or recording).
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Stalled">
            <summary>
            Playback of the stream has been stalled due to there not being enough sample
            data to continue playing. The playback will automatically resume once there's
            sufficient data to do so.
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Paused">
            <summary>
            The channel is paused.
            </summary>
        </member>
        <member name="T:ManagedBass.PositionFlags">
            <summary>
            Channel Position Mode flags to be used with e.g. <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />, <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />,
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> or <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Bytes">
            <summary>
            Byte position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MusicOrders">
            <summary>
            Order.Row position (HMUSIC only).
            LoWord = order, HiWord = row * scaler (<see cref="F:ManagedBass.ChannelAttribute.MusicPositionScaler" />).
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MIDITick">
            <summary>
            Tick position (MIDI streams only).
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.OGG">
            <summary>
            OGG bitstream number.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.CDTrack">
            <summary>
            CD Add-On: the track number.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.ZXTuneSubCount">
            <summary>
            ZXTune Sub Count.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.ZXTuneSubLength">
            <summary>
            ZXTune Sub Length.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MIDIDecaySeek">
            <summary>
            Midi Add-On: Let the old sound decay naturally (including reverb) when changing the position,
            including looping and such can also be used in <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/> calls to have it apply to particular position changes.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MusicPositionReset">
            <summary>
            MOD Music Flag: Stop all notes when moving position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MusicPositionResetEx">
            <summary>
            MOD Music Flag: Stop all notes and reset bmp/etc when moving position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MixerNoRampIn">
            <summary>
            Mixer Flag: Don't ramp-in the start after seeking.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Inexact">
            <summary>
            Flag: Allow inexact seeking.
            For speed, seeking may stop at the beginning of a block rather than partially processing the block to reach the requested position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Decode">
            <summary>
            Get the decoding (not playing) position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.DecodeTo">
            <summary>
            Flag: decode to the position instead of seeking.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Scan">
            <summary>
            Scan the file to build a seek table up to the position, if it has not already been scanned.
            Scanning will continue from where it left off previously rather than restarting from the beginning of the file each time.
            This flag only applies to MP3/MP2/MP1 files and will be ignored with other file formats.
            </summary>
        </member>
        <member name="T:ManagedBass.RecordFormatFlags">
            <summary>
            Formats flags of <see cref="P:ManagedBass.RecordInfo.SupportedFormats"/> member to be used with <see cref="T:ManagedBass.RecordInfo" />
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.Unknown">
            <summary>
            Unknown Format
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1M08">
            <summary>
            11.025 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1S08">
            <summary>
            11.025 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1M16">
            <summary>
            11.025 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1S16">
            <summary>
            11.025 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2M08">
            <summary>
            22.05 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2S08">
            <summary>
            22.05 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2M16">
            <summary>
            22.05 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2S16">
            <summary>
            22.05 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4M08">
            <summary>
            44.1 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4S08">
            <summary>
            44.1 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4M16">
            <summary>
            44.1 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4S16">
            <summary>
            44.1 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48M08">
            <summary>
            48 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48S08">
            <summary>
            48 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48M16">
            <summary>
            48 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48S16">
            <summary>
            48 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96M08">
            <summary>
            96 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96S08">
            <summary>
            96 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96M16">
            <summary>
            96 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96S16">
            <summary>
            96 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="T:ManagedBass.RecordInfoFlags">
            <summary>
            Flags to be used with <see cref="T:ManagedBass.RecordInfo" />
            </summary>
        </member>
        <member name="F:ManagedBass.RecordInfoFlags.None">
            <summary>
            None of the flags is set
            </summary>
        </member>
        <member name="F:ManagedBass.RecordInfoFlags.EmulatedDrivers">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated.
            Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:ManagedBass.RecordInfoFlags.Certified">
            <summary>
            The device driver has been certified by Microsoft.
            This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="T:ManagedBass.StreamProcedureType">
            <summary>
            <see cref="T:ManagedBass.StreamProcedure"/> flag used with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> resp. used with a User sample stream to be used with <see cref="T:ManagedBass.StreamProcedure" />.
            </summary>
        </member>
        <member name="F:ManagedBass.StreamProcedureType.End">
            <summary>
            Flag to signify that the end of the stream is reached.
            </summary>
        </member>
        <member name="F:ManagedBass.StreamProcedureType.Push">
            <summary>
            Create a "push" stream.
            Instead of BASS pulling data from a StreamProcedure function, data is pushed to
            BASS via <see cref="M:ManagedBass.Bass.StreamPutData(System.Int32,System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.StreamProcedureType.Dummy">
            <summary>
            Create a "dummy" stream.
            A dummy stream doesn't have any sample data of its own, but a decoding dummy
            stream (with <see cref="F:ManagedBass.BassFlags.Decode"/> flag) can be used to apply DSP/FX processing
            to any sample data, by setting DSP/FX on the stream and feeding the data through <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>.
            The dummy stream should have the same sample format as the data being fed through it.
            </summary>
        </member>
        <member name="T:ManagedBass.StreamSystem">
            <summary>
            User file system flag to be used with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />
            </summary>
        </member>
        <member name="F:ManagedBass.StreamSystem.NoBuffer">
            <summary>
            Unbuffered file system (like also used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />).
            <para>
            The unbuffered file system is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />.
            In this system, BASS does not do any intermediate buffering - it simply requests data from the file as and when it needs it.
            This means that reading (<see cref="T:ManagedBass.FileReadProcedure" />) must be quick,
            otherwise the decoding will be delayed and playback Buffer underruns (old data repeated) are a possibility.
            It's not so important for seeking (<see cref="T:ManagedBass.FileSeekProcedure" />) to be fast, as that is generally not required during decoding, except when looping a file.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.StreamSystem.Buffer">
            <summary>
            Buffered file system (like also used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />).
            <para>
            The buffered file system is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            As the name suggests, data from the file is buffered so that it's readily available for decoding -
            BASS creates a thread dedicated to "downloading" the data. This is ideal for when the data is coming from a source that has high latency, like the internet.
            It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.StreamSystem.BufferPush">
            <summary>
            Buffered, with the data pushed to BASS via <see cref="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)" />.
            <para>
            The push buffered file system is the same as <see cref="F:ManagedBass.StreamSystem.Buffer"/>, except that instead of the file data being pulled from the <see cref="T:ManagedBass.FileReadProcedure" /> function in a "download" thread,
            the data is pushed to BASS via <see cref="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)" />.
            A <see cref="T:ManagedBass.FileReadProcedure" /> function is still required, to get the initial data used in the creation of the stream.
            </para>
            </summary>
        </member>
        <member name="T:ManagedBass.SyncFlags">
            <summary>
            Sync types to be used with <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> (param flag) and <see cref="T:ManagedBass.SyncProcedure" /> (data flag).
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Onetime">
            <summary>
            FLAG: sync only once, else continuously
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Mixtime">
            <summary>
            FLAG: sync at mixtime, else at playtime
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Position">
            <summary>
            Sync when a channel reaches a position.
            param : position in bytes
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MusicInstrument">
            <summary>
            Sync when an instrument (sample for the non-instrument based formats) is played in a MOD music (not including retrigs).
            param : LOWORD=instrument (1=first) HIWORD=note (0=c0...119=b9, -1=all)
            data : LOWORD=note HIWORD=volume (0-64)
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.End">
            <summary>
            Sync when a channel reaches the end.
            param : not used
            data : 1 = the sync is triggered by a backward jump in a MOD music, otherwise not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MusicFx">
            <summary>
            Sync when the "sync" effect (XM/MTM/MOD: E8x/Wxx, IT/S3M: S2x) is used.
            param : 0:data=Position, 1:data="x" value
            data : param=0: LOWORD=order HIWORD=row, param=1: "x" value
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MetadataReceived">
            <summary>
            Sync when metadata is received in a stream.
            param : not used
            data : not used - the updated metadata is available from <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Slided">
            <summary>
            Sync when an attribute slide is completed.
            param : not used
            data : the Type of slide completed (one of the <see cref="T:ManagedBass.ChannelAttribute"/> values)
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Stalled">
            <summary>
            Sync when playback has stalled.
            param : not used
            data : 0=stalled, 1=resumed
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Downloaded">
            <summary>
            Sync when downloading of an internet (or "buffered" User file) stream has ended.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Free">
            <summary>
            Sync when a channel is freed.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MusicPosition">
            <summary>
            Sync when a MOD music reaches an order:row position.
            param : LOWORD=order (0=first, -1=all) HIWORD=row (0=first, -1=all)
            data : LOWORD=order HIWORD=row
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Seeking">
            <summary>
            Sync when seeking (inc. looping and restarting).
            So it could be used to reset DSP/etc.
            param : position in bytes
            data : 0=playback is unbroken, 1=if is it broken (eg. Buffer flushed).
            The latter would be the time to reset DSP/etc.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.OggChange">
            <summary>
            Sync when a new logical bitstream begins in a chained OGG stream.
            Updated tags are available from <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Stop">
            <summary>
            Sync when the DirectSound Buffer fails during playback, eg. when the device is no longer available.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.WinampBitRate">
            <summary>
            WINAMP add-on: Sync when bitrate is changed or retrieved from a winamp Input plug-in.
            param : not used
            data : the bitrate retrieved from the winamp Input plug-in -
            called when it is retrieved or changed (VBR MP3s, OGGs, etc).
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.CDError">
            <summary>
            CD add-on: Sync when playback is stopped due to an error.
            For example, the drive door being opened.
            param : not used
            data : the position that was being read from the CD track at the time.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.CDSpeed">
            <summary>
            CD add-on: Sync when the read speed is automatically changed due to the BassCd.AutoSpeedReduction setting.
            param : not used
            data : the new read speed.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiMarker">
            <summary>
            MIDI add-on: Sync when a marker is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)"/> call.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiCue">
            <summary>
            MIDI add-on: Sync when a cue is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)"/> call.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiLyric">
            <summary>
            MIDI add-on: Sync when a lyric event is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)"/> call.
            If the text begins with a '/' (slash) character, a new line should be started.
            If it begins with a '\' (backslash) character, the display should be cleared.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiText">
            <summary>
            MIDI add-on: Sync when a text event is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)"/> call.
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiEvent">
            <summary>
            MIDI add-on: Sync when a Type of event is processed, in either a MIDI file or <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)"/>.
            param : event Type (0 = all types).
            data : LOWORD = event parameter, HIWORD = channel (high 8 bits contain the event Type when syncing on all types).
            See <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)"/> for a list of event types and their parameters.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiTick">
            <summary>
            MIDI add-on: Sync when reaching a tick position.
            param : tick position.
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiTimeSignature">
            <summary>
            MIDI add-on: Sync when a time signature event is processed.
            param : event Type.
            data : The time signature events are given (by <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)"/>)
            in the form of "numerator/denominator metronome-pulse 32nd-notes-per-MIDI-quarter-note", eg. "4/4 24 8".
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiKeySignature">
            <summary>
            MIDI add-on: Sync when a key signature event is processed.
            param : event Type.
            data : The key signature events are given (by <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)"/>) in the form of "a b",
            where a is the number of sharps (if positive) or flats (if negative),
            and b signifies major (if 0) or minor (if 1).
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.WmaChange">
            <summary>
            WMA add-on: Sync on a track change in a server-side playlist.
            Updated tags are available via <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.WmaMeta">
            <summary>
            WMA add-on: Sync on a mid-stream tag change in a server-side playlist.
            Updated tags are available via <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            param : not used
            data : not used - the updated metadata is available from <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MixerEnvelope">
            <summary>
            MIX add-on: Sync when an envelope reaches the end.
            param : not used
            data : envelope Type
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MixerEnvelopeNode">
            <summary>
            MIX add-on: Sync when an envelope node is reached.
            param : Optional limit the sync to a certain envelope Type (one of the BASSMIXEnvelope values).
            data : Will contain the envelope Type in the LOWORD and the current node number in the HIWORD.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.HlsSegement">
            <summary>
            Sync when a new segment begins downloading.
            Mixtime only.
            param: not used.
            data: not used.
            </summary>
        </member>
        <member name="T:ManagedBass.TagType">
            <summary>
            Types of what's returned by <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ID3">
            <summary>
            ID3v1 tags : A pointer to a 128 byte block is returned.
            See www.id3.org for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ID3v2">
            <summary>
            ID3v2 tags : A pointer to a variable Length block is returned.
            See www.id3.org for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.OGG">
            <summary>
            OGG comments : Only available when streaming an OGG file.
            A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.HTTP">
            <summary>
            HTTP headers : Only available when streaming from a HTTP server.
            A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ICY">
            <summary>
            ICY headers : A pointer to a series of null-terminated ANSI strings is returned,
            the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.META">
            <summary>
            ICY (Shoutcast) metadata : A single null-terminated ANSI string containing
            the current stream title and url (usually omitted).
            The format of the string is: StreamTitle='xxx';StreamUrl='xxx';
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.APE">
            <summary>
            APE (v1 or v2) tags : Only available when streaming an APE file.
            A pointer to a series of null-terminated UTF-8 strings is returned,
            the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MP4">
            <summary>
            iTunes/MP4 metadata : Only available when streaming a MP4 file.
            A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WMA">
            <summary>
            WMA header tags: WMA tags : Only available when streaming a WMA file.
            A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.OggEncoder">
            <summary>
            OGG encoder : A single null-terminated UTF-8 string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.Lyrics3v2">
            <summary>
            Lyric3v2 tag : A single ANSI string is returned, containing the Lyrics3v2 information.
            See www.id3.org/Lyrics3v2 for details of its format.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WmaMeta">
            <summary>
            WMA mid-stream tag: a single UTF-8 string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WmaCodec">
            <summary>
            WMA codec: A description of the codec used by the file.
            2 null-terminated UTF-8 strings are returned, with the 1st string being the name of the codec,
            and the 2nd containing additional information like what VBR setting was used.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.FlacCue">
            <summary>
            FLAC cuesheet.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MF">
            <summary>
            Media Foundation tags : A pointer to a series of null-terminated UTF-8 strings
            is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WaveFormat">
            <summary>
            WAVE format : A pointer to a <see cref="F:ManagedBass.TagType.WaveFormat"/> structure is returned.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ZXTuneSuOgg">
            <summary>
            ZXTune Sub Ogg.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffInfo">
            <summary>
            RIFF/WAVE tags : array of null-terminated ANSI strings.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffBext">
            <summary>
            BWF/RF64 tags (Broadcast Audio Extension) : A pointer to a variable Length block is returned.
            See the EBU specification for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffCart">
            <summary>
            RIFF/BWF Radio Traffic Extension tags : A pointer to a variable Length block is returned.
            See the EBU specifications for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffDISP">
            <summary>
            RIFF DISP text chunk: a single ANSI string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ApeBinary">
            <summary>
            + index# : <see cref="T:ManagedBass.Ape.ApeBinaryTag"/> structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicName">
            <summary>
            MOD music name : a single ANSI string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicMessage">
            <summary>
            MOD message : a single ANSI string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicOrders">
            <summary>
            MOD music order list: BYTE array of pattern numbers played at that order position.
            Pattern number 254 is "+++" (skip order) and 255 is "---" (end song).
            You can use <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)"/> with <see cref="F:ManagedBass.PositionFlags.MusicOrders"/> to get the Length of the array.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicAuth">
            <summary>
            MOD author : UTF-8 string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicInstrument">
            <summary>
            + instrument#, MOD instrument name : ANSI string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicSample">
            <summary>
            + sample#, MOD sample name : ANSI string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MidiTrack">
            <summary>
            + track#, track text : array of null-terminated ANSI strings
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.FlacPicture">
            <summary>
            + index# : FLACPicture structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.AdxLoop">
            <summary>
            ADX tags: A pointer to the ADX loop structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.DSDArtist">
            <summary>
            DSDIFF artist : ASCII string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.DSDTitle">
            <summary>
            DSDIFF title : ASCII string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.DSDComment">
            <summary>
            + index, DSDIFF comment : A pointer to the DSDIFF comment tag structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.HlsExtInf">
            <summary>
            Segment's EXTINF tag: UTF-8 string.
            </summary>
        </member>
        <member name="T:ManagedBass.VAMMode">
            <summary>
            Voice allocation management flags.
            These flags enable hardware resource stealing... if the hardware has no	available voices, a currently playing Buffer will be stopped to make room for the new Buffer.
            </summary>
            <remarks>
            NOTE: only samples loaded/created with the <see cref="F:ManagedBass.BassFlags.VAM"/> flag are considered for termination by the DX7 voice management.
            </remarks>
        </member>
        <member name="F:ManagedBass.VAMMode.Hardware">
            <summary>
            Play the sample in hardware (default).
            If no hardware voices are available then the "play" call will fail.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.Software">
            <summary>
            Play the sample in software (ie. non-accelerated).
            No other VAM flags may be used together with this flag.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.TerminateTime">
            <summary>
            If there are no free hardware voices,
            the Buffer to be terminated will be the one with the least time left to play.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.TerminateDistance">
            <summary>
            If there are no free hardware voices, the Buffer to be terminated will be
            one that was loaded/created with the <see cref="F:ManagedBass.BassFlags.MuteMax"/> flag and is beyond
            it's max distance. If there are no buffers that match this criteria, then
            the "play" call will fail.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.TerminatePriority">
            <summary>
            If there are no free hardware voices,
            the Buffer to be terminated will be the one with the lowest priority.
            </summary>
        </member>
        <member name="T:ManagedBass.WaveFormatTag">
            <summary>
            Wave Format Encoding
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Extensible">
            <summary>
            Wave Format Extensible, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Unknown">
            <summary>
            Unknown, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Pcm">
            <summary>
            PCM, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Adpcm">
            <summary>
            ADPCM, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IeeeFloat">
            <summary>
            IEEE Float, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vselp">
            <summary>
            VSELP, Compaq Computer Corp.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IbmCvsd">
            <summary>
            IBM CVSD, IBM Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ALaw">
            <summary>
            ALAW, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MuLaw">
            <summary>
            MULAW, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Dts">
            <summary>
            DTS, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Drm">
            <summary>
            DRM, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WmaVoice9">
            <summary>
            WMA VOICE 9
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OkiAdpcm">
            <summary>
            OKI ADPCM, OKI
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DviAdpcm">
            <summary>
            DVI ADPCM, Intel Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ImaAdpcm">
            <summary>
            IMA ADPCM, Intel Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MediaspaceAdpcm">
            <summary>
            MEDIASPACE ADPCM, Videologic
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SierraAdpcm">
            <summary>
            SIERRA ADPCM, Sierra Semiconductor Corp
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G723Adpcm">
            <summary>
            G723 ADPCM, Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiStd">
            <summary>
            DIGISTD, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiFix">
            <summary>
            DIGIFIX, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DialogicOkiAdpcm">
            <summary>
            DIALOGIC OKI ADPCM, Dialogic Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MediaVisionAdpcm">
            <summary>
            MEDIAVISION ADPCM, Media Vision, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CUCodec">
            <summary>
            CU CODEC, Hewlett-Packard Company
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.YamahaAdpcm">
            <summary>
            YAMAHA ADPCM, Yamaha Corporation of America
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SonarC">
            <summary>
            SONARC, Speech Compression
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DspGroupTrueSpeech">
            <summary>
            DSPGROUP TRUESPEECH, DSP Group, Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.EchoSpeechCorporation1">
            <summary>
            ECHOSC1, Echo Speech Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.AudioFileAf36">
            <summary>
            AUDIOFILE AF36, Virtual Music, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Aptx">
            <summary>
            APTX, Audio Processing Technology
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.AudioFileAf10">
            <summary>
            AUDIOFILE AF10, Virtual Music, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Prosody1612">
            <summary>
            PROSODY 1612, Aculab plc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Lrc">
            <summary>
            LRC, Merging Technologies S.A.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DolbyAc2">
            <summary>
            DOLBY AC2, Dolby Laboratories
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Gsm610">
            <summary>
            GSM610, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MsnAudio">
            <summary>
            MSNAUDIO, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.AntexAdpcme">
            <summary>
            ANTEX ADPCME, Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ControlResVqlpc">
            <summary>
            CONTROL RES VQLPC, Control Resources Limited
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiReal">
            <summary>
            DIGIREAL, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiAdpcm">
            <summary>
            DIGIADPCM, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ControlResCr10">
            <summary>
            CONTROL RES CR10, Control Resources Limited
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NMS_VBXADPCM">
            <summary>
            Natural MicroSystems
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CS_IMAADPCM">
            <summary>
            Crystal Semiconductor IMA ADPCM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ECHOSC3">
            <summary>
            Echo Speech Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ROCKWELL_ADPCM">
            <summary>
            Rockwell International
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ROCKWELL_DIGITALK">
            <summary>
            Rockwell International
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.XEBEC">
            <summary>
            Xebec Multimedia Solutions Limited
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G721_ADPCM">
            <summary>
            Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G728_CELP">
            <summary>
            Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MSG723">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Mpeg">
            <summary>
            MPEG, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RT24">
            <summary>
            InSoft, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PAC">
            <summary>
            InSoft, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Mp3">
            <summary>
            MPEGLAYER3, ISO/MPEG Layer3 Format Tag
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.LUCENT_G723">
            <summary>
            Lucent Technologies
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CIRRUS">
            <summary>
            Cirrus Logic
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ESPCM">
            <summary>
            ESS Technology 
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CANOPUS_ATRAC">
            <summary>
            Canopus, co., Ltd.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G726_ADPCM">
            <summary>
            APICOM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G722_ADPCM">
            <summary>
            APICOM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DSAT_DISPLAY">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_BYTE_ALIGNED">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC8">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC10">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC16">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC20">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_RT24">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_RT29">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_RT29HW">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_VR12">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_VR18">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_TQ40">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SOFTSOUND">
            <summary>
            Softsound, Ltd.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_TQ60">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MSRT24">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G729A">
            <summary>
            AT&amp;T Labs, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MVI_MVI2">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DF_G726">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DF_GSM610">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ISIAUDIO">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ONLIVE">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SBC24">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DOLBY_AC3_SPDIF">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MEDIASONIC_G723">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PROSODY_8KBPS">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ZYXEL_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PHILIPS_LPCBB">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PACKED">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MALDEN_PHONYTALK">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Gsm">
            <summary>
            WAVE_FORMAT_GSM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G729">
            <summary>
            WAVE_FORMAT_G729
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G723">
            <summary>
            WAVE_FORMAT_G723
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Acelp">
            <summary>
            WAVE_FORMAT_ACELP
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RawAac">
            <summary>
            WAVE_FORMAT_RAW_AAC1
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RHETOREX_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IRAT">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VIVO_G723">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VIVO_SIREN">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DIGITAL_G723">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SANYO_LD_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_ACEPLNET">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_ACELP4800">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_ACELP8V3">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_G729">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_G729A">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_KELVIN">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G726ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QUALCOMM_PUREVOICE">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QUALCOMM_HALFRATE">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.TUBGSM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MSAUDIO1">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMA">
            <summary>
            Windows Media Audio, WAVE_FORMAT_WMAUDIO2, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMAProfessional">
            <summary>
            Windows Media Audio Professional WAVE_FORMAT_WMAUDIO3, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMALosseless">
            <summary>
            Windows Media Audio Lossless, WAVE_FORMAT_WMAUDIO_LOSSLESS
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMA_SPDIF">
            <summary>
            Windows Media Audio Professional over SPDIF WAVE_FORMAT_WMASPDIF (0x0164)
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_ULAW">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_ALAW">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_16K">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CREATIVE_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CREATIVE_FASTSPEECH8">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CREATIVE_FASTSPEECH10">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UHER_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QUARTERDECK">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ILINK_VC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RAW_SPORT">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ESST_AC3">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IPI_HSX">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IPI_RPELP">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CS2">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SONY_SCX">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.FM_TOWNS_SND">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.BTV_DIGITAL">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QDESIGN_MUSIC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VME_VMPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.TPC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLIGSM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLIADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLICELP">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLISBC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLIOPR">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.LH_CODEC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NORRIS">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SOUNDSPACE_MUSICOMPRESS">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_ADTS_AAC">
            <summary>
            Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format.
            The format block is a WAVEFORMATEX structure with wFormatTag equal to WAVE_FORMAT_MPEG_ADTS_AAC.
            </summary>
            <remarks>
            The WAVEFORMATEX structure specifies the core AAC-LC sample rate and number of channels, 
            prior to applying spectral band replication (SBR) or parametric stereo (PS) tools, if present.
            No additional data is required after the WAVEFORMATEX structure.
            </remarks>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_RAW_AAC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_LOAS">
            <summary>
            MPEG-4 audio transport stream with a synchronization layer (LOAS) and a multiplex layer (LATM).
            The format block is a WAVEFORMATEX structure with wFormatTag equal to WAVE_FORMAT_MPEG_LOAS.
            </summary>
            <remarks>
            The WAVEFORMATEX structure specifies the core AAC-LC sample rate and number of channels, 
            prior to applying spectral SBR or PS tools, if present.
            No additional data is required after the WAVEFORMATEX structure.
            </remarks>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NOKIA_MPEG_ADTS_AAC">
            <summary>NOKIA_MPEG_ADTS_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NOKIA_MPEG_RAW_AAC">
            <summary>NOKIA_MPEG_RAW_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VODAFONE_MPEG_ADTS_AAC">
            <summary>VODAFONE_MPEG_ADTS_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VODAFONE_MPEG_RAW_AAC">
            <summary>VODAFONE_MPEG_RAW_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_HEAAC">
            <summary>
            High-Efficiency Advanced Audio Coding (HE-AAC) stream.
            The format block is an HEAACWAVEFORMAT structure.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DVM">
            <summary>
            WAVE_FORMAT_DVM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis1">
            <summary>
            WAVE_FORMAT_VORBIS1 "Og" Original stream compatible
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis2">
            <summary>
            WAVE_FORMAT_VORBIS2 "Pg" Have independent header
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis3">
            <summary>
            WAVE_FORMAT_VORBIS3 "Qg" Have no codebook header
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis1P">
            <summary>
            WAVE_FORMAT_VORBIS1P "og" Original stream compatible
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis2P">
            <summary>
            WAVE_FORMAT_VORBIS2P "pg" Have independent headere
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis3P">
            <summary>
            WAVE_FORMAT_VORBIS3P "qg" Have no codebook header
            </summary>
        </member>
        <member name="T:ManagedBass.BassInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to retrieve information on the current device.
            </summary>
            <remarks>
            The DSCAPS_SECONDARY flags only indicate which sample formats are supported by hardware mixing.
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, it is possible for speakers to mistakenly be 2 with some devices/drivers when the device in fact supports more speakers.
            In that case, the <see cref="F:ManagedBass.DeviceInitFlags.CPSpeakers"/> flag can be used (with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>) to use the Windows control panel setting,
            or the <see cref="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment"/> flag can be used to force the enabling of speaker assignment to up to 8 speakers,
            even though the device may not really support that many speakers.
            The result of assigning channels to nonexistent speakers is undefined;
            they may be heard on other speakers or not heard at all.
            </para>
            <para>
            The flags, hwsize, hwfree, freesam, free3d, minrate, maxrate, eax, and dsver members are only used on Windows, as DirectSound and hardware mixing are only available there.
            The freq member is not available on Windows prior to Vista.
            </para>
            <para>On Windows, the availability of the latency and minbuf values depends on the <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> flag being used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </remarks>
        </member>
        <member name="P:ManagedBass.BassInfo.TotalHardwareMemory">
            <summary>
            The device's total amount of hardware memory.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.FreeHardwareMemory">
            <summary>
            The device's amount of free hardware memory.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.FreeSampleSlots">
            <summary>
            The number of free sample slots in the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Free3DSampleSlots">
            <summary>
            The number of free 3D sample slots in the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.MinSampleRate">
            <summary>
            The minimum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.MaxSampleRate">
            <summary>
            The maximum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.EAXEnabled">
            <summary>The device supports EAX and has it enabled?
            <para>The device's "Hardware acceleration" needs to be set to "Full" in it's "Advanced Properties" setup, else EAX is disabled.</para>
            <para>This is always <see langword="false" /> if <see cref="F:ManagedBass.DeviceInitFlags.Device3D"/> was not used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.MinBufferLength">
            <summary>The minimum Buffer Length (rounded up to the nearest millisecond) recommended for use with the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option.
            <para>Requires that <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> was used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.DSVersion">
            <summary>
            DirectSound version.
            <para>
            9 = DX9/8/7/5 features are available,
            8 = DX8/7/5 features are available,
            7 = DX7/5 features are available,
            5 = DX5 features are available.
            0 = none of the DX9/8/7/5 features are available.
            </para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Latency">
            <summary>The delay (rounded up to the nearest millisecond) for playback of HSTREAM/HMUSIC channels to start and be heard.
            <para>Requires that <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> was used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.InitFlags">
            <summary>
            The flags parameter of the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call (<see cref="T:ManagedBass.DeviceInitFlags" />).
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SpeakerCount">
            <summary>The number of speakers the device/drivers supports... 2 means that there is no support for speaker assignment - this will always be the case with non-WDM drivers in Windows.
            <para>It's also possible that it could mistakenly be 2 with some devices/drivers, when the device in fact supports more speakers.</para>
            <para>In that case the <see cref="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment"/> or <see cref="F:ManagedBass.DeviceInitFlags.CPSpeakers"/> flag can be used in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call to force the enabling of speaker assignment.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SampleRate">
            <summary>
            The device's current output sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Supports16BitSamples">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Supports8BitSamples">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsContinuousRate">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsMonoSamples">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsStereoSamples">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:ManagedBass.ChannelInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on a channel.
            </summary>
            <remarks>
            A "channel" can be a playing sample (HCHANNEL), a sample stream (HSTREAM), a MOD music (HMUSIC), or a recording (HRECORD).
            <para>Each "Channel" function can be used with one or more of these channel types.</para>
            <para>
            The BassFlags.SoftwareMixing flag indicates whether or not the channel's sample data is being mixed into the final output by the hardware.
            It does not indicate (in the case of a stream or MOD music) whether the processing required to generate the sample data is being done by the hardware, this processing is always done in software.
            </para>
            <para>
            BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            The <see cref="P:ManagedBass.ChannelInfo.OriginalResolution"/> member can be used to check what the resolution originally was.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Frequency">
            <summary>
            Default playback rate.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Channels">
            <summary>
            Number of channels... 1=mono, 2=stereo, etc.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Flags">
            <summary>
            Sample/Stream/Music/Speaker flags.
            A combination of <see cref="T:ManagedBass.BassFlags"/>.
            </summary>
            <remarks><b>Platform-specific</b>
            <para>
            On Linux/iOS/OSX, the <see cref="F:ManagedBass.BassFlags.Unicode"/> flag may not be present even if it was used in the stream's creation, as BASS will have translated the filename to the native UTF-8 form.
            On Windows CE, the opposite is true: the <see cref="F:ManagedBass.BassFlags.Unicode"/> flag may be present even if it was not used in the stream's creation, as BASS will have translated the filename to the native UTF-16 form.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.ChannelInfo.ChannelType">
            <summary>
            The Type of Channel
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Plugin">
            <summary>
            The plugin that is handling the channel... 0 = not using a plugin.
            <para>
            Note this is only available with streams created using the plugin system via the standard BASS stream creation functions, not those created by add-on functions.
            Information on the plugin can be retrieved via <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" />.
            </para>
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Sample">
            <summary>
            The sample that is playing on the channel. (HCHANNEL only)
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Resolution">
            <summary>
            The resolution which Bass uses for the stream.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.OriginalResolution">
            <summary>
            The original resolution (bits per sample)... 0 = undefined.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.FileName">
            <summary>
            The filename associated with the channel. (HSTREAM only)
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.IsDecodingChannel">
            <summary>
            Is the channel a decoding channel?
            </summary>
        </member>
        <member name="T:ManagedBass.DeviceInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> or <see cref="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> to retrieve information on a device.
            </summary>
            <remarks>
            <para>
            When a device is disabled/disconnected, it is still retained in the device list, but the IsEnabled is set to <see langword="false" /> flag is removed from it.
            If the device is subsequently re-enabled, it may become available again with the same device number, or the system may add a new entry for it.
            </para>
            <para>
            When a new device is connected, it can affect the other devices and result in the system moving them to new device entries.
            If an affected device is initialized, it will stop working and will need to be reinitialized using its new device number.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, <see cref="P:ManagedBass.DeviceInfo.Driver"/> can reveal the Type of driver being used on systems that support both VxD and WDM drivers (Windows Me/98SE).
            Further information can be obtained from the file via the GetFileVersionInfo function.
            On Vista and newer, the device's endpoint ID is given rather than its driver filename.
            On OSX, driver is the device's UID, and on Linux it is the ALSA device name.
            It is unused on other platforms.
            The device Type is only available on Windows (Vista and newer) and OSX.
            On Windows, DisplayPort devices will have <see cref="F:ManagedBass.DeviceType.HDMI"/> rather than <see cref="F:ManagedBass.DeviceType.DisplayPort"/>.
            </para>
            <para>
            Depending on the Bass.UnicodeDeviceInformation config setting, <see cref="P:ManagedBass.DeviceInfo.Name"/> and <see cref="P:ManagedBass.DeviceInfo.Driver"/> can be in ANSI or UTF-8 form on Windows.
            They are always in UTF-16 form on Windows CE, and UTF-8 on other platforms.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.DeviceInfo.Name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.Driver">
            <summary>
            The filename of the driver being used... <see langword="null" /> = no driver (ie. <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device).
            <para>On systems that can use both VxD and WDM drivers (Windows Me/98SE), this will reveal which Type of driver is being used.</para>
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.IsDefault">
            <summary>
            The device is the system default device.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.IsEnabled">
            <summary>
            The device is enabled and can be used.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.IsInitialized">
            <summary>
            The device is already initialized.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.Type">
            <summary>
            The device's Type.
            </summary>
        </member>
        <member name="T:ManagedBass.FileProcedures">
            <summary>
            Table of callback functions used with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </summary>
            <remarks>
            A copy is made of the <see cref="T:ManagedBass.FileProcedures"/> callback function table, so it does not have to persist beyond this function call.
            Unlike Bass.Net, a reference to <see cref="T:ManagedBass.FileProcedures"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </remarks>
        </member>
        <member name="F:ManagedBass.FileProcedures.Close">
            <summary>
            Callback function to close the file.
            </summary>
        </member>
        <member name="F:ManagedBass.FileProcedures.Length">
            <summary>
            Callback function to get the file Length.
            </summary>
        </member>
        <member name="F:ManagedBass.FileProcedures.Read">
            <summary>
            Callback function to read from the file.
            </summary>
        </member>
        <member name="F:ManagedBass.FileProcedures.Seek">
            <summary>
            Callback function to seek in the file. Not used by buffered file streams.
            </summary>
        </member>
        <member name="T:ManagedBass.PluginFormat">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" /> to retrieve information on the supported plugin formats.
            </summary>
            <remarks>
            The plugin information does not change, so the returned pointer remains valid for as long as the plugin is loaded.
            <para>
            The extension filter is for information only.
            A plugin will check the file contents rather than file extension, to verify that it is a supported format.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.PluginFormat.ChannelType">
            <summary>
            The channel Type, as would appear in the <see cref="T:ManagedBass.ChannelInfo" /> structure.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginFormat.Name">
            <summary>
            The Format description or name.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginFormat.FileExtensions">
            <summary>
            File extension filter, in the form of "*.ext1;*.ext2;etc...".
            </summary>
            <remarks>
            The extension filter is for information only.
            A plugin will check the file contents rather than file extension, to verify that it is a supported format.
            </remarks>
        </member>
        <member name="T:ManagedBass.PluginInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" /> to retrieve information on a plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginInfo.Version">
            <summary>
            Plugin version.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginInfo.Formats">
            <summary>
            The collection of supported formats.
            </summary>
            <remarks>
            Note: There is no guarantee that the list of supported formats is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).
            </remarks>
        </member>
        <member name="T:ManagedBass.RecordInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.RecordGetInfo(ManagedBass.RecordInfo@)" /> to retrieve information on the current recording device.
            </summary>
            <remarks>
            <para>The <see cref="P:ManagedBass.RecordInfo.SupportedFormats"/> member does not represent all the formats supported by the device, just the "standard" ones.</para>
            <para>If there is no DirectSound driver for the device (ie. it's being emulated), then the driver member will contain something like "WaveIn" instead of a filename.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="P:ManagedBass.RecordInfo.IsCertified"/> and <see cref="P:ManagedBass.RecordInfo.SupportsDirectSound"/> members are only used on Windows.
            The <see cref="P:ManagedBass.RecordInfo.SupportedFormats"/> member is only used on Windows/OSX/iOS, and only for the device's channel count in the case of OSX and iOS.
            On Windows, it does not necessarily represent all of the formats supported by the device, just the "standard" ones.
            <see cref="P:ManagedBass.RecordInfo.Frequency"/> is also only available on Windows/OSX/iOS, but not on Windows prior to Vista.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.RecordInfo.SupportedFormats">
            <summary>
            The standard wave formats supported by the device (default is <see cref="F:ManagedBass.RecordFormatFlags.WF4S16"/>).
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.Inputs">
            <summary>
            The number of Input sources available to the device
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.SingleInput">
            <summary>
            <see langword="true" /> = only one Input may be active at a time
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.Frequency">
            <summary>
            The device's current Input sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.Channels">
            <summary>
            Gets the available channel count for a recording Input.
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="T:ManagedBass.SampleInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" /> and <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" /> to retrieve and set the default playback attributes of a sample.
            </summary>
            <remarks>
            <para>
            When a sample has 3D functionality, the <see cref="F:ManagedBass.SampleInfo.InsideAngle"/> and <see cref="F:ManagedBass.SampleInfo.OutsideAngle"/> angles decide how wide the sound is projected around the orientation angle (as set via <see cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)" />).
            Within the inside angle the volume level is the level set in the volume member (or the <see cref="F:ManagedBass.ChannelAttribute.Volume" /> attribute when the sample is playing).
            Outside the outer angle, the volume changes according to the outvol value.
            Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels.
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.
            </para>
            <para>When VAM is enabled, and neither the <see cref="F:ManagedBass.VAMMode.Hardware"/> or <see cref="F:ManagedBass.VAMMode.Software"/> flags are specified, then the sample will be played in hardware if resources are available, and in software if no hardware resources are available.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.SampleInfo.Frequency">
            <summary>
            Default playback rate (set to 44100 by default).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Volume">
            <summary>
            Default volume... 0 (silent) to 1 (full, default).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Pan">
            <summary>
            Default panning position -1 (full left) to +1 (full right) - defaulted to 0 = centre.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Flags">
            <summary>
            A combination of <see cref="T:ManagedBass.BassFlags"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Length">
            <summary>
            The Length in bytes.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Max">
            <summary>
            Maximum number of simultaneous playbacks (defaulted to 1).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.OriginalResolution">
            <summary>
            The original resolution (bits per sample)... 0 = undefined (default).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Channels">
            <summary>
            Number of channels... 1=mono, 2=stereo (default), etc.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.MinGap">
            <summary>
            Minimum time gap in milliseconds between creating channels using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />.
            This can be used to prevent flanging effects caused by playing a sample multiple times very close to eachother.
            The default setting, when loading/creating a sample, is 0 (disabled).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Mode3D">
            <summary>
            The 3D processing mode...
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.MinDistance">
            <summary>
            The minimum distance (default 0). The sample's volume is at maximum when the listener is within this distance.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.MaxDistance">
            <summary>
            The maximum distance (default 0). The sample's volume stops decreasing when the listener is beyond this distance.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.InsideAngle">
            <summary>
            The angle of the inside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.OutsideAngle">
            <summary>
            The angle of the outside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.OutsideVolume">
            <summary>
            The delta-volume outside the outer projection cone... 0 (silent) to 1 (full, default) - same as inside the cone.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.VAM">
            <summary>
            The sample's DX7 voice allocation/management settings (if VAM is enabled)...a combination of <see cref="T:ManagedBass.VAMMode" /> flags.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Priority">
            <summary>
            Priority, used with the <see cref="F:ManagedBass.VAMMode.TerminatePriority"/> flag... 0 (min, default) - 0xFFFFFFFF (max)
            </summary>
        </member>
        <member name="T:ManagedBass.Vector3D">
            <summary>
            Structure used by the 3D functions to describe positions, velocities, and orientations in the left-handed coordinate system.
            </summary>
        </member>
        <member name="F:ManagedBass.Vector3D.X">
            <summary>
            +values=right, -values=left (default=0)
            </summary>
        </member>
        <member name="F:ManagedBass.Vector3D.Y">
            <summary>
            +values=up, -values=down (default=0)
            </summary>
        </member>
        <member name="F:ManagedBass.Vector3D.Z">
            <summary>
            +values=front, -values=behind (default=0)
            </summary>
        </member>
        <member name="M:ManagedBass.Vector3D.#ctor">
            <summary>
            Creates a new instance of <see cref="T:ManagedBass.Vector3D"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.Vector3D.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new instance of Vector3D and initialises members.
            </summary>
        </member>
        <member name="M:ManagedBass.Vector3D.ToString">
            <summary>
            Returns a string representation of this Vector.
            </summary>
        </member>
        <member name="T:ManagedBass.BitHelper">
            <summary>
            Helps perform certain operations on primative types that deal with bits
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.HiDword(System.Int64)">
            <summary>
            The return value is the high-order double word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.LoDword(System.Int64)">
            <summary>
            The return value is the low-order word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.HiWord(System.Int32)">
            <summary>
            The return value is the high-order word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.LoWord(System.Int32)">
            <summary>
            The return value is the low-order word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.HiByte(System.Int16)">
            <summary>
            The return value is the high-order byte of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.LoByte(System.Int16)">
            <summary>
            The return value is the low-order byte of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.MakeWord(System.Byte,System.Byte)">
            <summary>
            Make an short from 2-bytes.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.MakeLong(System.Int16,System.Int16)">
            <summary>
            Make an integer putting <paramref name="low"/> in low 2-bytes and <paramref name="high"/> in high 2-bytes.
            </summary>
        </member>
        <member name="T:ManagedBass.Errors">
            <summary>
            Bass Error Codes returned by <see cref="P:ManagedBass.Bass.LastError" /> and BassAsio.LastError.
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Unknown">
            <summary>
            Some other mystery error
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.OK">
            <summary>
            No Error
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Memory">
            <summary>
            Memory Error
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.FileOpen">
            <summary>
            Can't open the file
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Driver">
            <summary>
            Can't find a free/valid driver
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.BufferLost">
            <summary>
            The sample Buffer was lost
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Handle">
            <summary>
            Invalid Handle
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.SampleFormat">
            <summary>
            Unsupported sample format
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Position">
            <summary>
            Invalid playback position
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Init">
            <summary>
            <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Start">
            <summary>
            <see cref="M:ManagedBass.Bass.Start"/> has not been successfully called
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.SLL">
            <summary>
            SSL/HTTPS support isn't available.
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoCD">
            <summary>
            No CD in drive
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.CDTrack">
            <summary>
            Invalid track number
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Already">
            <summary>
            Already initialized/paused/whatever
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotPaused">
            <summary>
            Not paused
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotAudioTrack">
            <summary>
            Not an audio track
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoChannel">
            <summary>
            Can't get a free channel
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Type">
            <summary>
            An illegal Type was specified
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Parameter">
            <summary>
            An illegal parameter was specified
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.No3D">
            <summary>
            No 3D support
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoEAX">
            <summary>
            No EAX support
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Device">
            <summary>
            Illegal device number
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotPlaying">
            <summary>
            Not playing
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.SampleRate">
            <summary>
            Illegal sample rate
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotFile">
            <summary>
            The stream is not a file stream
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoHW">
            <summary>
            No hardware voices available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Empty">
            <summary>
            The MOD music has no sequence data
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoInternet">
            <summary>
            No internet connection could be opened
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Create">
            <summary>
            Couldn't create the file
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoFX">
            <summary>
            Effects are not available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Playing">
            <summary>
            The channel is playing
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotAvailable">
            <summary>
            Requested data is not available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Decode">
            <summary>
            The channel is a 'Decoding Channel'
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.DirectX">
            <summary>
            A sufficient DirectX version is not installed
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Timeout">
            <summary>
            Connection timedout
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.FileFormat">
            <summary>
            Unsupported file format
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Speaker">
            <summary>
            Unavailable speaker
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Version">
            <summary>
            Invalid BASS version (used by add-ons)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Codec">
            <summary>
            Codec is not available/supported
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Ended">
            <summary>
            The channel/file has ended
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Busy">
            <summary>
            The device is busy (eg. in "exclusive" use by another process)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.WmaLicense">
            <summary>
            BassWma: The file is protected
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.WM9">
            <summary>
            BassWma: WM9 is required
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.WmaAccesDenied">
            <summary>
            BassWma: Access denied (Username/Password is invalid)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.WmaCodec">
            <summary>
            BassWma: No appropriate codec is installed
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.WmaIndividual">
            <summary>
            BassWma: individualization is needed
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Wasapi">
            <summary>
            BassWASAPI: WASAPI Not available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.AcmCancel">
            <summary>
            BassEnc: ACM codec selection cancelled
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.CastDenied">
            <summary>
            BassEnc: Access denied (invalid password)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Mp4NoStream">
            <summary>
            BassAAC: Non-Streamable due to MP4 atom order ("mdat" before "moov")
            </summary>
        </member>
        <member name="T:ManagedBass.Extensions">
            <summary>
            Contains Helper and Extension methods.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.Clip``1(``0,``0,``0)">
            <summary>
            Clips a value between a Minimum and a Maximum.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.Is``1(``0,``0[])">
            <summary>
            Checks for equality of an item with any element of an array of items.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ToBassFlag(ManagedBass.Resolution)">
            <summary>
            Converts <see cref="T:ManagedBass.Resolution"/> to <see cref="T:ManagedBass.BassFlags"/>
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.SpeakerN(System.Int32)">
            <summary>
            Returns the <param name="N">n'th (max 15)</param> pair of Speaker Assignment Flags
            </summary>
        </member>
        <member name="P:ManagedBass.Extensions.SupportsFloatingPoint">
            <summary>
            Check whether Floating point streams are supported in the Current Environment.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ChannelCountToString(System.Int32)">
            <summary>
            Returns a string representation for given number of channels.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ExtractMultiStringAnsi(System.IntPtr)">
            <summary>
            Extract an array of strings from a pointer to ANSI null-terminated string ending with a double null.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ExtractMultiStringUtf8(System.IntPtr)">
            <summary>
            Extract an array of strings from a pointer to UTF-8 null-terminated string ending with a double null.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.PtrToStringUtf8(System.IntPtr)">
            <summary>
            Returns a Unicode string from a pointer to a Utf-8 string.
            </summary>
        </member>
        <member name="T:ManagedBass.IEffectParameter">
            <summary>
            Parameters for an Effect.
            </summary>
        </member>
        <member name="P:ManagedBass.IEffectParameter.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Plugin">
            <summary>
            Wraps Plugins AddOns.
            </summary>
        </member>
        <member name="P:ManagedBass.Plugin.DllName">
            <summary>
            FileName of the Plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.Plugin.Version">
            <summary>
            Gets the Version of the Plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.Plugin.SupportedFormats">
            <summary>
            Gets the Formats supported by the Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Plugin.Load(System.String)">
            <summary>
            Load the plugin into memory.
            <param name="Folder">Folder to load the plugin from... <see langword="null"/> (default), Load from Current Directory.</param>
            </summary>
        </member>
        <member name="M:ManagedBass.Plugin.Unload">
            <summary>
            Unloads the Plugin from Memory
            </summary>
        </member>
        <member name="T:ManagedBass.Resolution">
            <summary>
            Bits per Sample of a Channel
            </summary>
        </member>
        <member name="F:ManagedBass.Resolution.Short">
            <summary>
            16-Bit PCM (Default)
            </summary>
        </member>
        <member name="F:ManagedBass.Resolution.Byte">
            <summary>
            8-Bit PCM
            </summary>
        </member>
        <member name="F:ManagedBass.Resolution.Float">
            <summary>
            32-Bit IEEE Floating Point
            </summary>
        </member>
        <member name="T:ManagedBass.Tags.BextTag">
            <summary>
            BWF BEXT block tag structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.Description">
            <summary>
            The description or title (Max 256 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.Originator">
            <summary>
            The name of the originator or artist (Max 32 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.OriginatorReference">
            <summary>
            The reference of the originator or encoded by (Max 32 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.OriginationDate">
            <summary>
            The date of creation (Max 10 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.OriginationTime">
            <summary>
            The time of creation (max. 10 characters).
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.BextTag.OriginationDateTime">
            <summary>
            The Date and Time of creation.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.TimeReference">
            <summary>
            First sample count since midnight (little-endian).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.Version">
            <summary>
            The BWF version (little-endian)
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.UMID">
            <summary>
            The SMPTE UMID.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.BextTag.CodingHistory">
            <summary>
            Coding history.
            </summary>
        </member>
        <member name="M:ManagedBass.Tags.BextTag.Read(System.Int32)">
            <summary>
            Reads the tag from a channel.
            </summary>
            <param name="Channel">The Channel to read the tag from.</param>
        </member>
        <member name="T:ManagedBass.Tags.CartTimer">
            <summary>
            BWF CART Timer structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTimer.Usage">
            <summary>
            Usage
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTimer.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="T:ManagedBass.Tags.CartTag">
            <summary>
            BWF CART block tag structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Version">
            <summary>
            Version of the data structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Title">
            <summary>
            Title of cart audio sequence (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Artist">
            <summary>
            Artist or Creator name (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.CutID">
            <summary>
            Cut Number Identification (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.ClientID">
            <summary>
            Client Identification (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Category">
            <summary>
            Category ID (e.g. PSA, NEWS, etc | Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Classification">
            <summary>
            Classification or Auxiliary Key (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.OutCue">
            <summary>
            Out Cue Text (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.ProducerAppID">
            <summary>
            Name of vendor or application (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.ProducerAppVersion">
            <summary>
            Version of producer application (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.UserDef">
            <summary>
            User defined text (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.dwLevelReference">
            <summary>
            Sample value for 0 dB reference.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.PostTimer">
            <summary>
            8 time markers after head.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.URL">
            <summary>
            Uniform resource locator.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.CartTag.TagText">
            <summary>
            Free form text for scripts or tags.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.CartTag.StartTime">
            <summary>
            Start time.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.CartTag.EndTime">
            <summary>
            End time.
            </summary>
        </member>
        <member name="M:ManagedBass.Tags.CartTag.Read(System.Int32)">
            <summary>
            Read the tag from a Channel.
            </summary>
        </member>
        <member name="T:ManagedBass.Tags.ID3v1Tag">
            <summary>
            Wraps an ID3v1 tag
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Title">
            <summary>
            Returns the Title (Max 30 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Artist">
            <summary>
            Returns the Artist (Max 30 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Album">
            <summary>
            Returns the Album (Max 30 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Year">
            <summary>
            Returns the Year.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.genre">
            <summary>
            Genre ID.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Genres">
            <summary>
            An array of Genres arranged by ID.
            </summary>
        </member>
        <member name="M:ManagedBass.Tags.ID3v1Tag.Read(System.Int32)">
            <summary>
            Reads an <see cref="T:ManagedBass.Tags.ID3v1Tag"/>.
            </summary>
            <param name="Channel">The Channel to read from.</param>
        </member>
        <member name="P:ManagedBass.Tags.ID3v1Tag.Comment">
            <summary>
            Gets the Comment.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.ID3v1Tag.Genre">
            <summary>
            Gets the Genre.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.ID3v1Tag.TrackNo">
            <summary>
            Gets the Track Number.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.BassCd">
            <summary>
            Wraps basscd.dll.
            </summary>
            <remarks>
            <para>Supports: .cda</para>
            <para>Not available on OSX</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Cd.BassCd.TrackPregap">
            <summary>
            Track Pregap constant
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.BassCd.Plugin">
            <summary>
            Gets the <see cref="F:ManagedBass.Cd.BassCd.Plugin"/> instance for <see cref="T:ManagedBass.Cd.BassCd"/>.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.BassCd.DriveCount">
            <summary>
            Gets the number of CD Drives available.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.BassCd.FreeOld">
            <summary>
            Automatically free an existing stream when creating a new one on the same drive? (enabled by Default)
            </summary>
            <remarks>
            Only one stream can exist at a time per CD drive. 
            So if a stream using the same drive already exists, stream creation function calls
            will fail, unless this config option is enabled to automatically free the existing stream.
            </remarks>
        </member>
        <member name="P:ManagedBass.Cd.BassCd.RetryCount">
            <summary>
            Number of times to retry after a read error... 0 = don't retry, default = 2.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.BassCd.AutoSpeedReduction">
            <summary>
            Automatically reduce the read speed when a read error occurs? (default is disabled).
            If true, the read speed will be halved when a read error occurs, before retrying (if the <see cref="P:ManagedBass.Cd.BassCd.RetryCount"/> setting allows).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.BassCd.SkipError">
            <summary>
            Skip past read errors?
            If true, reading will skip onto the next frame when a read error occurs, otherwise reading will stop.
            When skipping an error, it will be replaced with silence, so that the track Length is unaffected. 
            Before skipping past an error, BassCd will first retry according to the <see cref="P:ManagedBass.Cd.BassCd.RetryCount"/> setting.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.BassCd.CDDBServer">
            <summary>
            The server address to use in CDDB requests, in the form of "User:pass@server:port/path" (default = "freedb.freedb.org").
            </summary>
            <remarks>
            The "User:pass@", ":port" and "/path" parts are optional; only the "server" part is required.
            If not provided, the port and path default to 80 and "/~cddb/cddb.cgi", respectively.
            The proxy server, as configured via the <see cref="P:ManagedBass.Bass.NetProxy"/> option, is used when connecting to the CDDB server.
            </remarks>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.Release(System.Int32)">
            <summary>
            Releases a drive to allow other applications to access it.
            </summary>
            <param name="Drive">The drive to release... 0 = the first drive.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            When using the SPTI interface, some applications may require BassCd to release a CD drive before the app is able to use it.
            After a drive has been released, BassCd will attempt to re-acquire it in the next BassCd function call made on it.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The ASPI interface is being used.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetSpeed(System.Int32)">
            <summary>
            Retrieves the current read speed setting of a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>If successful, the read speed (in KB/s) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>Divide the speed by 176.4 to get the real-time speed multiplier, eg. 5645 / 176.4 = "32x speed".</remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The read speed is unavailable.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetSpeedMultiplier(System.Int32)">
            <summary>
            Retrieves the current read speed multiplier of a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>If successful, the read speed multiplier is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The read speed is unavailable.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.SetSpeed(System.Int32,System.Int32)">
            <summary>
            Sets the read speed of a drive in KB/s.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Speed">The speed, in KB/s.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The speed is automatically restricted (rounded down) to what's supported by the drive, so may not be exactly what was requested.
            <see cref="M:ManagedBass.Cd.BassCd.GetSpeed(System.Int32)" /> can be used to check that. 
            The maximum supported speed can be retrieved via <see cref="M:ManagedBass.Cd.BassCd.GetInfo(System.Int32,ManagedBass.Cd.CDInfo@)" />.
            </para>
            <para>To use a real-time speed multiplier, multiply it by 176.4 (and round up) to get the KB/s speed to use with this function, eg. "32x speed" = 32 * 176.4 = 5645.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.IsReady(System.Int32)">
            <summary>
            Checks if there is a CD ready in a drive.
            </summary>
            <param name="Drive">The drive to check... 0 = the first drive.</param>
            <returns>If there is a CD ready in the drive, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>This function only returns <see langword="true" /> once there's a CD in the drive, and it's ready to be accessed.</remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetInfo(System.Int32,ManagedBass.Cd.CDInfo@)">
            <summary>
            Retrieves information on a drive.
            </summary>
            <param name="Drive">The drive to get info on... 0 = the first drive.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Cd.CDInfo" /> structure to store the information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetInfo(System.Int32)">
            <summary>
            Retrieves information on a drive.
            </summary>
            <param name="Drive">The drive to get info on... 0 = the first drive.</param>
            <returns>An instance of the <see cref="T:ManagedBass.Cd.CDInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an audio CD track.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Track">The track... 0 = the first track, <see cref="F:ManagedBass.Cd.BassCd.TrackPregap"/> = 1st track pregap (not all drives support reading of the 1st track pregap).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/></param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Only one stream can exist at a time per CD drive.
            If a stream using the drive already exists, this function will fail, unless the <see cref="P:ManagedBass.Cd.BassCd.FreeOld"/> config option is enabled. 
            Note that <see cref="M:ManagedBass.Cd.BassCd.StreamSetTrack(System.Int32,System.Int32)" /> can be used to change track without creating a new stream.
            </para>
            <para>
            The sample format of a CD audio stream is always 44100hz stereo 16-bit, unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, in which case it's converted to 32-bit.
            When reading sub-channel data, the sample rate will be 45900hz, taking the additional sub-channel data into account.
            </para>
            <para>
            When reading sub-channel data, BASSCD will automatically de-interleave the data if the drive can't.
            You can check whether the drive can de-interleave the data itself (or even read sub-channel data at all) in the the <see cref="P:ManagedBass.Cd.CDInfo.ReadWriteFlags"/> member.
            </para>
            <para>
            When using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag, it's not possible to play the stream, but seeking is still possible.
            Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">A stream using this drive already exists.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <see cref="F:ManagedBass.BassFlags.CDSubChannel"/> and <see cref="F:ManagedBass.BassFlags.CdC2Errors"/> flags cannot be used without the <see cref="F:ManagedBass.BassFlags.Decode"/> flag or with the <see cref="F:ManagedBass.BassFlags.Float"/> flag. See <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)" />.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.CDTrack"><paramref name="Track" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Reading sub-channel data and/or C2 error info is not supported by the drive, or a read offset is in effect. In case of the latter, see <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)" />.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point channels are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)">
            <summary>
            Creates a sample stream from an audio CD track, optionally providing a callback function to receive sub-channel data and/or C2 error info.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Track">The track... 0 = the first track, <see cref="F:ManagedBass.Cd.BassCd.TrackPregap"/> = 1st track pregap (not all drives support reading of the 1st track pregap).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedure">A callback function to receive sub-channel data and C2 error info... <see langword="null" /> = no callback. If a callback function is provided, sub-channel data and C2 error info will be delivered to it rather than being inserted amongst the sample data.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags)" />, but with the additional option of providing a callback function to receive sub-channel data and C2 error info.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">A stream using this drive already exists.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <see cref="F:ManagedBass.BassFlags.CDSubChannel"/> and <see cref="F:ManagedBass.BassFlags.CdC2Errors"/> flags cannot be used without the <see cref="F:ManagedBass.BassFlags.Decode"/> flag or with the <see cref="F:ManagedBass.BassFlags.Float"/> flag, unless a <see cref="T:ManagedBass.Cd.CDDataProcedure" /> is provided.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.CDTrack"><paramref name="Track" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Reading sub-channel data and/or C2 error info is not supported by the drive, or a read offset is in effect, in which case a , in which case a <see cref="T:ManagedBass.Cd.CDDataProcedure" /> must be provided to receive sub-channel data or C2 error info.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point channels are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an audio CD track, using a CDA file on the CD.
            </summary>
            <param name="File">The CDA filename... for example, "D:\Track01.cda".</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Only one stream can exist at a time per CD drive.
            If a stream using the drive already exists, this function will fail, unless the <see cref="P:ManagedBass.Cd.BassCd.FreeOld"/> config option is enabled. 
            Note that <see cref="M:ManagedBass.Cd.BassCd.StreamSetTrack(System.Int32,System.Int32)" /> can be used to change track without creating a new stream.
            </para>
            <para>
            The sample format of a CD audio stream is always 44100hz stereo 16-bit, unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, in which case it's converted to 32-bit.
            When reading sub-channel data, the sample rate will be 45900hz, taking the additional sub-channel data into account.
            </para>
            <para>
            When reading sub-channel data, BASSCD will automatically de-interleave the data if the drive can't.
            You can check whether the drive can de-interleave the data itself (or even read sub-channel data at all) in the the <see cref="P:ManagedBass.Cd.CDInfo.ReadWriteFlags"/> member.
            </para>
            <para>
            When using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag, it's not possible to play the stream, but seeking is still possible.
            Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Already">A stream using this drive already exists.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file was not recognised as a CDA file.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <see cref="F:ManagedBass.BassFlags.CDSubChannel"/> and <see cref="F:ManagedBass.BassFlags.CdC2Errors"/> flags cannot be used without the <see cref="F:ManagedBass.BassFlags.Decode"/> flag or with the <see cref="F:ManagedBass.BassFlags.Float"/> flag. See <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)" />.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Reading sub-channel data and/or C2 error info is not supported by the drive, or a read offset is in effect. In case of the latter, see <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)" />.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point channels are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)">
            <summary>
            Creates a sample stream from an audio CD track, using a CDA file on the CD, optionally providing a callback function to receive sub-channel data and/or C2 error info.
            </summary>
            <param name="File">The CDA filename... for example, "D:\Track01.cda".</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedure">A callback function to receive sub-channel data and C2 error info... <see langword="null" /> = no callback. If a callback function is provided, sub-channel data and C2 error info will be delivered to it rather than being inserted amongst the sample data.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags)" />, but with the additional option of providing a callback function to receive sub-channel data and C2 error info.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Already">A stream using this drive already exists.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file was not recognised as a CDA file.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <see cref="F:ManagedBass.BassFlags.CDSubChannel"/> and <see cref="F:ManagedBass.BassFlags.CdC2Errors"/> flags cannot be used without the <see cref="F:ManagedBass.BassFlags.Decode"/> flag or with the <see cref="F:ManagedBass.BassFlags.Float"/> flag, unless a <see cref="T:ManagedBass.Cd.CDDataProcedure" /> is provided.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Reading sub-channel data and/or C2 error info is not supported by the drive, or a read offset is in effect, in which case a <see cref="T:ManagedBass.Cd.CDDataProcedure" /> must be provided to receive sub-channel data or C2 error info.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point channels are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.StreamGetTrack(System.Int32)">
            <summary>
            Retrieves the drive and track number of a CD stream.
            </summary>
            <param name="Handle">The CD stream handle.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            If successful, the track number is returned in the low word (low 16-bits), and the drive is returned in the high word (high 16-bits).
            </returns>
            <remarks>
            If the track has just changed, this function will give the new track number even if the old track is still being heard due to buffering.
            The <see cref="F:ManagedBass.PositionFlags.CDTrack"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> to get the track currently being heard.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.StreamSetTrack(System.Int32,System.Int32)">
            <summary>
            Changes the track of a CD stream.
            </summary>
            <param name="Handle">The CD stream handle.</param>
            <param name="Track">The new track... 0 = the first track, <see cref="F:ManagedBass.Cd.BassCd.TrackPregap"/> = 1st track pregap (not all drives support reading of the 1st track pregap).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The stream's current position is set to the start of the new track.
            <para>
            This function is identical to using the <see cref="F:ManagedBass.PositionFlags.CDTrack"/> mode with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />.
            Either can be used with a <see cref="F:ManagedBass.SyncFlags.End"/> sync (set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />) to play one track after another.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.CDTrack"><paramref name="Track" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.Door(System.Int32,ManagedBass.Cd.CDDoorAction)">
            <summary>
            Opens, closes, locks or unlocks a drive door.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Action">The action to perform... one of <see cref="T:ManagedBass.Cd.CDDoorAction"/>.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Action" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem! Could be that the door is locked.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.DoorIsLocked(System.Int32)">
            <summary>
            Checks if a drive door/tray is locked.
            </summary>
            <param name="Drive">The drive to check... 0 = the first drive.</param>
            <returns><see langword="true" /> is returned if the door is locked, else <see langword="false" /> is returned.</returns>
            <remarks>
            It is not possible to get the drive's current door status via the WIO interface. 
            So the last known status will be returned in that case, which may not be accurate if the door has been opened or closed by another application.
            </remarks>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.DoorIsOpen(System.Int32)">
            <summary>
            Checks if a drive door/tray is open.
            </summary>
            <param name="Drive">The drive to check... 0 = the first drive.</param>
            <returns><see langword="true" /> is returned if the door is open, else <see langword="false" /> is returned.</returns>
            <remarks>
            It is not possible to get the drive's current door status via the WIO interface. 
            So the last known status will be returned in that case, which may not be accurate if the door has been opened or closed by another application, or manually.
            </remarks>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.SetInterface(ManagedBass.Cd.CDInterface)">
            <summary>
            Sets the interface to use to access CD drives
            </summary>
            <param name="iface">The interface to use, which can be one of the <see cref="T:ManagedBass.Cd.CDInterface"/> values.</param>
            <returns>If successful, the interface being used is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The interface can be changed at any time, but any existing CD streams will be freed in doing so. 
            The current interface can also be reinitialized, to detect any newly connected drives.
            <para>Use of this function is optional. If it is not used, BassCd will automatically detect an available interface.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="iface" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The interface is not available, or has no drives available.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.SetOffset(System.Int32,System.Int32)">
            <summary>
            Sets the read offset of a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Offset">The offset (in samples; bytes/4) to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function can be used to compensate for the fact that most drives will read audio data from CDs at a slight offset from where they ideally should.
            Different drive models will have differing offsets.
            <para>
            When a negative offset is used, reading the beginning of the first track will require accessing the lead-in, and when a positive offset is used, reading the end of the last track will require accessing the lead-out.
            The drive may not support that (overreading), in which case those parts will be replaced with silence.
            </para>
            <para>Changes do not affect an existing CD stream, unless <see cref="M:ManagedBass.Cd.BassCd.StreamSetTrack(System.Int32,System.Int32)" /> is called (and any sub-channel/C2 reading is using a <see cref="T:ManagedBass.Cd.CDDataProcedure" />).</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetID(System.Int32,ManagedBass.Cd.CDID)">
            <summary>
            Retrieves identification info from the CD in a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="ID">The identification to retrieve. For <see cref="F:ManagedBass.Cd.CDID.Text"/> use <see cref="M:ManagedBass.Cd.BassCd.GetIDText(System.Int32)"/>.</param>
            <returns>The identication info on success, else<see langword="null" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="ID" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The CD does not have a UPC, ISRC or CD-TEXT info, or the CDDB Read entry number is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetIDText(System.Int32)">
            <summary>
            Retrieves CD-Text identification info from the CD in a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>
            If an error occurs, <see langword="null" /> is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            If successful, a string array of all CD-Text tags is returned in the form of "tag=text".
            </returns>
            <remarks>
            The returned identification string will remain in memory until the next call to this function, when it'll be overwritten by the next result.
            If you need to keep the contents of an identification string, then you should copy it before calling this function again.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The CD does not have a UPC, ISRC or CD-TEXT info.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetTOC(System.Int32,ManagedBass.Cd.TOCMode,ManagedBass.Cd.TOC@)">
            <summary>
            Retrieves the TOC from the CD in a drive.
            </summary>
            <param name="Drive">The drive to get info on... 0 = the first drive.</param>
            <param name="Mode">TOC Mode.</param>
            <param name="TOC">An instance of the <see cref="T:ManagedBass.Cd.TOC" /> structure to store the information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This function gives the TOC in the form that it is delivered by the drive, except that the byte order may be changed to match the system's native byte order (the TOC is originally big-endian).</remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetTOC(System.Int32,ManagedBass.Cd.TOCMode)">
            <summary>
            Retrieves the TOC from the CD in a drive.
            </summary>
            <param name="Drive">The drive to get info on... 0 = the first drive.</param>
            <param name="Mode">TOC Mode.</param>
            <returns>If successful, an instance of the <see cref="T:ManagedBass.Cd.TOC" /> strucure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>This function gives the TOC in the form that it is delivered by the drive, except that the byte order may be changed to match the system's native byte order (the TOC is originally big-endian).</remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetTracks(System.Int32)">
            <summary>
            Retrieves the number of tracks on the CD in a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. If successful, the number of tracks on the CD is returned.</returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetTrackLength(System.Int32,System.Int32)">
            <summary>
            Retrieves the length (in bytes) of a track.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Track">The track to retrieve the length of... 0 = the first track.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. If successful, the length of the track is returned.</returns>
            <remarks>
            CD audio is always 44100hz stereo 16-bit.
            That's 176400 bytes per second.
            So dividing the track length by 176400 gives the length in seconds.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.CDTrack">The <paramref name="Track" /> number is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.GetTrackPregap(System.Int32,System.Int32)">
            <summary>
            Retrieves the pregap length (in bytes) of a track.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Track">The track to retrieve the pregap length of... 0 = the first track.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            If successful, the pregap length of the track is returned. To translate the pregap length from bytes to frames, divide by 2352.</returns>
            <remarks>
            The drive needs to support sub-channel reading in order to detect all but the first pregap length. 
            <see cref="P:ManagedBass.Cd.CDInfo.ReadWriteFlags" /> can be used to check whether the drive can read sub-channel data.
            <para>
            A track's pregap is actually played as part of the preceeding track. 
            So to remove the gap from the end of a track, you would get the pregap length of the following track. 
            The gap will usually contain silence, but it doesn't have to - it could contain crowd noise in a live recording, for example.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.CDTrack">The <paramref name="Track" /> number is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Reading sub-channel data is not supported by the drive.</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.AnalogGetPosition(System.Int32)">
            <summary>
            Retrieves the current position and track on a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            If successful, the HIWORD contains the track number (0=first), and the LOWORD contains the offset (in frames).
            </returns>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.AnalogIsActive(System.Int32)">
            <summary>
            Checks if analog playback is in progress on a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>The return value is <see cref="F:ManagedBass.PlaybackState.Stopped"/> or <see cref="F:ManagedBass.PlaybackState.Playing"/>.</returns>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.AnalogPlay(System.Int32,System.Int32,System.Int32)">
            <summary>
            Starts analog playback of an audio CD track.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <param name="Track">The track... 0 = the first track.</param>
            <param name="Position">Position (in frames) to start playback from. There are 75 frames per second.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Some old CD drives may not be able to digitally extract audio data (or not quickly enough to sustain playback), so that it's not possible to use <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags)" /> to stream CD tracks. 
            This is where the analog playback option can come in handy.
            </para>
            <para>
            In analog playback, the sound bypasses Bass - it goes directly from the CD drive to the soundcard (assuming the drive is cabled up to the soundcard). 
            This means that Bass output does not need to be initialized to use analog playback.
            It also means it's not possible to apply any DSP/FX to the sound, and nor is it possible to visualise it (unless you record the sound from the soundcard).
            </para>
            <para>
            Analog playback is not possible while digital streaming is in progress - the streaming will kill the analog playback.
            So if you wish to switch from digital to analog playback, you should first free the stream using <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" />.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NoCD">There's no CD in the drive.</exception>
            <exception cref="F:ManagedBass.Errors.CDTrack"><paramref name="Track" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAudioTrack">The track is not an audio track.</exception>
            <exception cref="F:ManagedBass.Errors.Position"><paramref name="Position" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.AnalogPlay(System.String,System.Int32)">
            <summary>
            Starts analog playback of an audio CD track, using a CDA file on the CD.
            </summary>
            <param name="FileName">The CDA filename... for example, "D:\Track01.cda".</param>
            <param name="Position">Position (in frames) to start playback from. There are 75 frames per second.</param>
            <returns>If successful, the number of the drive being used is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Some old CD drives may not be able to digitally extract audio data (or not quickly enough to sustain playback), so that it's not possible to use <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags)" /> to stream CD tracks.
            This is where the analog playback option can come in handy.
            </para>
            <para>
            In analog playback, the sound bypasses Bass - it goes directly from the CD drive to the soundcard (assuming the drive is cabled up to the soundcard). 
            This means that Bass output does not need to be initialized to use analog playback.
            It also means it's not possible to apply any DSP/FX to the sound, and nor is it possible to visualise it (unless you record the sound from the soundcard).
            </para>
            <para>
            Analog playback is not possible while digital streaming is in progress - the streaming will kill the analog playback.
            So if you wish to switch from digital to analog playback, you should first free the stream using <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" />.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file was not recognised as a CDA file.</exception>
            <exception cref="F:ManagedBass.Errors.Device">The Drive could not be found.</exception>
            <exception cref="F:ManagedBass.Errors.Position"><paramref name="Position" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Cd.BassCd.AnalogStop(System.Int32)">
            <summary>
            Stops analog playback on a drive.
            </summary>
            <param name="Drive">The drive... 0 = the first drive.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>Pausing can be achieved by getting the position (<see cref="M:ManagedBass.Cd.BassCd.AnalogGetPosition(System.Int32)" />) just before stopping, and then using that position in a call to <see cref="M:ManagedBass.Cd.BassCd.AnalogPlay(System.Int32,System.Int32,System.Int32)" /> to resume.</remarks>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Drive" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="T:ManagedBass.Cd.CDDataProcedure">
            <summary>
            User defined CD data callback delegate (to be used with <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Cd.BassCd.CreateStream(System.String,ManagedBass.BassFlags,ManagedBass.Cd.CDDataProcedure,System.IntPtr)" />).
            </summary>
            <param name="Handle">The CD stream that provided the data.</param>
            <param name="Position">The stream position (in bytes) that the data is from.</param>
            <param name="Type">The Type of data.</param>
            <param name="Buffer">The pointer to the Buffer data.</param>
            <param name="Length">The amount of data in bytes.</param>
            <param name="User">The User instance data given on stream creation.</param>
            <remarks>
            <para>
            Sub-channel data or C2 error info is delivered to this function as soon as it is read from the CD, before the associated audio data is played, or delivered by <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> in the case of a decoding channel.
            The Position value can be used to synchronize the delivered data with the stream's audio data.
            </para>
            <para>
            CDs are read from in units of a frame, and so this function will always receive a whole number of frames' worth of data;
            there are 96 bytes of sub-channel data per-frame, and 296 bytes of C2 error info.
            When <see cref="M:ManagedBass.Cd.BassCd.SetOffset(System.Int32,System.Int32)" /> has been used to set a read offset, playback may begin mid-frame, and as a result of that,
            <paramref name="Position" /> may start out negative because the delivered data is from the start of the 1st frame, before where playback will begin from.
            </para>
            <para>Neither sub-channel data or C2 error info will be delivered in the case of a silenced frame resulting from the <see cref="P:ManagedBass.Cd.BassCd.SkipError" /> config option being enabled.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Cd.CDDataType">
            <summary>
            The Type of data received, used with <see cref="T:ManagedBass.Cd.CDDataProcedure" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDDataType.SubChannel">
            <summary>
            Sub-channel data.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDDataType.C2">
            <summary>
            C2 error info.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.CDDoorAction">
            <summary>
            The CD Door actions to perform, used with <see cref="M:ManagedBass.Cd.BassCd.Door(System.Int32,ManagedBass.Cd.CDDoorAction)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDDoorAction.Close">
            <summary>
            Close the door.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDDoorAction.Open">
            <summary>
            Open the door.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDDoorAction.Lock">
            <summary>
            Lock the door.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDDoorAction.Unlock">
            <summary>
            Unlock the door.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.CDID">
            <summary>
            The identification to retrieve, used with <see cref="M:ManagedBass.Cd.BassCd.GetID(System.Int32,ManagedBass.Cd.CDID)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.UPC">
            <summary>
            Returns the catalog number of the CD.
            The number uses UPC/EAN-code (BAR coding).
            This might not be available for all CDs.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.CDDB">
            <summary>
            Produces a CDDB identifier.
            This can be used to get details on the CD's contents from a CDDB server.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.CDDB2">
            <summary>
            Produces a CDDB2 identifier.
            This can be used to get details on the CD's contents from a CDDB2 server.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.Text">
            <summary>
            Retrieves the CD-TEXT information from the CD.
            CD-TEXT is not available on the majority of CDs.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.CDPlayer">
            <summary>
            Produces an identifier that can be used to lookup CD details in the CDPLAYER.INI file, located in the Windows directory.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.MusicBrainz">
            <summary>
            Produces an identifier that can be used to get details on the CD's contents from <a href="http://www.musicbrainz.org">www.musicbrainz.org</a>.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.ISRC">
            <summary>
            Use: + track#. Returns the International Standard Recording Code of the track... 0 = first track.
            This might not be available for all CDs.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.Query">
            <summary>
            Sends a "query" command to the configured CDDB server (see <see cref="P:ManagedBass.Cd.BassCd.CDDBServer" />) to get a list of matching entries for the CD's CDDB identifier.
            The contents of each entry can be retrieved via the <see cref="F:ManagedBass.Cd.CDID.Read"/> option.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.Read">
            <summary>
            Use: + entry#.
            Sends a "read" command to the configured CDDB server (see <see cref="P:ManagedBass.Cd.BassCd.CDDBServer" />) to get a database entry for the CD's CDDB identifier... 0 = first entry.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDID.ReadCache">
            <summary>
            Returns the cached CDDB "read" command response, if there is one.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.CDInterface">
            <summary>
            The interface to use to access CD drives (used with <see cref="M:ManagedBass.Cd.BassCd.SetInterface(ManagedBass.Cd.CDInterface)" />).
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDInterface.Auto">
            <summary>
            Automatically detect an available interface.
            The interfaces are checked in the order that they are listed here.
            For example, if both SPTI and ASPI are available, SPTI will be used.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDInterface.SPTI">
            <summary>
            SCSI Pass-Through Interface.
            This is only available on NT-based Windows, not Windows 9x, and generally only to administrator user accounts, not limited/restricted user accounts.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDInterface.ASPI">
            <summary>
            Advanced SCSI Programming Interface.
            This is the only interface available on Windows 9x, and can also be installed on NT-based Windows.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDInterface.WIO">
            <summary>
            Windows I/O. Like SPTI, this is only available on NT-based Windows, but it is also available to limited/restricted user accounts.
            Some features are not available via this interface, notably sub-channel data reading and read speed control (except on Vista or newer).
            Door status detection is also affected.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDInterface.Linux">
            <summary>
            Linux interface.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.CDReadWriteFlags">
            <summary>
            The drive's reading &amp; writing capabilities used with <see cref="M:ManagedBass.Cd.BassCd.GetInfo(System.Int32,ManagedBass.Cd.CDInfo@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.CDR">
            <summary>
            The drive can read CD-R media.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.CDRW">
            <summary>
            The drive can read CD-RW media.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.CDRW2">
            <summary>
            The drive can read CD-R/RW media where the addressing Type is "method 2".
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.DVD">
            <summary>
            The drive can read DVD-ROM media.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.DVDR">
            <summary>
            The drive can read DVD-R media.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.DVDRAM">
            <summary>
            The drive can read DVD-RAM media.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.Analog">
            <summary>
            The drive is capable of analog playback.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.M2F1">
            <summary>
            The drive can read in "mode 2 form 1" format.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.M2F2">
            <summary>
            The drive can read in "mode 2 form 2" format.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.MultiSession">
            <summary>
            The drive can read multi-session discs.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.CDDA">
            <summary>
            The drive can read CD audio.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.CDDASIA">
            <summary>
            The drive supports "stream is accurate".
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.SubChannel">
            <summary>
            The drive can read sub-channel data.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.SubChannelDeInterleave">
            <summary>
            The drive can read sub-channel data, and de-interleave it.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.C2">
            <summary>
            The drive can provide C2 error info.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.ISRC">
            <summary>
            The drive can read ISRC numbers.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.CDReadWriteFlags.UPC">
            <summary>
            The drive can read UPC numbers.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.TOCControlFlags">
            <summary>
            The <see cref="P:ManagedBass.Cd.TOCTrack.Control" /> flags.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCControlFlags.None">
            <summary>
            No flag defined.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCControlFlags.PreEmphasis">
            <summary>
            Pre-emphasis of 50/15 µs.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCControlFlags.DigitalCopyPermitted">
            <summary>
            Digital copy permitted.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCControlFlags.DataTrack">
            <summary>
            Data track.
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.TOCMode">
            <summary>
            The mode to use with <see cref="M:ManagedBass.Cd.BassCd.GetTOC(System.Int32,ManagedBass.Cd.TOCMode,ManagedBass.Cd.TOC@)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCMode.LBA">
            <summary>
            Get the track start address in LBA form.
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCMode.Time">
            <summary>
            Get the track start address in time form (hour, minute, second, frame).
            </summary>
        </member>
        <member name="F:ManagedBass.Cd.TOCMode.Index">
            <summary>
            + track#, Get the position of indexes (instead of tracks)
            <para>When this option is used, the 'first' and 'last' members of the TOC structure are index numbers, 
            and the 'track' member of the <see cref="T:ManagedBass.Cd.TOCTrack"/> structure is also an index number and the "lba" or "hmsf" member 
            (depending on whether "<see cref="F:ManagedBass.Cd.TOCMode.Time"/>" is used) is an offset from the start of the track</para>
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.CDInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Cd.BassCd.GetInfo(System.Int32,ManagedBass.Cd.CDInfo@)" /> to retrieve information on a drive.
            </summary>
            <remarks>The <see cref="P:ManagedBass.Cd.CDInfo.ReadWriteFlags"/>, <see cref="P:ManagedBass.Cd.CDInfo.MaxSpeed"/> and <see cref="P:ManagedBass.Cd.CDInfo.Cache"/> members are unavailable when the WIO interface is used.</remarks>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.Name">
            <summary>
            The drive product/model name.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.Manufacturer">
            <summary>
            The drive manufacturer name.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.Revision">
            <summary>
            The revision number as a string.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.SpeedMultiplier">
            <summary>
            Gets the real-time Speed Multiplier = <see cref="P:ManagedBass.Cd.CDInfo.MaxSpeed"/> / 176.4.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.DriveLetter">
            <summary>
            The character letter of the drive.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.CanOpen">
            <summary>
            If <see langword="true" />, <see cref="M:ManagedBass.Cd.BassCd.Door(System.Int32,ManagedBass.Cd.CDDoorAction)" /> can be used and <see cref="F:ManagedBass.Cd.CDDoorAction.Open"/>/<see cref="F:ManagedBass.Cd.CDDoorAction.Close"/> is supported?
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.CanLock">
            <summary>
            If <see langword="true" />, <see cref="M:ManagedBass.Cd.BassCd.Door(System.Int32,ManagedBass.Cd.CDDoorAction)" /> can be used and <see cref="F:ManagedBass.Cd.CDDoorAction.Lock"/>/<see cref="F:ManagedBass.Cd.CDDoorAction.Unlock"/> is supported?
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.MaxSpeed">
            <summary>
            The maximum read speed, in kilobytes per second (KB/s). Divide by 176.4 to get the real-time speed multiplier, eg. 5645 / 176.4 = "32x speed".
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.Cache">
            <summary>
            The drive's cache size, in kilobytes (KB).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.CDText">
            <summary>
            The drive can read CD-TEXT?
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.CDInfo.ReadWriteFlags">
            <summary>
            Read/Write capability flags (any combination of <see cref="T:ManagedBass.Cd.CDReadWriteFlags" />).
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.TOC">
            <summary>
            Used with <see cref="M:ManagedBass.Cd.BassCd.GetTOC(System.Int32,ManagedBass.Cd.TOCMode,ManagedBass.Cd.TOC@)" /> to retrieve the TOC from a CD.
            </summary>
            <remarks>
            If <see cref="F:ManagedBass.Cd.TOCMode.Index"/> was used in the <see cref="M:ManagedBass.Cd.BassCd.GetTOC(System.Int32,ManagedBass.Cd.TOCMode,ManagedBass.Cd.TOC@)" /> call, first and last will be index numbers rather than track numbers.
            </remarks>
        </member>
        <member name="P:ManagedBass.Cd.TOC.First">
            <summary>
            The first track number (or index number if <see cref="F:ManagedBass.Cd.TOCMode.Index"/> is used).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOC.Last">
            <summary>
            The last track number (or index number if <see cref="F:ManagedBass.Cd.TOCMode.Index"/> is used).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOC.Tracks">
            <summary>
            The list of tracks retrieved (see <see cref="T:ManagedBass.Cd.TOCTrack" />, up to 100 tracks).
            </summary>
        </member>
        <member name="T:ManagedBass.Cd.TOCTrack">
            <summary>
            Represents one track of a CD's TOC (see <see cref="T:ManagedBass.Cd.TOC" />).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOCTrack.ADR">
            <summary>
            ADR
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOCTrack.Control">
            <summary>
            Control
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOCTrack.Track">
            <summary>
            The track number... 170 = lead-out area (or index number if <see cref="F:ManagedBass.Cd.TOCMode.Index" /> is used).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOCTrack.LBA">
            <summary>
            Logical Block Address.
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOCTrack.Frame">
            <summary>
            The address in time form (frame part).
            </summary>
        </member>
        <member name="P:ManagedBass.Cd.TOCTrack.Address">
            <summary>
            The Address in Time format.
            </summary>
        </member>
        <member name="T:ManagedBass.Dsd.BassDsd">
            <summary>
            Wraps BassDsd
            </summary> 
            <remarks>
            Supports .dsf, .dff, .dsd
            </remarks>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Dsd.BassDsd.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr,System.Int32)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Dsd.BassDsd.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr,System.Int32)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="P:ManagedBass.Dsd.BassDsd.DefaultFrequency">
            <summary>
            The default sample rate when converting to PCM.
            </summary>
            <remarks>
            <para>
            This setting determines what sample rate is used by default when converting to PCM.
            The rate actually used may be different if the specified rate is not valid for a particular DSD rate, in which case it will be rounded up (or down if there are none higher) to the nearest valid rate;
            the valid rates are 1/8, 1/16, 1/32, etc. of the DSD rate down to a minimum of 44100 Hz.
            </para>
            <para>
            The default setting is 88200 Hz.
            Changes only affect subsequently created streams, not any that already exist.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Dsd.BassDsd.DefaultGain">
            <summary>
            The default gain applied when converting to PCM.
            </summary>
            <remarks>
            <para>
            This setting determines what gain is applied by default when converting to PCM.
            Changes only affect subsequently created streams, not any that already exist.
            An existing stream's gain can be changed via the <see cref="F:ManagedBass.ChannelAttribute.DSDGain" /> attribute.
            </para>
            <para>The default setting is 6dB.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Dsd.DSDComment">
            <summary>
            DSD Comment tag structure.
            </summary>
        </member>
        <member name="P:ManagedBass.Dsd.DSDComment.TimeStamp">
            <summary>
            Time Stamp.
            </summary>
        </member>
        <member name="F:ManagedBass.Dsd.DSDComment.CommentType">
            <summary>
            The comment type
            </summary>
        </member>
        <member name="F:ManagedBass.Dsd.DSDComment.Reference">
            <summary>
            The comment reference. Together with CommentType this indicates to what the comment refers. 
            If CommentType=General then this should be 0. 
            If CommentType=Channel then 0 = all channels, 1 = 1st channel, 2 = 2nd channel, etc. 
            If CommentType=SoundSource then 0 = DSD recording, 1 = analogue recording, 2 = PCM recording. 
            If CommentType=FileHistory then 0 = general remark, 1 = name of the operator, 2 = name or type of the creating machine, 3 = time zone information, 4 = revision of the file.
            </summary>
        </member>
        <member name="P:ManagedBass.Dsd.DSDComment.Description">
            <summary>
            The description of the comment.
            </summary>
        </member>
        <member name="M:ManagedBass.Dsd.DSDComment.Read(System.Int32,System.Int32)">
            <summary>
            Reads a tag at an <paramref name="Index"/> from a <paramref name="Channel"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Dsd.DSDCommentType">
            <summary>
            DSD Comment Type to be used with <see cref="F:ManagedBass.Dsd.DSDComment.CommentType"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.Dsd.DSDCommentType.General">
            <summary>
            General
            </summary>
        </member>
        <member name="F:ManagedBass.Dsd.DSDCommentType.Channel">
            <summary>
            Channel
            </summary>
        </member>
        <member name="F:ManagedBass.Dsd.DSDCommentType.SoundSource">
            <summary>
            Sound Source
            </summary>
        </member>
        <member name="F:ManagedBass.Dsd.DSDCommentType.FileHistory">
            <summary>
            File History
            </summary>
        </member>
        <member name="T:ManagedBass.BassAac">
            <summary>
            Wraps BassAac
            </summary> 
            <remarks>
            Supports .aac, .adts, .mp4, .m4a, .m4b
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAac.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAac.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.BassAac.PlayAudioFromMp4">
            <summary>
            Play audio from Mp4... default = true.
            </summary>
        </member>
        <member name="P:ManagedBass.BassAac.AacSupportMp4">
            <summary>
            Support Mp4 in Aac functions.
            </summary>
        </member>
        <member name="F:ManagedBass.BassAac.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassAac.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassAac.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassAac.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassAac.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassAac.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassMp4">
            <summary>
            BassAac support for Mp4
            </summary> 
            <remarks>
            
            </remarks>
        </member>
        <member name="M:ManagedBass.BassMp4.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassMp4.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassMp4.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassMp4.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassMp4.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassMp4.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassMp4.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassMp4.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.Mix.BassMix">
            <summary>
            Wraps BassMix: bassmix.dll
            </summary>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])">
            <summary>
            Creates a splitter stream (adds a reader channel to a decoding source channel).
            </summary>
            <param name="Channel">The handle of the decoding source channel to split... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Flags">The channel falgs to be used to create the reader channel.</param>
            <param name="ChannelMap">The target (readers) channel mapping definition, which is an array of source channel index values (0=1st channel, 1=2nd channel, 2=3rd channel, 3=4th channel etc.) ending with a final -1 element (use <see langword="null" /> to create a 1:1 reader).</param>
            <returns>If successful, the new reader stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            A "splitter" basically does the opposite of a mixer: it splits a single source into multiple streams rather then mixing multiple sources into a single stream.
            Like mixer sources, splitter sources must be decoding channels.
            <para>
            The splitter stream will have the same sample rate and resolution as its source, but it can have a different number of channels, as dictated by the mapping parameter.
            Even when the number of channels is different (and so the amount of data produced is different), <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will give the source length, and <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> will give the source position that is currently being output by the splitter stream.
            </para>
            <para>
            All splitter streams with the same source share a buffer to access its sample data.
            The length of the buffer is determined by the <see cref="P:ManagedBass.Mix.BassMix.SplitBufferLength"/> config option;
            the splitter streams should not be allowed to drift apart beyond that, otherwise those left behind will suffer buffer overflows. 
            A splitter stream's buffer state can be reset via <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" />;
            that can also be used to reset a splitter stream that has ended, so that it can be played again.
            </para>
            <para>
            If the <see cref="F:ManagedBass.BassFlags.SplitSlave"/> flag is used, the splitter stream will only receive data from the buffer and will not request more data from the source, so it can only receive data that has already been received by another splitter stream with the same source.
            The <see cref="F:ManagedBass.BassFlags.SplitSlave"/> flag can be toggled at any time via <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />.
            </para>
            <para>
            When <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> is used on a splitter stream, its source will be set to the requested position and the splitter stream's buffer state will be reset so that it immediately receives data from the new position. 
            The position change will affect all of the source's splitter streams, but the others will not have their buffer state reset;
            they will continue to receive any buffered data before reaching the data from the new position. 
            <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" /> can be used to reset the buffer state.
            </para>
            <para>
            Use <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)"/> with a splitter channel to remove it from the source.
            When a source is freed, all of its splitter streams are automatically freed.
            </para>
            <para>
            The <paramref name="ChannelMap" /> array defines the channel number to be created for the reader as well as which source channels should be used for each.
            This enables you to create a reader stream which extract certain source channels (e.g. create a mono reader based on a stereo source), remaps the channel order (e.g. swap left and right in the reader) or even contains more channels than the source (e.g. create a 5.1 reader based on a stereo source).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="ChannelMap" /> contains an invalid channel index.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding streams (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficent memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Couldn't initialize 3D support for the stream.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamGetAvailable(System.Int32)">
            <summary>
            Retrieves the amount of buffered data available to a splitter stream, or the amount of data in a splitter source buffer.
            </summary>
            <param name="Handle">The splitter (as obtained by <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" />) or the source channel handle.</param>
            <returns>If successful, then the amount of buffered data (in bytes) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            With a splitter source, this function reports how much data is in the buffer that is shared by all of its splitter streams.
            With a splitter stream, this function reports how much data is ahead of it in the buffer, before it will receive any new data from the source.
            A splitter stream can be repositioned within the buffer via the <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32,System.Int32)" /> function.
            <para>The amount of data that can be buffered is limited by the buffer size, which is determined by the <see cref="P:ManagedBass.Mix.BassMix.SplitBufferLength" /> config option.</para>
            <para>The returned buffered byte count is always based on the source's sample format, even with splitter streams that were created with a different channel count.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is neither a splitter stream or source.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)">
            <summary>
            Resets a splitter stream or all splitter streams of a source.
            </summary>
            <param name="Handle">The splitter (as obtained by <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" />) or the source channel handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function resets the splitter stream's buffer state, so that the next sample data it receives will be from the source's current position. 
            If the stream has ended, that is reset too, so that it can be played again.
            Unless called from within a mixtime sync callback, the stream's output buffer (if it has one) is also flushed.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is neither a splitter stream or source.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32,System.Int32)">
            <summary>
            Resets a splitter stream and sets its position in the source buffer.
            </summary>
            <param name="Handle">The splitter (as obtained by <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" />) or the source channel handle.</param>
            <param name="Offset">
            How far back (in bytes) to position the splitter in the source buffer.
            This is based on the source's sample format, which may have a different channel count to the splitter.
            </param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is the same as <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" /> except that it also provides the ability to position the splitter stream within the buffer that is shared by all of the splitter streams of the same source.
            A splitter stream's buffer position determines what data it will next receive.
            For example, if its position is half a second back, it will receive half a second of buffered data before receiving new data from the source.
            Calling this function with <paramref name="Offset"/> = 0 will result in the next data that the splitter stream receives being new data from the source, and is identical to using <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" />.
            <para>
            <paramref name="Offset" /> is automatically limited to the amount of data that the source buffer contains, which is in turn limited to the buffer size, determined by the <see cref="P:ManagedBass.Mix.BassMix.SplitBufferLength" /> config option.
            The amount of source data buffered, as well as a splitter stream's position within it, is available from <see cref="M:ManagedBass.Mix.BassMix.SplitStreamGetAvailable(System.Int32)" />.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is neither a splitter stream or source.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamGetSource(System.Int32)">
            <summary>
            Retrieves the source of a splitter stream.
            </summary>
            <param name="Handle">The splitter stream handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" /> beforehand).</param>
            <returns>If successful, the source stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is not a splitter stream.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamGetSplits(System.Int32)">
            <summary>
            Retrieves the channel's splitters.
            </summary>
            <param name="Handle">The handle to check.</param>
            <returns>The array of splitter handles (<see langword="null" /> on error, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.CreateMixerStream(System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Creates a mixer stream.
            </summary>
            <param name="Frequency">The sample rate of the mixer output (e.g. 44100).</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers (or the <see cref="F:ManagedBass.BassFlags.Decode"/> flag) in Windows, and the Speaker flags are ignored.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>..</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Source channels are "plugged" into a mixer using the <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> functions, and "unplugged" using the <see cref="M:ManagedBass.Mix.BassMix.MixerRemoveChannel(System.Int32)" /> function.
            Sources can be added and removed at any time, so a mixer does not have a predetermined length and <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> is not applicable.
            Likewise, seeking is not possible, except to position 0, as described below.
            </para>
            <para>
            If the mixer output is being played (it is not a decoding channel), then there will be some delay in the effect of adding/removing source channels or changing their attributes being heard.
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> and <see cref="P:ManagedBass.Bass.UpdatePeriod" /> config options.
            The playback buffer can be flushed by calling <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (Restart = true) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (Position = 0).
            That can also be done to restart a mixer that has ended.
            </para>
            <para>
            Unless the <see cref="F:ManagedBass.BassFlags.MixerEnd"/> flag is specified, a mixer stream will never end.
            When there are no sources (or the sources have ended/stalled), it'll produce no output until there's an active source. 
            That's unless the <see cref="F:ManagedBass.BassFlags.MixerNonStop"/> flag is used, in which case it will produce silent output while there are no active sources.
            The <see cref="F:ManagedBass.BassFlags.MixerEnd"/> and <see cref="F:ManagedBass.BassFlags.MixerNonStop"/> flags can be toggled at any time, using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />.
            </para>
            <para>
            Besides mixing channels, a mixer stream can be used as a resampler.
            In that case the freq parameter would be set the new sample rate, and the source channel's attributes would be left at their defaults. 
            A mixer stream can also be used to downmix, upmix and generally rearrange channels, set using the <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/>.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding streams (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>.</exception>
            <exception cref="F:ManagedBass.Errors.SampleRate"><paramref name="Frequency"/> is out of range. See <see cref="P:ManagedBass.BassInfo.MinSampleRate"/> and <see cref="P:ManagedBass.BassInfo.MaxSampleRate"/> members.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficent memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Couldn't initialize 3D support for the stream.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Plugs a channel into a mixer.
            </summary>
            <param name="Handle">The mixer handle (created with <see cref="M:ManagedBass.Mix.BassMix.CreateMixerStream(System.Int32,System.Int32,ManagedBass.BassFlags)" />).</param>
            <param name="Channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Internally, a mixer will use the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> function to get data from its source channels.
            That means that the source channels must be decoding channels (not using a <see cref="T:ManagedBass.RecordProcedure" /> in the case of a recording channel).
            Plugging a channel into more than one mixer at a time is not possible because the mixers would be taking data away from each other.
            An advantage of this is that there is no need for a mixer's handle to be provided with the channel functions.
            It is actually possible to plug a channel into multiple mixers via the use of splitter streams.</para>
            <para>
            Channels are 'unplugged' using the <see cref="M:ManagedBass.Mix.BassMix.MixerRemoveChannel(System.Int32)" /> function.
            Channels are also automatically unplugged when they are freed.
            </para>
            <para>
            When mixing a channel, the mixer makes use of the channel's attributes (freq/volume/pan), as set with <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" /> or <see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)" />.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> and <see cref="P:ManagedBass.Bass.LogarithmicPanningCurve"/> config option settings are also used.
            </para>
            <para>
            If a multi-channel stream has more channels than the mixer output, the extra channels will be discarded.
            For example, if a 5.1 stream is plugged into a stereo mixer, only the front-left/right channels will be retained.
            That is unless matrix mixing is used.
            </para>
            <para>
            The mixer processing is performed in floating-point, so it makes sense (for both quality and efficiency reasons) for the source channels to be floating-point too, though they do not have to be.
            It is also more efficient if the source channels have the same sample rate as the mixer output because no sample rate conversion is required then.
            When sample rate conversion is required, windowed sinc interpolation is used and the source's <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion" /> attribute determines how many points/samples are used in that, as follows:
            0 (or below) = 4 points, 1 = 8 points, 2 = 16 points, 3 = 32 points, 4 = 64 points, 5 = 128 points, 6 (or above) = 256 points.
            8 points are used if the <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion" /> attribute is unavailable (old BASS version).
            A higher number of points results in better sound quality (less aliasing and smaller transition band in the low-pass filter), but also higher CPU usage.
            </para>
            <para><b>Platform-specific:</b></para>
            <para>
            The sample rate conversion processing is limited to 128 points on iOS and Android.
            The mixer processing is also performed in fixed-point rather than floating-point on Android.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode"><paramref name="Channel" /> is not a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><paramref name="Channel" /> is already plugged into a mixer. It must be unplugged first.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)">
            <summary>
            Plugs a channel into a mixer, optionally delaying the start and limiting the length.
            </summary>
            <param name="Handle">The mixer handle (created with <see cref="M:ManagedBass.Mix.BassMix.CreateMixerStream(System.Int32,System.Int32,ManagedBass.BassFlags)" />).</param>
            <param name="Channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Start">Delay (in bytes) before the channel is mixed in.</param>
            <param name="Length">The maximum amount of data (in bytes) to mix... 0 = no limit. Once this end point is reached, the channel will be removed from the mixer.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" />, but with the additional ability to specify a delay and duration for the channel.
            <para>
            The <paramref name="Start" /> and <paramref name="Length" /> parameters relate to the mixer output.
            So when calculating these values, use the mixer stream's sample format rather than the source channel's. 
            The start parameter is automatically rounded-down to the nearest sample boundary, while the length parameter is rounded-up to the nearest sample boundary.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode"><paramref name="Channel" /> is not a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><paramref name="Channel" /> is already plugged into a mixer. It must be unplugged first.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.MixerRemoveChannel(System.Int32)">
            <summary>
            Unplugs a channel from a mixer.
            </summary>
            <param name="Handle">The handle of the mixer source channel to unplug (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
        </member>
        <member name="P:ManagedBass.Mix.BassMix.SplitBufferLength">
            <summary>
            The splitter Buffer Length in milliseconds... 100 (min) to 5000 (max).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            When a source has its first splitter stream created, a Buffer is allocated
            for its sample data, which all of its subsequently created splitter streams
            will share. This config option determines how big that Buffer is. The default
            is 2000ms.
            The Buffer will always be kept as empty as possible, so its size does not
            necessarily affect latency; it just determines how far splitter streams can
            drift apart before there are Buffer overflow issues for those left behind.
            Changes do not affect buffers that have already been allocated; any sources
            that have already had splitter streams created will continue to use their
            existing buffers.
            </remarks>
        </member>
        <member name="P:ManagedBass.Mix.BassMix.MixerBufferLength">
            <summary>
            The source channel Buffer size multiplier... 1 (min) to 5 (max). 
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            When a source channel has buffering enabled, the mixer will Buffer the decoded data,
            so that it is available to the <see cref="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)"/> functions.
            To reach the source channel's Buffer size, the multiplier (multiple) is applied to the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
            setting at the time of the mixer's creation.
            If the source is played at it's default rate, then the Buffer only need to be as big as the mixer's Buffer.
            But if it's played at a faster rate, then the Buffer needs to be bigger for it to contain the data that 
            is currently being heard from the mixer.
            For example, playing a channel at 2x its normal speed would require the Buffer to be 2x the normal size (multiple = 2).
            Larger buffers obviously require more memory, so the multiplier should not be set higher than necessary.
            The default multiplier is 2x. 
            Changes only affect subsequently setup channel buffers.
            An existing channel can have its Buffer reinitilized by disabling and then re-enabling 
            the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag using <see cref="M:ManagedBass.Mix.BassMix.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Mix.BassMix.MixerPositionEx">
            <summary>
            BASSmix add-on: How far back to keep record of source positions
            to make available for <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags,System.Int32)"/>, in milliseconds.
            </summary>
            <remarks>
            If a mixer is not a decoding channel (not using the BassFlag.Decode flag),
            this config setting will just be a minimum and the mixer will 
            always have a position record at least equal to its playback Buffer Length, 
            as determined by the PlaybackBufferLength config option.
            The default setting is 2000ms.
            Changes only affect newly created mixers, not any that already exist.
            </remarks>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)">
            <summary>
            Modifies and/or retrieves a channel's mixer flags.
            </summary>
            <param name="Handle">The handle of the mixer source channel to modify (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Mask">
            The flags (as above) to modify.
            Flags that are not included in this are left as they are, so it can be set to 0 (<see cref="F:ManagedBass.BassFlags.Default" />) in order to just retrieve the current flags. 
            To modify the speaker flags, any of the Speaker flags can be used in the mask (no need to include all of them).
            </param>
            <returns>If successful, the channel's updated flags are returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function only deals with the channel's mixer related flags.
            The channel's standard flags, for example looping (<see cref="F:ManagedBass.BassFlags.Loop"/>), are unaffected - use <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" /> to modify them.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelHasFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Gets whether a flag is present.
            </summary>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelAddFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Adds a flag to Mixer.
            </summary>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelRemoveFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Removes a flag from Mixer.
            </summary>
            <param name="handle"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">Location to write the data as an <see cref="T:System.IntPtr" /> (can be <see cref="F:System.IntPtr.Zero" /> when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">byte[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Byte[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">short[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int16[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">int[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int32[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">float[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Single[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" />, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be used to get the level.
            Otherwise, the level will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The mixer is not playing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retrieves the level of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Levels">An array to receive the levels.</param>
            <param name="Length">The amount of data to inspect to calculate the level, in seconds. The maximum is 1 second. Less data than requested may be used if the full amount is not available, eg. if the source's buffer (determined by the <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option) is shorter.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.LevelRetrievalFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)" />, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The mixer is not playing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Retrieves a channel's mixing matrix, if it has one.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Matrix">The 2-dimentional array (float[,]) where to write the matrix.</param>
            <returns>If successful, a <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            For more details see <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])" />.
            The array must be big enough to get the matrix.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel is not using matrix mixing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetMixer(System.Int32)">
            <summary>
            Retrieves the mixer that a channel is plugged into.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <returns>If successful, the mixer stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Sets a channel's mixing matrix, if it has one.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand)</param>
            <param name="Matrix">The 2-dimensional array (float[,]) of the mixing matrix.</param>
            <returns>If successful, a <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Normally when mixing channels, the source channels are sent to the output in the same order - the left input is sent to the left output, and so on.
            Sometimes something a bit more complex than that is required.
            For example, if the source has more channels than the output, you may want to "downmix" the source so that all channels are present in the output.
            Equally, if the source has fewer channels than the output, you may want to "upmix" it so that all output channels have sound.
            Or you may just want to rearrange the channels. Matrix mixing allows all of these.
            </para>
            <para>
            A matrix mixer is created on a per-source basis (you can mix'n'match normal and matrix mixing), by using the <see cref="F:ManagedBass.BassFlags.MixerMatrix" /> and/or <see cref="F:ManagedBass.BassFlags.MixerDownMix" /> flag when calling <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />. 
            The matrix itself is a 2-dimensional array of floating-point mixing levels, with the source channels on one axis, and the output channels on the other.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel is not using matrix mixing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:],System.Single)">
            <summary>
            Sets a channel's mixing matrix, transitioning from the current matrix.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Matrix">The 2-dimensional array (float[,]) of the new mixing matrix.</param>
            <param name="Time">The time to take (in seconds) to transition from the current matrix to the specified matrix.</param>
            <returns>If successful, a <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This method is identical to <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])" /> but with the option of transitioning over time to the specified matrix.
            If this function or <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/> is called while a previous matrix transition is still in progress, then that transition will be stopped.
            If <see cref="M:ManagedBass.Mix.BassMix.ChannelGetMatrix(System.Int32,System.Single[0:,0:])"/> is called mid-transition, it will give the mid-transition matrix values.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel is not using matrix mixing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)">
            <summary>
            Retrieves the playback position of a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Mode">Position mode... default = <see cref="F:ManagedBass.PositionFlags.Bytes"/>.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. If successful, the position is returned.</returns>
            <remarks>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />, but it compensates for the mixer's buffering to return the source channel position that is currently being heard.
            So when used with a decoding channel (eg. a mixer source channel), this method will return the current decoding position.
            But if the mixer output is being played, then there is a playback buffer involved.
            This function compensates for that, to return the position that is currently being heard. 
            If the mixer itself is a decoding channel, then this function is identical to using <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested position is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags,System.Int32)">
            <summary>
            Retrieves the playback position of a mixer source channel, optionally accounting for some latency.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Mode">Position mode.</param>
            <param name="Delay">How far back (in bytes) in the mixer output to get the source channel's position from.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. If successful, the channel's position is returned.</returns>
            <remarks>
            <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> compensates for the mixer's playback buffering to give the position that is currently being heard, but if the mixer is feeding some other output system, it will not know how to compensate for that.
            This function fills that gap by allowing the latency to be specified in the call.
            This functionality requires the mixer to keep a record of its sources' position going back some time, and that is enabled via the <see cref="F:ManagedBass.BassFlags.MixerPositionEx" /> flag when a mixer is created, with the <see cref="P:ManagedBass.Mix.BassMix.MixerPositionEx" /> config option determining how far back the position record goes.
            If the mixer is not a decoding channel (not using the <see cref="F:ManagedBass.BassFlags.Decode" /> flag), then it will automatically have a position record at least equal to its playback buffer length.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested position is not available, or delay goes beyond where the mixer has record of the source channel's position.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)">
            <summary>
            Sets the playback position of a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Position">The position, in bytes. With MOD musics, the position can also be set in orders and rows instead of bytes.</param>
            <param name="Mode">Position Mode... default = <see cref="F:ManagedBass.PositionFlags.Bytes"/>.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function works exactly like the standard <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />, except that it also resets things for the channel in the mixer, well as supporting the <see cref="F:ManagedBass.BassFlags.MixerNoRampin"/> flag.
            See <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> for details.
            <para>For custom looping purposes (eg. in a mixtime <see cref="T:ManagedBass.SyncProcedure"/>), the standard <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> function should be used instead of this</para>
            <para>The playback buffer of the mixer can be flushed by using pos = 0.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotFile">The stream is not a file stream.</exception>
            <exception cref="F:ManagedBass.Errors.Position">The requested position is illegal.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The download has not yet reached the requested position.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The type of sync.</param>
            <param name="Parameter">The sync parameters, depends on the sync type.</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are automatically <see cref="F:ManagedBass.SyncFlags.Mixtime"/>, 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag is used, then there is effectively no real difference between this function and <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />.
            One sync type that is slightly different is the <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync, which can be either mixtime or not.
            </para>
            <para>
            Sync types that would automatically be mixtime when using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are not so when using this function. 
            The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag should be specified in those cases, or <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> used instead.
            </para>
            <para>
            When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it.
            Syncs set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are unaffected.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal <paramref name="Parameter" /> was specified.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)">
            <summary>
            Sets up an extended synchronizer on a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The type of sync.</param>
            <param name="Parameter">The sync parameters, depends on the sync type.</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The main difference between this method and <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> is, that this method invokes the <see cref="T:ManagedBass.Mix.SyncProcedureEx" /> callback.
            This callback contains an extra 'Offset' parameter, which defines the position of the sync occurrence within the current update cycle of the source converted to the mixer stream position.
            This offset might be used to calculate more accurate non-mixtime sync triggers (as with non-mixtime sync's a variable delay is to be expected, as the accuracy depends on the sync thread waking in time, and there is no guarantee when that will happen) - 
            as well as mixtime syncs are only accurate to the current update period, as they are triggered within such.
            So a mixtime sync is being triggered ahead of the actual mixer position being heard.
            The 'Offset' parameter might be used to compensate for that.
            </para>
            <para>
            When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are automatically <see cref="F:ManagedBass.SyncFlags.Mixtime"/>, 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag is used, then there is effectively no real difference between this function and <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />.
            One sync type that is slightly different is the <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync, which can be either mixtime or not.
            </para>
            <para>
            Sync types that would automatically be mixtime when using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are not so when using this function. 
            The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag should be specified in those cases, or <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> used instead.
            </para>
            <para>
            When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it.
            Syncs set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are unaffected.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal <paramref name="Parameter" /> was specified.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle (as returned by <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />).</param>
            <param name="Sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> call).</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This function can only remove syncs that were set via <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, not those that were set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Sync" /> is not valid.</exception>        
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Single@)">
            <summary>
            Retrieves the current position and value of an envelope on a channel.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Type">The envelope to get the position/value of.</param>
            <param name="Value">A reference to a variable to receive the envelope value at the current position.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The envelope's current position is not necessarily what is currently being heard, due to buffering.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no envelope of the requested type on the channel.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Int64)">
            <summary>
            Sets the current position of an envelope on a channel.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The envelope to set the position/value of.</param>
            <param name="Position">The new envelope position, in bytes. If this is beyond the end of the envelope it will be capped or looped, depending on whether the envelope has looping enabled.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            During playback, the effect of changes are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option config option to reduce the buffer length.
            <para>
            Note: Envelopes deal in mixer positions, not sources!
            So when you are changing the source position (e.g. via <see cref="M:ManagedBass.Mix.BassMix.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> the envelope's positions doesn't change with it.
            You might use this method to align the envelope position accorting to the new source position
            .</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no envelope of the requested type on the channel.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetEnvelope(System.Int32,ManagedBass.Mix.MixEnvelope,ManagedBass.Mix.MixerNode[],System.Int32)">
            <summary>
            Sets an envelope to modify the sample rate, volume or pan of a channel over a period of time.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The envelope to get the position/value of.</param>
            <param name="Nodes">The array of envelope nodes, which should have sequential positions.</param>
            <param name="Length">The number of elements in the nodes array... 0 = no envelope.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Envelopes are applied on top of the channel's attributes, as set via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />. 
            In the case of <see cref="F:ManagedBass.Mix.MixEnvelope.Frequency"/> and <see cref="F:ManagedBass.Mix.MixEnvelope.Volume"/>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="F:ManagedBass.Mix.MixEnvelope.Pan"/> case, the final panning is a sum of the channel attribute and envelope.
            </para>
            <para>
            <see cref="M:ManagedBass.Mix.BassMix.ChannelGetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Single@)" /> can be used to get the current envelope position, 
            and a <see cref="F:ManagedBass.SyncFlags.MixerEnvelope"/> sync can be set via <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when an envelope ends.
            The function can be called again from such a sync, in order to set a new envelope to follow the old one.
            </para>
            <para>
            Any previous envelope of the same type is replaced by the new envelope.
            A copy is made of the nodes array, so it does not need to persist beyond this function call.
            </para>
            <para>Note: Envelopes deal in mixer positions, not sources!
            You might use <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Int64)" /> to adjust the envelope to a source channel position.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
        </member>
        <member name="T:ManagedBass.Mix.MixEnvelope">
            <summary>
            Mixer envelope attribute types, used with <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelope(System.Int32,ManagedBass.Mix.MixEnvelope,ManagedBass.Mix.MixerNode[],System.Int32)" />, <see cref="M:ManagedBass.Mix.BassMix.ChannelGetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Single@)" /> and <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Int64)" /> to set/retrieve an envelope on a mixer source channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Frequency">
            <summary>
            Sample rate.
            <para>Envelopes are applied on top of the channel's attributes.
            The final sample rate is the product of the channel attribute and the envelope.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Volume">
            <summary>
            Volume.
            <para>Envelopes are applied on top of the channel's attributes. 
            The final volume is the product of the channel attribute and the envelope.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Pan">
            <summary>
            Panning/Balance.
            <para>Envelopes are applied on top of the channel's attributes. 
            The final panning is a sum of the channel attribute and envelope.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Loop">
            <summary>
            Loop the envelope (flag).
            </summary>
        </member>
        <member name="T:ManagedBass.Mix.MixerNode">
            <summary>
            Used with <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelope(System.Int32,ManagedBass.Mix.MixEnvelope,ManagedBass.Mix.MixerNode[],System.Int32)" /> to set an envelope on a mixer source channel.
            </summary>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />. 
            In the case of <see cref="F:ManagedBass.Mix.MixEnvelope.Frequency"/> and <see cref="F:ManagedBass.Mix.MixEnvelope.Volume"/>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="F:ManagedBass.Mix.MixEnvelope.Pan"/> case, the final panning is a sum of the channel attribute and envelope.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Mix.MixerNode.Position">
            <summary>
            The postion of the node in bytes. This is based on the mixer's sample format, not the source channel's format!
            </summary>
            <remarks>Note: Envelopes deal with mixer positions, not sources!</remarks>
        </member>
        <member name="F:ManagedBass.Mix.MixerNode.Value">
            <summary>
            The envelope value at the position.
            </summary>
        </member>
        <member name="T:ManagedBass.Mix.SyncProcedureEx">
            <summary>
            User defined extended mixer synchronizer callback function (see <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)" /> for details).
            </summary>
            <param name="Handle">The sync handle that has occured (as returned by <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)" />).</param>
            <param name="Channel">The channel that the sync occured on (the mixer source channel).</param>
            <param name="Data">Additional data associated with the sync's occurance.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)" /> was called.</param>
            <param name="Offset">The offset in bytes containing the position of the sync occurrence within the update cycle converted to the mixer stream.</param>
            <remarks>
            <para>
            A sync callback function should be very quick as other syncs can't be processed until it has finished.
            Attribute slides (<see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)" />) are also performed by the sync thread, so are also affected if a sync callback takes a long time.
            </para>
            <para>
            If the sync is a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> sync, then depending on the sync type, the callback will be executed in the update thread.
            The <paramref name="Offset" /> specifies the position of the sync within the update buffer converted to the mixer stream position.
            Note that the <paramref name="Offset" /> is based on the mixer's sample format, so you'll need to convert that to the source's format if using the sync to trigger things on the source.
            </para>
            <para>
            The usual restrictions on which BASS functions can be called that apply to stream callbacks (<see cref="T:ManagedBass.StreamProcedure" />) also apply here. 
            It is also unsafe to call <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> on the same channel from a mixtime sync callback.
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be used in a mixtime sync to implement custom looping, eg. set a <see cref="F:ManagedBass.SyncFlags.Position"/> sync at the loop end position and seek to the loop start position in the callback.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Midi.MidiEventsMode">
            <summary>
            The type of event data to apply, to be used with <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.IntPtr,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.Struct">
            <summary>
            An array of <see cref="T:ManagedBass.Midi.MidiEvent" /> structures (Default).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.Raw">
            <summary>
            Raw MIDI event data, as would be sent to a MIDI device. 
            Running status is supported.
            To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where +1 = the 1st channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.Sync">
            <summary>
            Trigger event syncs
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.NoRunningStatus">
            <summary>
            No running status
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiEventType">
            <summary>
            The MIDI event type, to be used with <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" /> or <see cref="M:ManagedBass.Midi.BassMidi.StreamGetEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType)" /> or <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.End">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)" /> to mark the end of the event array.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.None">
            <summary>
            No event.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Note">
            <summary>
            Press or release a key, or stop without sustain/decay.
            param : LOBYTE = key number (0-127, 60=middle C), HIBYTE = velocity (0=release, 1-127=press, 255=stop).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Program">
            <summary>
            Select the preset/instrument to use. Standard soundfont presets follow the
            General MIDI standard, and generally also include Roland GS variations in other banks (accessible via the <see cref="F:ManagedBass.Midi.MidiEventType.Bank"/> event).
            param : preset number (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChannelPressure">
            <summary>
            Set the channel pressure.
            param : pressure level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Pitch">
            <summary>
            Set the pitch wheel.
            param : pitch wheel position (0-16383, 8192=normal/middle).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.PitchRange">
            <summary>
            Set pitch wheel range (MIDI RPN 0).
            param : range in semitones.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Drums">
            <summary>
            Set the percussion/drums channel switch. 
            The bank and program are reset to 0 when this changes.
            param : use drums? (0=no, 1=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.FineTune">
            <summary>
            Set the fine tuning (MIDI RPN 1).
            param : finetune in cents (0-16383, 0=-100, 8192=normal, 16383=+100).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.CoarseTune">
            <summary>
            Set the coarse tuning (MIDI RPN 2).
            param : finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.MasterVolume">
            <summary>
            Set the master volume.
            param : volume level (0-16383, 0=silent, 16363=normal/full).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Bank">
            <summary>
            Select the bank to use (MIDI controller 0).
            param : bank number (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Modulation">
            <summary>
            Set the modulation (MIDI controller 1).
            param : modulation level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Volume">
            <summary>
            Set the volume (MIDI controller 7).
            param : volume level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Pan">
            <summary>
            Set the pan position (MIDI controller 10).
            param : pan position (0-128, 0=left, 64=middle, 127=right, 128=random).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Expression">
            <summary>
            Set the expression (MIDI controller 11).
            param : expression level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Sustain">
            <summary>
            Set the sustain switch (MIDI controller 64).
            param : enable sustain? (0-63=no, 64-127=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.SoundOff">
            <summary>
            Stop all sounds (MIDI controller 120).
            param : not used.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Reset">
            <summary>
            Reset controllers (MIDI controller 121), that is modulation=0, expression=127,
            sustain=0, pitch wheel=8192, channel pressure=0.
            param : not used.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.NotesOff">
            <summary>
            Release all keys (MIDI controller 123).
            param : not used.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Portamento">
            <summary>
            Set the portamento switch (MIDI controller 65).
            param : enable portamento? (0-63=no, 64-127=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.PortamentoTime">
            <summary>
            Set the portamento time (MIDI controller 5).
            param : portamento time (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.PortamentoNote">
            <summary>
            Set the portamento start key - the next note starts at this key (MIDI controller 84).
            param : key number (1-127, 60=middle C).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Mode">
            <summary>
            Set poly/mono mode (MIDI controllers 126 and 127).
            param : mode (0=poly, 1=mono).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Reverb">
            <summary>
            Set the reverb send level (MIDI controller 91).
            param : reverb level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Chorus">
            <summary>
            Set the chorus send level (MIDI controller 93).
            param : chorus level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.CutOff">
            <summary>
            Set the low-pass filter cutoff (MIDI controller 74, NRPN 120h).
            param : cutoff level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Resonance">
            <summary>
            Set the low-pass filter resonance (MIDI controller 71, NRPN 121h).
            param : resonance level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Release">
            <summary>
            Set the release time (MIDI controller 72, NRPN 166h).
            param : release time (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Attack">
            <summary>
            Set the attack time (MIDI controller 73, NRPN 163h).
            param : attack time (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbMacro">
            <summary>
            To be defined.
            param : to be defined.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusMacro">
            <summary>
            To be defined.
            param : to be defined.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbTime">
            <summary>
            Set the reverb time.
            param : reverb time in milliseconds.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbDelay">
            <summary>
            Set the reverb delay.
            param : reverb delay in millisecond 10ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbLowPassCutOff">
            <summary>
            Set the reverb low-pass cutoff.
            param : reverb low-pass cutoff in hertz (0=off).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbHighPassCutOff">
            <summary>
            Set the reverb high-pass cutoff.
            param : reverb high-pass cutoff in hertz (0=off).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbLevel">
            <summary>
            Set the reverb level.
            param : reverb level (0=off, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusDelay">
            <summary>
            Set the chorus delay.
            param : chorus delay in millisecond 10ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusDepth">
            <summary>
            Set the chorus depth.
            param : chorus depth in millisecond 10ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusRate">
            <summary>
            Set the chorus rate.
            param : chorus rate in hertz 100ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusFeedback">
            <summary>
            Set the chorus feedback level.
            param : chorus feedback level (0=-100%, 100=off, 200=+100%).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusLevel">
            <summary>
            Set the chorus level.
            param : chorus level (0=off, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusReverb">
            <summary>
            Set the chorus send to reverb level.
            param : chorus send to reverb level (0=off, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumFineTune">
            <summary>
            Set the fine tuning of a drum key (MIDI NRPN 19knh).
            param : LOBYTE = key number (0-127), HIBYTE = finetune in cents (0-127, 0=-100, 64=normal, 127=+100).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumCoarseTune">
            <summary>
            Set the coarse tuning of a drum key (MIDI NRPN 18knh).
            param : LOBYTE = key number (0-127), HIBYTE = finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumPan">
            <summary>
            Set the pan position of a drum key (MIDI NRPN 1Cknh).
            param : LOBYTE = key number (0-127), HIBYTE = pan position (0-127, 0=random, 64=middle).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumReverb">
            <summary>
            Set the reverb send level of a drum key (MIDI NRPN 1Dknh).
            param : LOBYTE = key number (0-127), HIBYTE = reverb level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumChorus">
            <summary>
            Set the chorus send level of a drum key (MIDI NRPN 1Eknh).
            param : LOBYTE = key number (0-127), HIBYTE = chorus level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumCutOff">
            <summary>
            Set the low-pass filter cutoff of a drum key (MIDI NRPN 14knh).
            param : LOBYTE = key number (0-127), HIBYTE = cutoff level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumResonance">
            <summary>
            Set the low-pass filter resonance of a drum key (MIDI NRPN 15knh).
            param : LOBYTE = key number (0-127), HIBYTE = resonance level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumLevel">
            <summary>
            Set the drum level NRPN of a drum key (MIDI NRPN 16knh).
            param : LOBYTE = key number (0-127), HIBYTE = level (0-127, 127=full/normal).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Soft">
            <summary>
            Set the soft pedal/switch (MIDI controller 67).
            param : soft is on? (0-63=no, 64-127=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.System">
            <summary>
            Set the system mode, resetting everything to the system's defaults.
            <see cref="F:ManagedBass.Midi.MidiSystem.Default"/> is identical to <see cref="F:ManagedBass.Midi.MidiSystem.GS"/>, except that channel 10 is melodic if there are not 16 channels.
            This does not reset things in any additional channels allocated to a MIDI file stream via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute,
            while <see cref="F:ManagedBass.Midi.MidiEventType.SystemEx"/> does.
            param : system mode (see <see cref="T:ManagedBass.Midi.MidiSystem"/>).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Tempo">
            <summary>
            Set the tempo (MIDI meta event 81).
            Changing the tempo affects the stream Length, and the <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)"/> value will no longer be valid.
            param : tempo in microseconds per quarter note.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ScaleTuning">
            <summary>
            Set the tuning of a note in every octave.
            param : LOWORD = tuning change in cents (0-16383, 0=-100, 8192=normal, 16383=+100), HIWORD = note (0-11, 0=C).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Control">
            <summary>
            Control event.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetVibrato">
            <summary>
            Change Preset Vibrato.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetPitch">
            <summary>
            Change Preset Pitch.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetFilter">
            <summary>
            Change Preset Filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetVolume">
            <summary>
            Change Preset Volume.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ModRange">
            <summary>
            Mod Range.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.BankLSB">
            <summary>
            Bank LSB.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Level">
            <summary>
            Set the level.
            param : the level (0=silent, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Transpose">
            <summary>
            Transpose all notes. 
            Changes take effect from the next note played, and affect melodic channels only (not drum channels).
            param : transposition amount in semitones (0=-100, 100=normal, 200=+100).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.SystemEx">
            <summary>
            Set the system mode, resetting everything to the system's defaults. 
            <see cref="F:ManagedBass.Midi.MidiSystem.Default"/> is identical to <see cref="F:ManagedBass.Midi.MidiSystem.GS"/>, except that channel 10 is melodic if there are not 16 channels.
            <see cref="F:ManagedBass.Midi.MidiEventType.System"/> does not reset things in any additional channels allocated to a MIDI file stream 
            via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute, while this does.
            param : system mode (see <see cref="T:ManagedBass.Midi.MidiSystem"/>).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.EndTrack">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)"/> to mark the end of a track (the next event will be in a new track).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.NoRunningStatus">
            <summary>
            Flag: no running status.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiMarkerType">
            <summary>
            The Marker type, to be used with <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Marker">
            <summary>
            Marker events (MIDI meta event 6).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.CuePoint">
            <summary>
            Cue events (MIDI meta event 7).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Lyric">
            <summary>
            Lyric events (MIDI meta event 5).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Text">
            <summary>
            Text events (MIDI meta event 1).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.TimeSignature">
            <summary>
            Time signature event (MIDI meta event 88).
            The time signature events are given in the form of "numerator/denominator metronome-pulse 32nd-notes-per-MIDI-quarter-note", eg. "4/4 24 8".
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.KeySignature">
            <summary>
            Key signature events (MIDI meta event 89).
            That gives the key signature (in <see cref="P:ManagedBass.Midi.MidiMarker.Text"/>) in the form of "a b", where "a" is the number of sharps (if positive) or flats (if negative) and "b" signifies major (if 0) or minor (if 1).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Copyright">
            <summary>
            Copyright notice (MIDI meta event 2).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.TrackName">
            <summary>
            Track name events (MIDI meta event 3).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.InstrumentName">
            <summary>
            Instrument name events (MIDI meta event 4). 
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Tick">
            <summary>
            FLAG: get position in ticks instead of bytes
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiSystem">
            <summary>
            System mode parameter, to be used with <see cref="F:ManagedBass.Midi.MidiEventType.System" />, <see cref="F:ManagedBass.Midi.MidiEventType.SystemEx" />.
            </summary>
            <remarks>
            <see cref="F:ManagedBass.Midi.MidiSystem.Default"/> is identical to <see cref="F:ManagedBass.Midi.MidiSystem.GS"/>, except that channel 10 is melodic if there are not 16 channels.
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.Default">
            <summary>
            System default. 
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.GM1">
            <summary>
            General MIDI Level 1.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.GM2">
            <summary>
            General MIDI Level 2.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.XG">
            <summary>
            XG-Format (Yamaha).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.GS">
            <summary>
            GS-Format (Roland).
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiInProcedure">
            <summary>
            User defined callback delegate to receive MIDI data (to be used with <see cref="M:ManagedBass.Midi.BassMidi.InInit(System.Int32,ManagedBass.Midi.MidiInProcedure,System.IntPtr)" />).
            </summary>
            <param name="Device">The MIDI input device that the data is from.</param>
            <param name="Time">Timestamp, in seconds since <see cref="M:ManagedBass.Midi.BassMidi.InStart(System.Int32)" /> was called.</param>
            <param name="Buffer">Pointer to the MIDI data.</param>
            <param name="Length">The amount of data in bytes.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Midi.BassMidi.InInit(System.Int32,ManagedBass.Midi.MidiInProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Midi.BassMidi">
            <summary>
            Wraps BassMidi: bassmidi.dll
            
            <para>Supports: .midi, .mid, .rmi, .kar</para>
            </summary>
            <summary>
            Wraps BassMidi: bassmidi.dll
            
            <para>Supports: .midi, .mid, .rmi, .kar</para>
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.ChorusChannel">
            <summary>
            Chorus Mix Channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.ReverbChannel">
            <summary>
            Reverb Mix Channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.UserFXChannel">
            <summary>
            User FX Channel.
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Creates a sample stream to render real-time MIDI events.
            </summary>
            <param name="Channels">The number of MIDI channels: 1 (min) - 128 (max).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call; 1 = the device's current output rate or the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function creates a stream solely for real-time MIDI events.
            As it's not based on any file, the stream has no predetermined length and is never-ending.
            Seeking isn't possible, but it is possible to reset everything, including playback buffer, by calling <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (Restart = <see langword="true" />) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (Position = 0).
            </para>
            <para>
            MIDI events are applied using the <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" /> function.
            If the stream is being played (it's not a decoding channel), then there will be some delay in the effect of the events being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> and <see cref="P:ManagedBass.Bass.UpdatePeriod" /> options.
            </para>
            <para>
            If a stream has 16 MIDI channels, then channel 10 defaults to percussion/drums and the rest melodic, otherwise they are all melodic.
            That can be changed using <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" /> and <see cref="F:ManagedBass.Midi.MidiEventType.Drums"/>.
            </para>
            <para>
            Soundfonts provide the sounds that are used to render a MIDI stream.
            A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" />.
            </para>
            <para>To play a MIDI file, use <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)" />.</para>
            <para><b>Platform-specific</b></para>
            <para>
            On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the <see cref="F:ManagedBass.BassFlags.SincInterpolation"/> flag will otherwise be ignored.
            Sinc interpolation is not available on Windows CE.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Channels" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker Flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Creates a sample stream from a sequence of MIDI events.
            </summary>
            <param name="Events">An array of <see cref="T:ManagedBass.Midi.MidiEvent" />s containing the event sequence to play (the array should be terminated with a <see cref="F:ManagedBass.Midi.MidiEventType.End"/> event).</param>
            <param name="PulsesPerQuarterNote">The number of pulses per quarter note (or ticks per beat) value of the MIDI stream to create.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call; 1 = the device's current output rate (or the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function creates a 16 channel MIDI stream to play a predefined sequence of MIDI events.
            Any of the standard MIDI events can be used, but <see cref="F:ManagedBass.Midi.MidiEventType.Level"/>, <see cref="F:ManagedBass.Midi.MidiEventType.Transpose"/>, and <see cref="F:ManagedBass.Midi.MidiEventType.SystemEx"/> events are not available and will be ignored.
            The sequence should end with a <see cref="F:ManagedBass.Midi.MidiEventType.End"/> event.
            Multiple tracks are possible via the <see cref="F:ManagedBass.Midi.MidiEventType.EndTrack"/> event, which signals the end of a track; the next event will be in a new track.
            Any <see cref="F:ManagedBass.Midi.MidiEventType.Tempo"/> events should be in the first track.
            </para>
            <para>The event sequence is copied, so the events array does not need to persist beyond the function call.</para>
            <para>
            Soundfonts provide the sounds that are used to render a MIDI stream.
            A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overridden using <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" />.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the <see cref="F:ManagedBass.BassFlags.SincInterpolation"/> flag will otherwise be ignored.
            Sinc interpolation is not available on Windows CE.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.NoInternet">No internet connection could be opened. Can be caused by a bad <see cref="P:ManagedBass.Bass.NetProxy"/> setting.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Events" /> are not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with the <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker Flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the event to (as returned by <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)" />).</param>
            <param name="Channel">The MIDI channel to apply the event to... 0 = channel 1.</param>
            <param name="Event">The event to apply (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="Parameter">The event parameter (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>
            Except for the "non-MIDI" events, events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute.
            </para>
            <para>
            Event syncs (see <see cref="T:ManagedBass.SyncFlags" />) are not triggered by this function.
            If sync triggering is wanted, <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)" /> can be used instead.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One of the other parameters is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Byte,System.Byte)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the event to (as returned by <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)" />).</param>
            <param name="Channel">The MIDI channel to apply the event to... 0 = channel 1.</param>
            <param name="Event">The event to apply (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="LowParameter">The event parameter (LOBYTE), (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="HighParameter">The event parameter (HIBYTE), (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>
            Except for the "non-MIDI" events, events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute.
            </para>
            <para>
            Event syncs (see <see cref="T:ManagedBass.SyncFlags" />) are not triggered by this function.
            If sync triggering is wanted, <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)" /> can be used instead.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One of the other parameters is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.IntPtr,System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Events">The event data (raw data - byte[]).</param>
            <param name="Length">Length of Events data according to <paramref name="Mode"/>.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Events">The event data (an array of <see cref="T:ManagedBass.Midi.MidiEvent" /> structures).</param>
            <param name="Length">No of <see cref="T:ManagedBass.Midi.MidiEvent"/> items... 0 = No of items in <paramref name="Events"/> array.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.Byte[],System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Raw">The event data (raw data - byte[]).</param>
            <param name="Length">No of <see cref="T:System.Byte"/>s... 0 = No of items in <paramref name="Raw"/> array.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Channel">To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where 1 = the 1st channel - else leave to 0.</param>
            <param name="Raw">The event data (raw data - byte[]).</param>
            <param name="Length">No of <see cref="T:System.Byte"/>s... 0 = No of items in <paramref name="Raw"/> array.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetChannel(System.Int32,System.Int32)">
            <summary>
            Gets a HSTREAM handle for a MIDI channel (e.g. to set DSP/FX on individual MIDI channels).
            </summary>
            <param name="Handle">The midi stream to get a channel from.</param>
            <param name="Channel">The MIDI channel... 0 = channel 1. Or one of the following special channels:
            <para><see cref="F:ManagedBass.Midi.BassMidi.ChorusChannel"/> = Chorus mix channel. The default chorus processing is replaced by the stream's processing.</para>
            <para><see cref="F:ManagedBass.Midi.BassMidi.ReverbChannel"/> = Reverb mix channel. The default reverb processing is replaced by the stream's processing.</para>
            <para><see cref="F:ManagedBass.Midi.BassMidi.UserFXChannel"/> = User effect mix channel.</para>
            </param>
            <returns>If successful, the channel handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            By default, MIDI channels do not have streams assigned to them;
            a MIDI channel only gets a stream when this function is called, which it then keeps until the MIDI stream is freed. 
            MIDI channel streams can also be freed before then via <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" />.
            Each MIDI channel stream increases the CPU usage slightly, even if there are no DSP/FX set on them, so for optimal performance they should not be activated when unnecessary.
            </para>
            <para>
            The MIDI channel streams have a different path to the final mix than the BASSMIDI reverb/chorus processing, which means that the reverb/chorus will not be present in the data received by any DSP/FX set on the streams and nor will the reverb/chorus be applied to the DSP/FX output; 
            the reverb/chorus processing will use the channel's original data.
            </para>
            <para>
            The MIDI channel streams can only be used to set DSP/FX on the channels. 
            They cannot be used with <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> or <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" /> to visualise the channels, for example, 
            but that could be achieved via a DSP function instead.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType)">
            <summary>
            Retrieves the current value of an event in a MIDI stream channel.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the event from (as returned by <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)"/>.</param>
            <param name="Channel">The MIDI channel to get the event value from... 0 = channel 1.</param>
            <param name="Event">
            The event value to retrieve.
            With the drum key events (<see cref="F:ManagedBass.Midi.MidiEventType.DrumCutOff"/>/etc) and the <see cref="F:ManagedBass.Midi.MidiEventType.Note"/> and <see cref="F:ManagedBass.Midi.MidiEventType.ScaleTuning"/> events, the HIWORD can be used to specify which key/note to get the value from.</param>
            <returns>The event parameter if successful - else -1 (use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
            <remarks>SYNCs can be used to be informed of when event values change.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One of the other parameters is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetEvents(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,ManagedBass.Midi.MidiEvent[])">
            <summary>
            Retrieves the events in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to get the events from.</param>
            <param name="Track">The track to get the events from... 0 = 1st track.</param>
            <param name="Filter">The type of event to retrieve (use <see cref="F:ManagedBass.Midi.MidiEventType.None"/> to retrieve all events).</param>
            <param name="Events">An array of <see cref="T:ManagedBass.Midi.MidiEvent" />s to retrieve the events (<see langword="null" /> = get the number of events without getting the events themselves).</param>
            <returns>If successful, the number of events is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function should first be called with <paramref name="Events" /> = <see langword="null" /> to get the number of events, before allocating an array of the required size and retrieving the events.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is for real-time events only, so does not have an event sequence.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetEvents(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType)">
            <summary>
            Retrieves the events in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to get the events from.</param>
            <param name="Track">The track to get the events from... 0 = 1st track.</param>
            <param name="Filter">The type of event to retrieve (use <see cref="F:ManagedBass.Midi.MidiEventType.None"/> to retrieve all events).</param>
            <returns>An array of <see cref="T:ManagedBass.Midi.MidiEvent" /> configuration entries on success, <see langword="null" /> on error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is for real-time events only, so does not have an event sequence.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="Fonts">An <see cref="T:System.IntPtr"/> to retrieve the soundfont configuration.</param>
            <param name="Count">The maximum number of elements to retrieve. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="Fonts">An array to retrieve the soundfont configuration.</param>
            <param name="Count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:ManagedBass.Midi.MidiFont" /> configuration entries if successfull - or <see langword="null" /> on error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="Fonts">An array to retrieve the soundfont configuration.</param>
            <param name="Count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFontsEx(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:ManagedBass.Midi.MidiFontEx" /> configuration entries if successfull - or <see langword="null" /> on error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFontsCount(System.Int32)">
            <summary>
            Retrieves the number of elements in the soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the marker from.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <param name="Index">The marker to retrieve... 0 = the first.</param>
            <param name="Mark">The <see cref="T:ManagedBass.Midi.MidiMarker" /> structure to receive the marker details into.</param>
            <returns><see langword="true" /> on success, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The markers are ordered chronologically.
            <para>Syncs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a '/' (slash) character, that means a new line should be started.
            If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Index" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the marker from.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <param name="Index">The marker to retrieve... 0 = the first.</param>
            <returns>On success, an instance of the <see cref="T:ManagedBass.Midi.MidiMarker" /> structure is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The markers are ordered chronologically.
            <para>Syncs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a '/' (slash) character, that means a new line should be started.
            If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Index" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMarks(System.Int32,System.Int32,ManagedBass.Midi.MidiMarkerType,ManagedBass.Midi.MidiMarker[])">
            <summary>
            Retrieves the markers in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the markers from.</param>
            <param name="Track">The track to get the markers from... 0 = 1st track, -1 = all tracks.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <param name="Marks">An array of <see cref="T:ManagedBass.Midi.MidiMarker"/>s to receive the data into. Can be null to get the no of markers.</param>
            <returns>No of markers in the array on success, -1 on failure. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>The markers are ordered chronologically, and by track number (lowest first) if multiple markers have the same position.</para>
            <para>SYNCs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a / (slash) character, that means a new line should be started.
            If the text begins with a \ (backslash) character, the display should be cleared.
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMarks(System.Int32,System.Int32,ManagedBass.Midi.MidiMarkerType)">
            <summary>
            Retrieves the markers in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the markers from.</param>
            <param name="Track">The track to get the markers from... 0 = 1st track, -1 = all tracks.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <returns>On success, an array of <see cref="T:ManagedBass.Midi.MidiMarker" /> instances is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>The markers are ordered chronologically, and by track number (lowest first) if multiple markers have the same position.</para>
            <para>SYNCs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a / (slash) character, that means a new line should be started.
            If the text begins with a \ (backslash) character, the display should be cleared.
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)">
            <summary>
            Preloads the samples required by a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts.
            That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.
            </para>
            <para>Preloaded samples can be compacted/unloaded just like any other samples, so it is probably wise to disable the <see cref="P:ManagedBass.Midi.BassMidi.Compact"/> option when preloading samples, to avoid any chance of the samples subsequently being automatically unloaded.</para>
            <para>This function should not be used while the MIDI stream is being rendered, as that could interrupt the rendering.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is for real-time events only, so it's not possible to know what presets are going to be used. Use <see cref="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)" /> instead.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="Fonts">An array of <see cref="T:ManagedBass.Midi.MidiFont" /> soundfonts to apply.</param>
            <param name="Count">The number of elements in the fonts array.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Multiple soundfonts can be stacked, each providing different presets, for example.
            When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority.
            When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            When a preset is not available on a non-0 bank in any soundfont, BASSMIDI will try to fall back to bank 0; first the LSB and then the MSB if still unsuccessful.
            <para>
            Changing the default configuration only affects subsequently created MIDI streams.
            Existing streams that are using the previous default configuration will continue to use that previous configuration.
            </para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">Something in the <paramref name="Fonts" /> array is invalid, check the soundfont handles.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="Fonts">An array of <see cref="T:ManagedBass.Midi.MidiFontEx" /> soundfonts to apply.</param>
            <param name="Count">The number of elements in the fonts array.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Multiple soundfonts can be stacked, each providing different presets, for example.
            When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority.
            When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            When a preset is not available on a non-0 bank in any soundfont, BASSMIDI will try to fall back to bank 0; first the LSB and then the MSB if still unsuccessful.
            <para>
            Changing the default configuration only affects subsequently created MIDI streams.
            Existing streams that are using the previous default configuration will continue to use that previous configuration.
            </para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">Something in the <paramref name="Fonts" /> array is invalid, check the soundfont handles.</exception>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.Compact">
            <summary>
            Automatically compact all soundfonts following a configuration change?
            compact (bool): If true, all soundfonts are compacted following a MIDI stream being freed, or a <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)"/> call.
            The compacting isn't performed immediately upon a MIDI stream being freed or <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)"/> being called.
            It's actually done 2 seconds later (in another thread), 
            so that if another MIDI stream starts using the soundfonts in the meantime, they aren't needlessly closed and reopened.
            Samples that have been preloaded by <see cref="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)"/> are not affected by automatic compacting.
            Other samples that have been preloaded by <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)"/> are affected though,
            so it is probably wise to disable this option when using that function.
            By default, this option is enabled.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.AutoFont">
            <summary>
            Automatically load matching soundfonts?
            If set to 1 (default), BASSMIDI will try to load a soundfont matching the MIDI file. If set to 2, the matching soundfont will also be used on all banks. 
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.Voices">
            <summary>
            The maximum number of samples to play at a time (polyphony).
            voices (int): Maximum number of samples to play at a time... 1 (min) - 1000 (max).
            This setting determines the maximum number of samples that can play together in a single MIDI stream. 
            This isn't necessarily the same thing as the maximum number of notes, due to presets often layering multiple samples. 
            When there are no voices available to play a new sample, the voice with the lowest volume will be killed to make way for it.
            The more voices that are used, the more CPU that is required. 
            So this option can be used to restrict that, for example on a less powerful system. 
            The CPU usage of a MIDI stream can also be restricted via the <see cref="F:ManagedBass.ChannelAttribute.MidiCPU"/> attribute.
            Changing this setting only affects subsequently created MIDI streams, not any that have already been created. 
            The default setting is 128 voices.
            Platform-specific
            The default setting is 100, except on iOS, where it is 40.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.DefaultFont">
            <summary>
            Default soundfont usage
            filename (string): Filename of the default soundfont to use (null = no default soundfont).
            If the specified soundfont cannot be loaded, the default soundfont setting will remain as it is.
            On Windows, the default is to use one of the Creative soundfonts (28MBGM.SF2 or CT8MGM.SF2 or CT4MGM.SF2 or CT2MGM.SF2),
            if present in the windows system directory.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr,System.Int32)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr,System.Int32)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.InFree(System.Int32)">
            <summary>
            Frees a MIDI input device.
            </summary>
            <param name="Device">The device to free.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Init">The device has not been initialized.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.InGetDeviceInfo(System.Int32,ManagedBass.Midi.MidiDeviceInfo@)">
            <summary>
            Retrieves information on a MIDI input device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Midi.MidiDeviceInfo" /> class to store the information at.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available MIDI input devices for a setup dialog. 
            <para><b>Platform-specific</b></para>
            <para>MIDI input is not available on Android.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.InGetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a MIDI input device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>If successful, an instance of the <see cref="T:ManagedBass.Midi.MidiDeviceInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            This function can be used to enumerate the available MIDI input devices for a setup dialog.
            <para><b>Platform-specific</b></para>
            <para>MIDI input is not available on Android.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.InDeviceCount">
            <summary>
            Gets the number of MidiIn devices available.
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.InInit(System.Int32,ManagedBass.Midi.MidiInProcedure,System.IntPtr)">
            <summary>
            Initializes a MIDI input device.
            </summary>
            <param name="Device">The device to use... 0 = first. <see cref="M:ManagedBass.Midi.BassMidi.InGetDeviceInfo(System.Int32,ManagedBass.Midi.MidiDeviceInfo@)" /> can be used to enumerate the available devices.</param>
            <param name="Procedure">Callback delegate to receive MIDI data from the device.</param>
            <param name="User">User instance data to pass to the callback delegate.</param>
            <returns>If the device was successfully initialized, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before using any MIDI input functions.</para>
            <para><b>Platform-specific</b></para>
            <para>MIDI input is not available on Android.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The device has already been initialized. You must call <see cref="M:ManagedBass.Midi.BassMidi.InFree(System.Int32)" /> before you can initialize it again.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.InStart(System.Int32)">
            <summary>
            Starts a MIDI input device.
            </summary>
            <param name="Device">The device to start.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Init">The device has not been initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.InStop(System.Int32)">
            <summary>
            Stops a MIDI input device.
            </summary>
            <param name="Device">The device to stop.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Init">The device has not been initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontCompact(System.Int32)">
            <summary>
            Compact a soundfont's memory usage.
            </summary>
            <param name="Handle">The soundfont to get info on (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />)... 0 = all soundfonts.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Compacting involves freeing any samples that are currently loaded but unused.
            The amount of sample data currently loaded can be retrieved using <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontFree(System.Int32)">
            <summary>
            Frees a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to free (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont is freed, it is automatically removed from any MIDI streams that are using it.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="Handle">The soundfont to get info on (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />).</param>
            <param name="Info">An instance of <see cref="T:ManagedBass.Midi.MidiFontInfo"/> structure to store the information into.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="Handle">The soundfont to get info on (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />).</param>
            <returns>An instance of <see cref="T:ManagedBass.Midi.MidiFontInfo"/> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetPreset(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieves the name of a preset in a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to get the preset name from.</param>
            <param name="Preset">Preset number to load... -1 = all presets (the first encountered).</param>
            <param name="Bank">Bank number to load... -1 = all banks (the first encountered).</param>
            <returns>If successful, the requested preset name is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont does not contain the requested preset.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetPresets(System.Int32,System.Int32[])">
            <summary>
            Retrieves the presets in a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to get the preset name from.</param>
            <param name="Presets">The array to receive the presets.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The presets are delivered with the preset number in the LOWORD and the bank number in the HIWORD, and in numerically ascending order.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetPresets(System.Int32)">
            <summary>
            Retrieves the presets in a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to get the preset name from.</param>
            <returns>If successful, an array of presets is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The presets are delivered with the preset number in the LOWORD and the bank number in the HIWORD, and in numerically ascending order.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetVolume(System.Int32)">
            <summary>
            Retrieves a soundfont's volume level.
            </summary>
            <param name="Handle">The soundfont to get the volume of.</param>
            <returns>If successful, the soundfont's volume level is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontInit(System.String)">
            <summary>
            Initializes a soundfont from a file (unicode).
            </summary>
            <param name="File">The file name of the sound font (e.g. an .sf2 file).</param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASSMIDI uses SF2 and/or SFZ soundfonts to provide the sounds to use in the rendering of MIDI files.
            Several soundfonts can be found on the internet, including a couple on the BASS website.
            </para>
            <para>
            A soundfont needs to be initialized before it can be used to render MIDI streams.
            Once initialized, a soundfont can be assigned to MIDI streams using the <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" /> function.
            A single soundfont can be shared by multiple MIDI streams.
            </para>
            <para>Information on the initialized soundfont can be retrieved using <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" />.</para>
            <para>If a soundfont is initialized multiple times, each instance will have its own handle but share the same sample/etc data.</para>
            <para>
            Soundfonts use PCM sample data as standard, but BASSMIDI can accept any format that is supported by BASS or its add-ons.
            The FontPack function can be used to compress the sample data in SF2 files.
            SFZ samples are in separate files and can be compressed using standard encoding tools.
            </para>
            <para>Using soundfonts that are located somewhere other than the file system is possible via <see cref="M:ManagedBass.Midi.BassMidi.FontInit(ManagedBass.FileProcedures,System.IntPtr,ManagedBass.BassFlags)" />.</para>
            <para><b>SFZ support</b></para>
            <para>
            The following SFZ opcodes are supported: ampeg_attack, ampeg_decay, ampeg_delay, ampeg_hold, ampeg_release, ampeg_sustain, ampeg_vel2attack, ampeg_vel2decay, amplfo_delay/fillfo_delay/pitchlfo_delay, amplfo_depth, amplfo_freq/fillfo_freq/pitchlfo_freq, amp_veltrack, cutoff, effect1, effect2, end, fileg_attack/pitcheg_attack, fileg_decay/pitcheg_decay, fileg_delay/pitcheg_delay, fileg_depth, fileg_hold/pitcheg_hold, fileg_release/pitcheg_release, fileg_sustain/pitcheg_sustain, fileg_vel2depth, fillfo_depth, fil_veltrack, group, hikey, hivel, key, lokey, loop_end, loop_mode, loop_start, lovel, offset, off_by, pan, pitcheg_depth, pitchlfo_depth, pitch_keycenter, pitch_keytrack, pitch_veltrack, resonance, sample, seq_length, seq_position, transpose, tune, volume. 
            The fil_type opcode is also supported, but only to confirm that a low pass filter is wanted (the filter will be disabled otherwise). 
            The combined EG and LFO entries in the opcode list reflect that there is a shared EG for pitch/filter and a shared LFO for amplitude/pitch/filter, as is the case in SF2. 
            Information on these (and other) SFZ opcodes can be found at www.sfzformat.com.
            </para>
            <para><b>Platform-specific</b></para>
            <para>The <see cref="F:ManagedBass.BassFlags.MidiFontMemoryMap"/> option is not available on big-endian systems (eg. PowerPC) as a soundfont's little-endian sample data cannot be played directly from a mapping; its byte order needs to be reversed.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontInit(ManagedBass.FileProcedures,System.IntPtr,ManagedBass.BassFlags)">
            <summary>
            Initializes a soundfont via user callback functions.
            </summary>
            <param name="Procedures">The user defined file function (see <see cref="T:ManagedBass.FileProcedures" />).</param>
            <param name="User">User instance data to pass to the callback functions.</param>
            <param name="Flags">Unused.</param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The unbuffered file system (<see cref="F:ManagedBass.StreamSystem.NoBuffer"/>) is always used by this function.</remarks>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)">
            <summary>
            Preloads presets from a soundfont.
            </summary>
            <param name="Handle">The soundfont handle.</param>
            <param name="Preset">Preset number to load... -1 = all presets.</param>
            <param name="Bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts.
            That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.
            </para>
            <para>When preloading samples to render a particular MIDI stream, it is more efficient to use <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)" /> to preload the specific samples that the MIDI stream will use, rather than preloading the entire soundfont.</para>
            <para>Samples that are preloaded by this function are not affected by automatic compacting via the <see cref="P:ManagedBass.Midi.BassMidi.Compact" /> option, but can be compacted/unloaded manually with <see cref="M:ManagedBass.Midi.BassMidi.FontCompact(System.Int32)" />.</para>
            <para>A soundfont should not be preloaded while it's being used to render any MIDI streams, as that could delay the rendering.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The appropriate add-on to decode the samples is not loaded.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont does not contain the requested preset.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontPack(System.Int32,System.String,System.String,ManagedBass.BassFlags)">
            <summary>
            Produces a compressed version of a soundfont.
            </summary>
            <param name="Handle">The soundfont to pack.</param>
            <param name="OutFile">Filename for the packed soundfont.</param>
            <param name="Encoder">Encoder command-line.</param>
            <param name="Flags">Any combination of <see cref="F:ManagedBass.BassFlags.MidiNoHeader"/> and <see cref="F:ManagedBass.BassFlags.Midi16Bit"/>.</param>
            <returns>If successful, the <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Standard soundfonts use PCM samples, so they can be quite large, which can be a problem if they're to be distributed. 
            To reduce the size, BASSMIDI can compress the samples using any command-line encoder with STDIN and STDOUT support. 
            Packed soundfonts can be used for rendering by BASSMIDI just like normal soundfonts. 
            They can also be unpacked using <see cref="M:ManagedBass.Midi.BassMidi.FontUnpack(System.Int32,System.String)" />.
            <para>
            Although any command-line encoder can be used, it is best to use a lossless format like FLAC or WavPack, rather than a lossy one like OGG or MP3. 
            Using a lossless encoder, the packed soundfont will produce exactly the same results as the original soundfont, and will be identical to the original when unpacked. 
            As a compromise between quality and size, the WavPack hybrid/lossy mode also produces good sounding results.
            </para>
            <para>The encoder must be told (via the command-line) to expect input from STDIN and to send it's output to STDOUT.</para>
            <para>
            Before using a packed soundfont, the appropriate BASS add-on needs to be loaded via <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />. 
            For example, if the samples are FLAC encoded, BASSFLAC would need to be loaded.
            During rendering, the samples are unpacked as they're needed, which could result in CPU spikes. 
            Where smooth performance is critical, it may be wise to preload the samples using <see cref="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)" /> or <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)" />.
            </para>
            <para>
            A soundfont should not be packed while it is being used to render any MIDI streams, as that could delay the rendering. 
            This function only applies to SF2 soundfonts.
            SFZ samples can be compressed using standard encoding tools.
            </para>
            <para><b>Platform-specific</b></para>
            <para>This function is not available on iOS or Android.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">Couldn't start the encoder. Check that the executable exists.</exception>
            <exception cref="F:ManagedBass.Errors.Create">Couldn't create the output file, <paramref name="OutFile" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontSetVolume(System.Int32,System.Single)">
            <summary>
            Sets a soundfont's volume level.
            </summary>
            <param name="Handle">The soundfont to set the volume of.</param>
            <param name="Volume">The volume level... 0=silent, 1.0=normal/default.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            By default, some soundfonts may be louder than others, which could be a problem when mixing multiple soundfonts. 
            This function can be used to compensate for any differences, by raising the level of the quieter soundfonts or lowering the louder ones.
            <para>Changes take immediate effect in any MIDI streams that are using the soundfont.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontUnload(System.Int32,System.Int32,System.Int32)">
            <summary>
            Unloads presets from a soundfont.
            </summary>
            <param name="Handle">The soundfont handle.</param>
            <param name="Preset">Preset number to load... -1 = all presets.</param>
            <param name="Bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            An unloaded preset will be loaded again when needed by a MIDI stream.
            Any samples that are currently being used by a MIDI stream will not be unloaded.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont does not contain the specified preset, or the soundfont is memory mapped.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontUnpack(System.Int32,System.String)">
            <summary>
            Produces a decompressed version of a packed soundfont.
            </summary>
            <param name="Handle">The soundfont to unpack.</param>
            <param name="OutFile">Filename for the unpacked soundfont.</param>
            <returns>If successful, the <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            To unpack a soundfont, the appropriate BASS add-on needs to be loaded (via <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />) to decode the samples. 
            For example, if the samples are FLAC encoded, BASSFLAC would need to be loaded. 
            BASS also needs to have been initialized, using <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />. 
            For just unpacking a soundfont, the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> could be used.
            <para>
            A soundfont should not be unpacked while it is being used to render any MIDI streams, as that could delay the rendering.
            <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" /> can be used to check if a soundfont is packed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont is not packed.</exception>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called - it needs to be to decode the samples.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The appropriate add-on to decode the samples is not loaded.</exception>
            <exception cref="F:ManagedBass.Errors.Create">Couldn't create the output file, <paramref name="OutFile" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="T:ManagedBass.Midi.MidiDeviceInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.InGetDeviceInfo(System.Int32,ManagedBass.Midi.MidiDeviceInfo@)" /> to retrieve information on a MIDI input device.
            </summary>
            <remarks>
            <para>
            On Windows, <see cref="P:ManagedBass.Midi.MidiDeviceInfo.ID"/> consists of a manufacturer identifier in the LOWORD and a product identifier in the HIWORD.
            This will not uniquely identify a particular device, ie. multiple devices may have the same value..
            On OSX, <see cref="P:ManagedBass.Midi.MidiDeviceInfo.ID"/> is the device's "kMIDIPropertyUniqueID" property value, which is unique to the device.
            On Linux, id contains the device's ALSA client ID in the LOWORD and port ID in the HIWORD.</para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Midi.MidiDeviceInfo.ID">
            <summary>
            An identification number.
            </summary>
            <remarks>
            On Windows, <see cref="P:ManagedBass.Midi.MidiDeviceInfo.ID"/> consists of a manufacturer identifier in the LOWORD and a product identifier in the HIWORD.
            This will not uniquely identify a particular device, ie. multiple devices may have the same value..
            On OSX, <see cref="P:ManagedBass.Midi.MidiDeviceInfo.ID"/> is the device's "kMIDIPropertyUniqueID" property value, which is unique to the device.
            On Linux, id contains the device's ALSA client ID in the LOWORD and port ID in the HIWORD.
            </remarks>
        </member>
        <member name="P:ManagedBass.Midi.MidiDeviceInfo.Name">
            <summary>
            The name/description of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiDeviceInfo.IsEnabled">
            <summary>
            Gets whether the device is enabled.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiDeviceInfo.IsInitialized">
            <summary>
            Gets whether the device is already initialized.
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.MidiDeviceInfo.ToString">
            <summary>
            Returns the Name of the Device.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiEvent">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)"/> to apply events and <see cref="M:ManagedBass.Midi.BassMidi.StreamGetEvents(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,ManagedBass.Midi.MidiEvent[])"/> to retrieve events, and <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)"/> to play event sequences.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.EventType">
            <summary>
            The Event Type
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Parameter">
            <summary>
            The Event Parameter
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Channel">
            <summary>
            The MIDI Channel of the event... 0 = channel 1
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Ticks">
            <summary>
            The Position of the event, in ticks
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Position">
            <summary>
            The Position of the event, in bytes
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiFont">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" /> and <see cref="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" /> to set and retrieve soundfont configurations.
            </summary>
            <remarks>
            When using an individual preset from a soundfont, BASSMIDI will first look for the exact preset and bank match, but if that is not present, the first preset from the soundfont will be used.
            This is useful for single preset soundfonts.
            Individual presets can be assigned to program numbers beyond the standard 127 limit, up to 65535, which can then be accessed via <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)"/>.
            <para>
            When using all presets in a soundfont, the bank member is a base number that is added to the soundfont's banks.
            For example, if bank=1 then the soundfont's bank 0 becomes bank 1, etc.
            Negative base numbers are allowed.
            </para>
            <para>For more flexible mapping of soundfont presets to MIDI programs, see the <see cref="T:ManagedBass.Midi.MidiFontEx" /> structure.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiFont.Handle">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFont.Preset">
            <summary>
            Preset number... 0-65535, -1 = use all presets in the soundfont.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Program"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFont.Bank">
            <summary>
            Base bank number, or the bank number of the individual preset.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Bank"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiFontEx">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)" /> and <see cref="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)" /> to set and retrieve soundfont configurations.
            </summary>
            <remarks>
            This is an extended version of the <see cref="T:ManagedBass.Midi.MidiFont" /> structure that allows more flexible mapping of soundfont presets to MIDI programs, including access to the bank LSB (eg. MIDI controller 32).
            <para>
            When using an individual preset from a soundfont, BASSMIDI will first look for the exact <see cref="F:ManagedBass.Midi.MidiFontEx.SoundFontPreset"/> and <see cref="F:ManagedBass.Midi.MidiFontEx.SoundFontBank"/> match, but if that is not present, the first preset from the soundfont will be used.
            This is useful for single preset soundfonts.
            Individual presets can be assigned to program numbers beyond the standard 127 limit, up to 65535, which can then be accessed via <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" />.
            </para>
            <para>
            When using all presets from all banks in a soundfont, the <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBank"/> member is a base number that is added to the soundfont's banks.
            For example, if <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBank"/> = 1 then the soundfont's bank 0 becomes bank 1, etc.
            Negative base numbers are allowed, to lower a soundfont's bank numbers.
            </para>
            <para>
            The bank LSB raises the maximum number of melodic banks from 128 to 16384 (128 x 128).
            But, the SF2 soundfont format only supports 128 banks.
            So a soundfont that is set to be used on all banks (<see cref="F:ManagedBass.Midi.MidiFontEx.DestinationPreset"/> and <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBank"/> are -1) will still only apply to the single bank LSB specified by <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBankLSB"/>.
            </para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.Handle">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.SoundFontPreset">
            <summary>
            Soundfont preset number... 0-127, -1 = use all presets.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.SoundFontBank">
            <summary>
            Soundfont bank number... 0-128, -1 = use all banks.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.DestinationPreset">
            <summary>
            Destination preset/program number... 0-65535, -1 = all presets.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Program"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.DestinationBank">
            <summary>
            Destination bank number, or a base bank number when using all presets from all banks.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Bank"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.DestinationBankLSB">
            <summary>
            Destination bank number LSB.
            This is the <see cref="F:ManagedBass.Midi.MidiEventType.BankLSB"/> event value that the soundfont is used for.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiFontInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" /> to retrieve information on a soundfont.
            </summary>
            <remarks>
            The <see cref="P:ManagedBass.Midi.MidiFontInfo.Name"/>, <see cref="P:ManagedBass.Midi.MidiFontInfo.Copyright"/> and <see cref="P:ManagedBass.Midi.MidiFontInfo.Comment"/> information might not be included in some SF2 files. 
            Only the <see cref="F:ManagedBass.Midi.MidiFontInfo.Presets"/>, <see cref="F:ManagedBass.Midi.MidiFontInfo.SampleDataLoaded"/> and <see cref="F:ManagedBass.Midi.MidiFontInfo.SampleDataType"/> members are available with SFZ files, with the <see cref="F:ManagedBass.Midi.MidiFontInfo.SampleDataType"/> value reflecting the most recently loaded encoded sample (it is possible for different samples to use different encoding).
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.Presets">
            <summary>
            The number of presets/instruments in the soundfont.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.SampleDataSize">
            <summary>
            The total size (in bytes) of the sample data in the soundfont.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.SampleDataLoaded">
            <summary>
            The amount of sample data currently loaded... -1 = the soundfont is memory mapped.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.SampleDataType">
            <summary>
            The <see cref="T:ManagedBass.ChannelType"/> format of the sample data if it's packed... -1 = Unknown format (appropriate BASS add-on not loaded), 0 = not packed.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiFontInfo.Name">
            <summary>
            Name of the soundfont.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiFontInfo.Copyright">
            <summary>
            Copyright notice.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiFontInfo.Comment">
            <summary>
            Any comments.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiMarker">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)" />, <see cref="F:ManagedBass.SyncFlags.MidiLyric" />, <see cref="F:ManagedBass.SyncFlags.MidiCue" /> and <see cref="F:ManagedBass.SyncFlags.MidiMarker" /> to retrieve markers.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiMarker.Text">
            <summary>
            The marker, cue, lyric, keysig, timesig text.
            </summary>
            <remarks>
            If the lyric text begins with a '/' (slash) character, a new line should be started. 
            If it begins with a '\' (backslash) character, the display should be cleared.
            <para>
            For a key signature event (MIDI meta event 89).
            The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).
            </para>
            <para>
            For a time signature events (MIDI meta event 88).
            The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Midi.MidiMarker.Track">
            <summary>
            The MIDI track (number) containing marker (0=first).
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiMarker.Position">
            <summary>
            The position (in bytes) of the marker.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BassFx">
            <summary>
            Wraps BassFx: bassfx.dll
            </summary>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Fx.BassFx.Version">
            <summary>
            Gets the Version of BassFx that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Creates a resampling stream from a decoding channel.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel (use <see cref="F:ManagedBass.BassFlags.Decode"/> when creating the channel).</param>
            <param name="Flags">A combination of the <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the tempo stream handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Multi-channels are supported.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The <paramref name="Channel" />'s format is not supported. Make sure the channel is either Stereo or Mono.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.TempoGetSource(System.Int32)">
            <summary>
            Get the source channel handle of the reversed stream.
            </summary>
            <param name="Channel">The handle of the reversed stream.</param>
            <returns>If successful, the handle of the source of the reversed stream is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.TempoGetRateRatio(System.Int32)">
            <summary>
            Get the ratio of the resulting rate and source rate (the resampling ratio).
            </summary>
            <param name="Channel">Tempo stream (or source channel) handle.</param>
            <returns>If successful, the resampling ratio is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.ReverseCreate(System.Int32,System.Single,ManagedBass.BassFlags)">
            <summary>
            Creates a reversed stream from a decoding channel.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="DecodingBlockLength">Length of decoding blocks in seconds. Larger blocks means less seeking overhead but larger spikes.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the handle of the reversed stream is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            MODs are supported, if <see cref="F:ManagedBass.BassFlags.Prescan"/> flag was applied to a source handle.
            <para>For better MP3/2/1 reverse playback create the source stream using the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag.</para>
            <para>
            Thes <see cref="F:ManagedBass.ChannelAttribute.ReverseDirection"/> attribute can either be applied to the reverse channel or the underlying decoding source channel.
            Note, that when playing the channel reverse, the end of a reverse stream is reached at the logial beginning of the stream (this also applies to <see cref="F:ManagedBass.SyncFlags.End"/>).
            By default stream's position will start from the end.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The <paramref name="Channel" />'s format is not supported. Make sure the channel is either Stereo or Mono.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.ReverseGetSource(System.Int32)">
            <summary>
            Get the source channel handle of the reversed stream.
            </summary>
            <param name="Channel">The handle of the reversed stream.</param>
            <returns>If successful, the handle of the source of the reversed stream is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)">
            <summary>
            Get the original BPM of a decoding channel.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="StartSec">Start detecting position in seconds (if less than 0 it uses the current position).</param>
            <param name="EndSec">End detecting position in seconds (greater than 0).</param>
            <param name="MinMaxBPM">Set min and max bpm, LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="Flags">One of <see cref="F:ManagedBass.BassFlags.FxBpmBackground"/>, <see cref="F:ManagedBass.BassFlags.FXBpmMult2"/> and <see cref="F:ManagedBass.BassFlags.FxFreeSource"/>.</param>
            <param name="Procedure">User defined function to receive the process in percents, use <see langword="null" /> if not in use.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the original BPM value is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The BPM detection algorithm works by detecting repeating low-frequency (less than 250Hz) sound patterns and thus works mostly with most rock/pop music with bass or drum beat. 
            The BPM detection doesn't work on pieces such as classical music without distinct, repeating bass frequency patterns.
            Also pieces with varying tempo, varying bass patterns or very complex bass patterns (jazz, hiphop) may produce odd BPM readings.
            </para>
            <para>
            In cases when the bass pattern drifts a bit around a nominal beat rate (e.g. drummer is again drunken ;-), the BPM algorithm may report incorrect harmonic one-halft to one-thirdth of the correct BPM value.
            In such case the system could for example report BPM value of 50 or 100 instead of correct BPM value of 150.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The <paramref name="Channel" />'s format is not supported. Make sure the channel is either Stereo or Mono.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Already">BPM detection, for this <paramref name="Channel" /> is already in use.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)">
            <summary>
            Enable getting BPM value by period of time in seconds.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Procedure">User defined function to receive the bpm value.</param>
            <param name="Period">Detection period in seconds.</param>
            <param name="MinMaxBPM">Set min and max bpm, LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="Flags">Use <see cref="F:ManagedBass.BassFlags.FXBpmMult2"/> or <see cref="F:ManagedBass.BassFlags.Default"/>.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description></description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description></description></item>
            <item><term>BASS_ERROR_ALREADY</term><description></description></item>
            </list>
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><see cref="F:ManagedBass.BassFlags.FXBpmMult2"/> already used on this handle.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMCallbackReset(System.Int32)">
            <summary>
            Reset the BPM buffers.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the BPM callback.
            The BPM callback is automatically reset by <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />, except when called from a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> <see cref="T:ManagedBass.SyncProcedure" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMFree(System.Int32)">
            <summary>
            Frees all resources used by a given handle.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Used together with <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)" />.
            If <see cref="F:ManagedBass.BassFlags.FxFreeSource"/> was used, this will also free the underlying decoding channel as well.
            You can't set/get this flag with <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />/<see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds of the decoded channel using a callback function.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="StartSec">Start detecting position in seconds.</param>
            <param name="EndSec">End detecting position in seconds (greater than 0).</param>
            <param name="Flags">Use one of <see cref="F:ManagedBass.BassFlags.FxBpmBackground"/> and <see cref="F:ManagedBass.BassFlags.FxFreeSource"/>.</param>
            <param name="Procedure">User defined function to receive the beat position values.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This method works pretty much as a mix of <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> and <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Already">Beat detection, for this <paramref name="Channel" /> is already in use.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds in real-time.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Procedure">User defined function to receive the beat position values.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This method works on real-time (buffered) as well as on decoding channels and might also be used together with Tempo channels.
            <para><see cref="M:ManagedBass.Fx.BassFx.BPMBeatFree(System.Int32)" /> must be called at the end to free the real-time beat position callback and resources.</para>
            <para>Note: You should call <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackReset(System.Int32)" /> after you have changed the position of the stream when called from a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> <see cref="T:ManagedBass.SyncProcedure" />.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatCallbackReset(System.Int32)">
            <summary>
            Reset the BPM buffers.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the BPM callback.
            The BPM callback is automatically reset by <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />, except when called from a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> <see cref="T:ManagedBass.SyncProcedure" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatSetParameters(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Set new values for beat detection parameters.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Bandwidth">Bandwidth in Hz between 0 and samplerate/2 (-1.0f = leave current, default is 10Hz).</param>
            <param name="CenterFreq">The center-frequency in Hz of the band pass filter between 0 and samplerate/2 (-1.0f = leave current, default is 90Hz).</param>
            <param name="Beat_rTime">Beat release time in ms. (-1.0f = leave current, default is 20ms).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter.
            A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="Bandwidth" /> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="CenterFreq" /> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="Beat_rTime" /> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set.
            So the <paramref name="Beat_rTime" /> should avoid, that a second (quickly repeated beat) beat is detected.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatGetParameters(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the current beat detection parameter values.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Bandwidth">Current bandwidth in Hz.</param>
            <param name="CenterFreq">Current center-frequency in Hz of the band pass filter.</param>
            <param name="Beat_rTime">Current beat release time in ms.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter.
            A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="Bandwidth" /> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="CenterFreq" /> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="Beat_rTime" /> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set.
            So the <paramref name="Beat_rTime" /> should avoid, that a second (quickly repeated beat) beat is detected.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatFree(System.Int32)">
            <summary>
            Free all resources used by a given handle (decode or callback beat).
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Used together with <see cref="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" />.
            <para>
            Note: If the <see cref="F:ManagedBass.BassFlags.FxFreeSource"/> flag is used, this will free the source decoding channel as well.
            You can't set/get this flag with <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" /> and <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="T:ManagedBass.Fx.AutoWahParameters">
            <summary>
            Parameters for AutoWah Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 1.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 2.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fRange">
            <summary>
            Sweep range in octaves (0&lt;...&lt;10). Default = 4.3.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 50.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.AutoWahParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BQFParameters">
            <summary>
            Parameters for BQF Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.lFilter">
            <summary>
            BQF Filter Type.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fCenter">
            <summary>
            Cut-off frequency (Center in PEAKINGEQ and Shelving filters) in Hz (1...info.freq/2). Default = 200Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB (used only for PEAKINGEQ and Shelving filters).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), Q is not in use (<see cref="F:ManagedBass.Fx.BQFParameters.fBandwidth"/> has priority over <see cref="F:ManagedBass.Fx.BQFParameters.fQ"/>). Default = 1 (0=not in use).
            The bandwidth in octaves (between -3 dB frequencies for <see cref="F:ManagedBass.Fx.BQFType.BandPass"/> and <see cref="F:ManagedBass.Fx.BQFType.Notch"/> or between midpoint (dBgain/2) gain frequencies for PEAKINGEQ).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fQ">
            <summary>
            EE kinda definition of Q (0.1...1...n), if <see cref="F:ManagedBass.Fx.BQFParameters.fBandwidth"/> is not in use. Default = 0.0 (0=not in use).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fS">
            <summary>
            A shelf slope parameter (linear, used only with Shelving filters) (0...1...n). Default = 0.0.
            When 1, the shelf slope is as steep as you can get it and remain monotonically increasing or decreasing gain with frequency.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.BQFParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.ChorusParameters">
            <summary>
            Parameters for Chorus Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.9
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.35.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fMinSweep">
            <summary>
            Minimum delay in ms (0&lt;...6000). Default = 1.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fMaxSweep">
            <summary>
            Maximum delay in ms (0&lt;...6000). Default = 400.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fRate">
            <summary>
            Rate in ms/s (0&lt;...1000). Default = 200.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.ChorusParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.CompressorParameters">
            <summary>
            Parameters for Compressor Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fGain">
            <summary>
            Output gain in dB of signal after compression, in the range from -60 to 60. Default = 5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fThreshold">
            <summary>
            Point in dB at which compression begins, in decibels, in the range from -60 to 0. Default = -15.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fRatio">
            <summary>
            Compression ratio, in the range from 1 to 100. Default = 3.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fAttack">
            <summary>
            Time in ms before compression reaches its full value, in the range from 0.01 to 500. Default = 20.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fRelease">
            <summary>
            Time (speed) in ms at which compression is stopped after Input drops below <see cref="F:ManagedBass.Fx.CompressorParameters.fThreshold"/>, in the range from 50 to 3000. Default = 200.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.CompressorParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.DampParameters">
            <summary>
            Parameters for Damp Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fTarget">
            <summary>
            Target volume level (0&lt;...1, linear).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fQuiet">
            <summary>
            Quiet volume level (0...1, linear). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fRate">
            <summary>
            Amplification adjustment rate (0...1, linear).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fGain">
            <summary>
            Amplification level (0...1...n, linear). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fDelay">
            <summary>
            Delay in seconds before increasing level (0...n, linear).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.DampParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.DistortionParameters">
            <summary>
            Parameters for Distortion Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fDrive">
            <summary>
            Distortion Drive (0...5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-5...+5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-5...+5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fFeedback">
            <summary>
            Feedback (-1...+1).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fVolume">
            <summary>
            Distortion volume (0...+2).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.DistortionParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.EchoParameters">
            <summary>
            Parameters for Echo Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fFeedback">
            <summary>
            Feedback (-1...+1).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fDelay">
            <summary>
            Delay in seconds (0+...6).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.bStereo">
            <summary>
            Echo adjoining channels to each other? Default is disabled.
            </summary>
            <remarks>Only allowed with even number of channels!
            <para>If enabled and a stream has an even number of channels then, each even channels will be echoed to each other.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.EchoParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.PeakEQParameters">
            <summary>
            Parameters for PeakEQ Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.lBand">
            <summary>
            Number of bands (0...n), more bands means more memory and cpu usage. Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), <see cref="F:ManagedBass.Fx.PeakEQParameters.fQ"/> is not in use (<see cref="F:ManagedBass.Fx.PeakEQParameters.fBandwidth"/> has priority over <see cref="F:ManagedBass.Fx.PeakEQParameters.fQ"/>). Default = 1 (0=not in use).
            <para>In most cases users should use the minimum of 0.5 octave.</para>
            <para>The bandwidth in octaves (between -3 dB frequencies for BPF and notch or between midpoint (dBgain/2) gain frequencies for peaking EQ).</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fQ">
            <summary>
            EE kinda definition of Q (0.1...1...n), if bandwidth is not in use. Default = 0.0 (0=not in use).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fCenter">
            <summary>
            Center frequency in Hz (1Hz...nHz). Default = 1000 (max. is 1/2 of the samplerate).
            </summary>
            <remarks>Use 'oldcenter * freq / oldfreq' to update the <see cref="F:ManagedBass.Fx.PeakEQParameters.fCenter"/> after changing the samplerate.</remarks>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.PeakEQParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.PhaserParameters">
            <summary>
            Parameters for Phaser Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fRange">
            <summary>
            Sweep range inoctaves (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.PhaserParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.PitchShiftParameters">
            <summary>
            Parameters for PitchShift Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.fPitchShift">
            <summary>
            A factor value which is between 0.5 (one octave down) and 2 (one octave up) (1 won't change the pitch, default).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.fSemitones">
            <summary>
            Semitones (0 won't change the pitch). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.lFFTsize">
            <summary>
            Defines the FFT frame size used for the processing. Typical values are 1024, 2048 (default) and 4096, max is 8192.
            </summary>
            <remarks>It may be any value up to 8192 but it MUST be a power of 2.</remarks>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.lOsamp">
            <summary>
            Is the STFT oversampling factor which also determines the overlap between adjacent STFT frames. Default = 8.
            </summary>
            <remarks>It should at least be 4 for moderate scaling ratios. A value of 32 is recommended for best quality (better quality = higher CPU usage).</remarks>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.PitchShiftParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.ReverbParameters">
            <summary>
            Parameters for Reverb Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (0.0...1.0, def. 0).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (0.0...3.0, def. 1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fRoomSize">
            <summary>
            Room size (0.0...1.0, def. 0.5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fDamp">
            <summary>
            Damping factor (0.0...1.0, def. 0.5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fWidth">
            <summary>
            Stereo width (0.0...1.0, def. 1.0).
            </summary>
            <remarks>It should at least be 4 for moderate scaling ratios. A value of 32 is recommended for best quality (better quality = higher CPU usage).</remarks>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.lMode">
            <summary>
            Mode: 0 = no freeze or 1 = freeze, def. 0 (no freeze).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.ReverbParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.RotateParameters">
            <summary>
            Parameters for Rotate Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.RotateParameters.fRate">
            <summary>
            Rotation rate/speed in Hz (A negative rate can be used for reverse direction).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.RotateParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.RotateParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BQFType">
            <summary>
            BassFx BiQuad filter type. Defines within the <see cref="T:ManagedBass.Fx.BQFParameters" /> structure which BiQuad filter should be used.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.LowPass">
            <summary>
            BiQuad Lowpass filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.HighPass">
            <summary>
            BiQuad Highpass filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.BandPass">
            <summary>
            BiQuad Bandpass filter (constant 0 dB peak gain).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.BandPassQ">
            <summary>
            BiQuad Bandpass Q filter (constant skirt gain, peak gain = Q).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.Notch">
            <summary>
            BiQuad Notch filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.AllPass">
            <summary>
            BiQuad All-Pass filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.PeakingEQ">
            <summary>
            BiQuad Peaking EQ filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.LowShelf">
            <summary>
            BiQuad Low-Shelf filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.HighShelf">
            <summary>
            BiQuad High-Shelf filter.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BPMBeatProcedure">
            <summary>
            User defined callback function, to get the Beat position in seconds.
            </summary>
            <param name="Channel">Handle that the <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> has applied to.</param>
            <param name="BeatPosition">The exact beat position in seconds.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Fx.BPMProcedure">
            <summary>
            User defined callback function, to auto get the BPM after each period of time in seconds.
            </summary>
            <param name="Channel">Handle that the <see cref="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)" /> applies to.</param>
            <param name="BPM">The new original bpm value.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Fx.BPMProgressProcedure">
            <summary>
            User defined callback function, to get the bpm detection process in percents.
            </summary>
            <param name="Channel">Channel that the <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" /> applies to.</param>
            <param name="Percent">The progress of the process in percent (0%..100%).</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Flac.BassFlac">
            <summary>
            Wraps BassFlac
            </summary> 
            <remarks>
            Supports .flac
            </remarks>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Flac.BassFlac.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Flac.BassFlac.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.Flac.CueSheetTrackType">
            <summary>
            Cue Sheet Track type to be used with <see cref="F:ManagedBass.Flac.FlacCueTrack.TrackFlags"/>
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.CueSheetTrackType.Audio">
            <summary>
            Audio
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.CueSheetTrackType.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.CueSheetTrackType.Pre">
            <summary>
            Pre
            </summary>
        </member>
        <member name="T:ManagedBass.Flac.FlacCueTag">
            <summary>
            Flac Cuesheet tag structure.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacCueTag.Catalog">
            <summary>
            The media catalog number.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTag.LeadInSampleCount">
            <summary>
            The number of lead-in samples.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTag.IsCD">
            <summary>
            The cuesheet corresponds to a CD?
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTag.TrackCount">
            <summary>
            The number of tracks.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacCueTag.Tracks">
            <summary>
            The array of tracks or <see langword="null" />.
            </summary>
        </member>
        <member name="M:ManagedBass.Flac.FlacCueTag.Read(System.Int32)">
            <summary>
            Reads the tag from a Channel.
            </summary>
        </member>
        <member name="T:ManagedBass.Flac.FlacCueTrack">
            <summary>
            Flac Cuesheet tag track structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTrack.Offset">
            <summary>
            Track offset in samples.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTrack.Number">
            <summary>
            The track number.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacCueTrack.ISRC">
            <summary>
            The International Standard Recording Code.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTrack.TrackFlags">
            <summary>
            The Track type.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTrack.IndexesCount">
            <summary>
            The number of indices.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacCueTrack.Indexes">
            <summary>
            The array of indices or <see langword="null" />.
            </summary>
        </member>
        <member name="T:ManagedBass.Flac.FlacCueTrackIndex">
            <summary>
            Flac Cuesheet tag Track Index structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTrackIndex.Offser">
            <summary>
            Index offset in samples relative to the track offset.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacCueTrackIndex.Number">
            <summary>
            The index number.
            </summary>
        </member>
        <member name="T:ManagedBass.Flac.FlacPictureTag">
            <summary>
            Flac Picture tag structure.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacPictureTag.Mime">
            <summary>
            The MIME type. This may be "--&gt;" to signify that data contains a URL of the picture rather than the picture data itself.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacPictureTag.Description">
            <summary>
            A description of the picture.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacPictureTag.Width">
            <summary>
            The width in pixels.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacPictureTag.Height">
            <summary>
            The height in pixels.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacPictureTag.Depth">
            <summary>
            The colour depth in bits-per-pixel.
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacPictureTag.Colors">
            <summary>
            The number of colours used for indexed-colour pictures (eg. GIF).
            </summary>
        </member>
        <member name="F:ManagedBass.Flac.FlacPictureTag.Length">
            <summary>
            The size of <see cref="P:ManagedBass.Flac.FlacPictureTag.Data" /> in bytes.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacPictureTag.Data">
            <summary>
            The picture data.
            </summary>
        </member>
        <member name="P:ManagedBass.Flac.FlacPictureTag.URL">
            <summary>
            Returns the image URL, if the <see cref="P:ManagedBass.Flac.FlacPictureTag.Mime" /> type is "--&gt;" - else <see langword="null" />.
            </summary>
        </member>
        <member name="M:ManagedBass.Flac.FlacPictureTag.Read(System.Int32,System.Int32)">
            <summary>
            Read the tag at an <param name="Index"/> from a <param name="Channel"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Ape.ApeBinaryTag">
            <summary>
            APE binary tag structure.
            </summary>
        </member>
        <member name="P:ManagedBass.Ape.ApeBinaryTag.Data">
            <summary>
            The binary tag data.
            </summary>
        </member>
        <member name="P:ManagedBass.Ape.ApeBinaryTag.Key">
            <summary>
            The name of the tag.
            </summary>
        </member>
        <member name="P:ManagedBass.Ape.ApeBinaryTag.Length">
            <summary>
            The size of data in bytes.
            </summary>
        </member>
        <member name="M:ManagedBass.Ape.ApeBinaryTag.Read(System.Int32,System.Int32)">
            <summary>
            Read a Tag.
            </summary>
            <param name="Channel">The Chanel to read the tag from.</param>
            <param name="Index">Index of tag.</param>
        </member>
        <member name="M:ManagedBass.Ape.ApeBinaryTag.ReadAll(System.Int32)">
            <summary>
            Read all APE binary tags
            </summary>
            <param name="Channel">The Chanel to read the tag from.</param>
        </member>
        <member name="M:ManagedBass.Ape.ApeBinaryTag.ToString">
            <summary>
            Returns the Key of the binary tag.
            </summary>
        </member>
        <member name="T:ManagedBass.Ape.BassApe">
            <summary>
            Wraps BassApe
            </summary> 
            <remarks>
            Supports .ape, .ap1
            </remarks>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Ape.BassApe.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Ape.BassApe.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassAc3">
            <summary>
            Wraps BassAc3
            </summary> 
            <remarks>
            Supports .ac3
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAc3.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAc3.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassAc3.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassAc3.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassAc3.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassAc3.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassAc3.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassAc3.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="P:ManagedBass.BassAc3.DRC">
            <summary>
            Enable Dynamic Range Compression (default is false).
            </summary>
        </member>
        <member name="T:ManagedBass.BassAlac">
            <summary>
            Wraps BassAlac
            </summary> 
            <remarks>
            Supports .m4a, .aac, .mp4, .mov
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAlac.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAlac.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassAlac.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassAlac.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassAlac.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassAlac.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassAlac.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassAlac.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassHls">
            <summary>
            Wraps BassHls
            </summary> 
            <remarks>
            HTTP Live Streaming Add-On
            </remarks>
        </member>
        <member name="M:ManagedBass.BassHls.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassHls.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassHls.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassHls.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassHls.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassHls.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassHls.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassHls.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassMpc">
            <summary>
            Wraps BassMpc
            </summary> 
            <remarks>
            Supports .mpc, .mpp, .mp+
            </remarks>
        </member>
        <member name="M:ManagedBass.BassMpc.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassMpc.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassMpc.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassMpc.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassMpc.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassMpc.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassMpc.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassMpc.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassOpus">
            <summary>
            Wraps BassOpus
            </summary> 
            <remarks>
            Supports .opus
            </remarks>
        </member>
        <member name="M:ManagedBass.BassOpus.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassOpus.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassOpus.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassOpus.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassOpus.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassOpus.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassOpus.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassOpus.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassSpx">
            <summary>
            Wraps BassSpx
            </summary> 
            <remarks>
            Supports .spx
            </remarks>
        </member>
        <member name="M:ManagedBass.BassSpx.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassSpx.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassSpx.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassSpx.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassSpx.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassSpx.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassSpx.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassSpx.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassTta">
            <summary>
            Wraps BassTta
            </summary> 
            <remarks>
            Supports .tta
            </remarks>
        </member>
        <member name="M:ManagedBass.BassTta.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassTta.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassTta.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassTta.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassTta.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassTta.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassTta.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassTta.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassWv">
            <summary>
            Wraps BassWv
            </summary> 
            <remarks>
            Supports .wv
            </remarks>
        </member>
        <member name="M:ManagedBass.BassWv.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassWv.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassWv.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassWv.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassWv.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassWv.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassWv.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassWv.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioNotifyProcedure">
            <summary>
            User defined notification callback function (to be used with <see cref="M:ManagedBass.Asio.BassAsio.SetNotify(ManagedBass.Asio.AsioNotifyProcedure,System.IntPtr)" />).
            </summary>
            <param name="Notify">The notification.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Asio.BassAsio.SetNotify(ManagedBass.Asio.AsioNotifyProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            When using multiple devices, <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> can be used to determine which the notification applies to.
            </remarks>
        </member>
        <member name="T:ManagedBass.Asio.AsioProcedure">
            <summary>
            User defined ASIO channel callback function (to be used with <see cref="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)" />).
            </summary>
            <param name="Input">Dealing with an Input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The Input/output channel number... 0 = first.</param>
            <param name="Buffer">The pointer to the Buffer containing the recorded data (Input channel), or in which to put the data to output (output channel).</param>
            <param name="Length">The number of bytes to process.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)" /> was called.</param>
            <returns>The number of bytes written (ignored with Input channels).</returns>
            <remarks>
            <para>ASIO is a low latency system, so a channel callback function should obviously be as quick as possible. <see cref="P:ManagedBass.Asio.BassAsio.CPUUsage" /> can be used to monitor that.</para>
            <para>
            When multiple channels are joined together, the sample data of the channels is interleaved;
            the channel that was enabled via <see cref="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)" /> comes first, followed by the channels that have been joined to it.
            The order of the joined channels defaults to numerically ascending order unless the <see cref="F:ManagedBass.Asio.AsioInitFlags.JoinOrder"/> flag was used in the <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> call,
            in which case they will be in the order in which <see cref="M:ManagedBass.Asio.BassAsio.ChannelJoin(System.Boolean,System.Int32,System.Int32)" /> was called to join then.
            </para>
            <para>
            When an output channel's function returns less data than requested, the remainder of the Buffer is filled with silence, and some processing is saved by that. 
            When 0 is returned, the level of processing is the same as if the channel had been paused with <see cref="M:ManagedBass.Asio.BassAsio.ChannelPause(System.Boolean,System.Int32)" />, ie. the ASIO Buffer is simply filled with silence and all additional processing (resampling/etc) is bypassed.
            </para>
            <para>
            ASIO is a low latency system, so a channel callback function should obviously be as quick as possible. 
            <see cref="P:ManagedBass.Asio.BassAsio.CPUUsage" /> can be used to monitor that.
            Do not call the <see cref="M:ManagedBass.Asio.BassAsio.Stop" /> or <see cref="M:ManagedBass.Asio.BassAsio.Free" /> functions from within an ASIO callback. 
            Also, if it is an output channel, <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetFormat(System.Boolean,System.Int32,ManagedBass.Asio.AsioSampleFormat)" /> and <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetRate(System.Boolean,System.Int32,System.Double)" /> should not be used on the channel being processed by the callback.
            </para>
            <para>
            Prior to calling this function, BassAsio will set the thread's device context to the device that the channel belongs to.
            So when using multiple devices, <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> can be used to determine which device the channel is on.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Asio.AsioChannelActive">
            <summary>
            BassAsio active values return by <see cref="M:ManagedBass.Asio.BassAsio.ChannelIsActive(System.Boolean,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelActive.Disabled">
            <summary>
            The channel is not enabled.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelActive.Enabled">
            <summary>
            The channel is enabled.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelActive.Paused">
            <summary>
            The channel is enabled and paused.
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioChannelResetFlags">
            <summary>
            BassAsio attributes to be used when to reset a channel with <see cref="M:ManagedBass.Asio.BassAsio.ChannelReset(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelResetFlags)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelResetFlags.Enable">
            <summary>
            Disable Channel
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelResetFlags.Join">
            <summary>
            Unjoin Channel
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelResetFlags.Pause">
            <summary>
            Unpause Channel
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelResetFlags.Format">
            <summary>
            Reset sample format to native format
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelResetFlags.Rate">
            <summary>
            Reset sample rate to device rate
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelResetFlags.Volume">
            <summary>
            Reset Volume to 1.0
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioFuture">
            <summary>
            BassAsio Future values that might be used with the <see cref="M:ManagedBass.Asio.BassAsio.Future(ManagedBass.Asio.AsioFuture,System.IntPtr)" /> method.
            <para>Note: Other/Additional values might be possible - see your drivers manual for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.EnableTimeCodeRead">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.DisableTimeCodeRead">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.SetInputMonitor">
            <summary>
            ASIOInputMonitor* in params
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.Transport">
            <summary>
            ASIOTransportParameters* in params
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.SetInputGain">
            <summary>
            ASIOChannelControls* in params, apply gain
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.GetInputMeter">
            <summary>
            ASIOChannelControls* in params, fill meter
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.SetOutputGain">
            <summary>
            ASIOChannelControls* in params, apply gain
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.GetOutputMeter">
            <summary>
            ASIOChannelControls* in params, fill meter
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanInputMonitor">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanTimeInfo">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanTimeCode">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanTransport">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanInputGain">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanInputMeter">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanOutputGain">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanOutputMeter">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.SetIoFormat">
            <summary>
            DSD support: ASIOIoFormat * in params
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.GetIoFormat">
            <summary>
            DSD support: ASIOIoFormat * in params
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioFuture.CanDoIoFormat">
            <summary>
            DSD support: ASIOIoFormat * in params
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioInitFlags">
            <summary>
            Initialization flags to be used with <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" />
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInitFlags.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInitFlags.Thread">
            <summary>
            Host driver in dedicated thread
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInitFlags.JoinOrder">
            <summary>
            Order joined channels by when they were joined
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioIOFormatType">
            <summary>
            Asio IO Format type to be used with <see cref="F:ManagedBass.Asio.AsioIOFormat.FormatType"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioIOFormatType.PCM">
            <summary>
            PCM.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioIOFormatType.DSD">
            <summary>
            DSD.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioIOFormatType.Invalid">
            <summary>
            Invalid.
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioNotify">
            <summary>
            BassAsio notify values as used in the <see cref="T:ManagedBass.Asio.AsioNotifyProcedure" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioNotify.Rate">
            <summary>
            The device's sample rate has changed.
            The new rate is available from <see cref="P:ManagedBass.Asio.BassAsio.Rate" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioNotify.Reset">
            <summary>
            The driver has requested a reset/reinitialization;
            for example, following a change of the default Buffer size.
            This request can be ignored, but if a reinitialization is performed, it should not be done within the callback.
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioSampleFormat">
            <summary>
            BassAsio sample formats to be used with <see cref="T:ManagedBass.Asio.AsioChannelInfo" /> and <see cref="M:ManagedBass.Asio.BassAsio.ChannelGetInfo(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelInfo@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.Unknown">
            <summary>
            Unknown format. Error.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.Bit16">
            <summary>
            16-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.Bit24">
            <summary>
            24-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.Bit32">
            <summary>
            32-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.Float">
            <summary>
            32-bit floating-point.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.DSD_LSB">
            <summary>
            DSD (LSB 1st)
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioSampleFormat.DSD_MSB">
            <summary>
            DSD (MSB 1st)
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioTransportCommand">
            <summary>
            Asio Transport Command to be used with <see cref="T:ManagedBass.Asio.AsioTransportParameters"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.Start">
            <summary>
            Start
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.Stop">
            <summary>
            Stop
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.Locate">
            <summary>
            Locate
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.PunchIn">
            <summary>
            Punch in
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.PunchOut">
            <summary>
            Punch out
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.ArmOn">
            <summary>
            Arm on
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.ArmOff">
            <summary>
            Arm off
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.MonitorOn">
            <summary>
            Monitor on
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.MonitorOff">
            <summary>
            Monitor off
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.Arm">
            <summary>
            Arm
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportCommand.Monitor">
            <summary>
            Monitor
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.BassAsio">
            <summary>
            Wraps BassAsio: bassasio.dll
            </summary>
            <remarks>
            Only available on Windows
            </remarks>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.AddDevice(System.Guid,System.String,System.String)">
            <summary>
            Adds a driver to the device list.
            </summary>
            <param name="ClsID">The driver's class ID.</param>
            <param name="Driver">The filename of the driver.</param>
            <param name="Name">An optional description of the driver.</param>
            <returns>
            If successful, the new device number is returned (which might be used in a subsequent <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> call), else -1 is returned.
            Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.
            </returns>
            <remarks>
            <para>A list of installed ASIO drivers is kept in the Windows registry, which is where BassAsio gets its device list from, 
            but it is also possible to add unregistered drivers (eg. private drivers) to the list via this function. 
            If successful, the returned device number can be used in a <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> call to use the driver.</para>
            <para>The <paramref name="Driver"/> and <patamref name="Name"/> strings are expected to be in Unicode from.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="Driver" /> file does not exist.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.CheckRate(System.Double)">
            <summary>
            Checks if a sample rate is supported by the device.
            </summary>
            <param name="Rate">The sample rate to check.</param>
            <returns>If the sample rate is supported, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The sample rate is not supported by the device/drivers.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ControlPanel">
            <summary>
            Displays the current Asio driver's control panel.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.LastError">
            <summary>
            Retrieves the error code for the most recent BassAsio function call in the current thread.
            </summary>
            <returns>
            If no error occured during the last BassAsio function call then <see cref="F:ManagedBass.Errors.OK"/> is returned, else one of the <see cref="T:ManagedBass.Errors" /> values is returned. 
            See the function description for an explanation of what the error code means.
            </returns>
            <remarks>Error codes are stored for each thread. So if you happen to call 2 or more BassAsio functions at the same time, they will not interfere with eachother's error codes.</remarks>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Free">
            <summary>
            Releases the Asio device/driver.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>Make sure to free each Asio device you have initialized with <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" />, <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> is used to switch the current device.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)"/> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Future(ManagedBass.Asio.AsioFuture,System.IntPtr)">
            <summary>
            Provides access to the driver's 'future' function.
            </summary>
            <param name="Selector">Operation code.</param>
            <param name="Param">Pointer to the operation's parameters, if applicable.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>This method is a general purpose extension method serving various purposes.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <paramref name="Selector" /> is not supported by the driver.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem.</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.CPUUsage">
            <summary>
            Retrieves the current CPU usage of BASSASIO.
            </summary>
            <returns>The BASSASIO CPU usage as a percentage of total CPU time.</returns>
            <remarks>This function includes the time taken by the <see cref="T:ManagedBass.Asio.AsioProcedure" /> callback functions.</remarks>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.CurrentDevice">
            <summary>
            Gets or Sets the Asio device to use for subsequent calls in the current thread... 0 = first device.
            </summary>
            <remarks>
            <para>Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>
            As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via this function prior to calling the function.
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </para>
            <para>
            The device context setting is used by any function that may result in a <see cref="F:ManagedBass.Errors.Init"/> error (except this function), which is the majority of them.
            When one if those functions is called, it will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BassAsio will automatically select the lowest device that is initialized. 
            This means that when using a single device, there is no need to use this function - BassAsio will automatically use the device that's initialized.
            Even if you free the device, and initialize another, BassAsio will automatically switch to the one that is initialized.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init">The device has not been initialized or there are no initialised devices.</exception>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.GetDeviceInfo(System.Int32,ManagedBass.Asio.AsioDeviceInfo@)">
            <summary>
            Retrieves information on an Asio device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Asio.AsioDeviceInfo" /> structure to store the information at.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Asio devices for a setup dialog. 
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The <paramref name="Device"/> number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an Asio device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.Asio.AsioDeviceInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            This function can be used to enumerate the available Asio devices for a setup dialog.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The <paramref name="Device"/> number specified is invalid.</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.DeviceCount">
            <summary>
            Returns the total number of available Asio devices.
            </summary>
            <returns>Number of ASIO devices available.</returns>
            <remarks>Uses <see cref="M:ManagedBass.Asio.BassAsio.GetDeviceInfo(System.Int32,ManagedBass.Asio.AsioDeviceInfo@)" /> internally.</remarks>        
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.GetInfo(ManagedBass.Asio.AsioInfo@)">
            <summary>
            Retrieves information on the Asio device being used.
            </summary>
            <param name="Info">An instance of the <see cref="T:ManagedBass.BassInfo" /> structure to store the information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> prior to calling the function.
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.Info">
            <summary>
            Retrieves information on the Asio device being used.
            </summary>
            <returns>An instance of the <see cref="T:ManagedBass.Asio.AsioInfo" /> structure. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> prior to calling the function.
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.GetLatency(System.Boolean)">
            <summary>
            Retrieves the latency of input or output channels of the current Asio device
            </summary>
            <param name="Input">Get the input latency? <see langword="false" /> = the output latency.</param>
            <returns>If successful, the latency in samples is returned, else -1 is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The latency is the delay between the sound being recorded and reaching an <see cref="T:ManagedBass.Asio.AsioProcedure" />, in the case of input channels.
            And the delay between the sample data being fed to an <see cref="T:ManagedBass.Asio.AsioProcedure" /> and actually being heard, in the case of output channels. 
            The latency is dependant on the buffer size, as specified in the <see cref="M:ManagedBass.Asio.BassAsio.Start(System.Int32,System.Int32)" /> call.
            So the latency should be checked after making that call, not before.
            </para>
            <para>
            The latency time can by calculated be dividing the sample latency by the device sample rate.
            When a channel is being resampled, the sample latency will change, but the effective latency time remains constant.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.Rate">
            <summary>
            Gets or Sets the current Asio device's sample rate.
            </summary>
            <remarks>
            <para>Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            When it's not possible to set the device to the rate wanted, this can be used to overcome that.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The sample rate is not supported by the device/drivers.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.Version">
            <summary>
            Gets the version of BassAsio that is Loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)">
            <summary>
            Initializes an Asio device/driver.
            </summary>
            <param name="Device">The device to use... 0 = first device. <see cref="M:ManagedBass.Asio.BassAsio.GetDeviceInfo(System.Int32,ManagedBass.Asio.AsioDeviceInfo@)" /> can be used to get the total number of devices.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.Asio.AsioInitFlags"/>.</param>
            <returns>If the device was successfully initialized, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before any input or output can be performed.</para>
            <para>
            The ASIO driver is accessed via a COM object using the single-threaded apartment model, which means that requests to the driver go through the thread that initialized it, so the thread needs to exist as long as the driver remains initialized.
            The thread should also have a message queue.
            If device initializing and releasing from multiple threads is required, or the application does not have a message queue (eg. a console application), then the <see cref="F:ManagedBass.Asio.AsioInitFlags.Thread"/> flag can be used to have BassAsio create a dedicated thread to host the ASIO driver.
            </para>
            <para>
            Simultaneously using multiple devices is supported in the BassAsio API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> is used to switch the current device. 
            When successful, the current thread's device is set to the one that was just initialized.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The <paramref name="Device" /> number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">A device has already been initialized. You must call <see cref="M:ManagedBass.Asio.BassAsio.Free" /> before you can initialize again.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">The driver couldn't be initialized.</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.IsStarted">
            <summary>
            Checks, if the current Asio device has been started.
            </summary>
            <returns>Returns <see langword="true" />, if the device has been started, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Monitor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the direct input monitoring state.
            </summary>
            <param name="Input">The input channel to set the monitoring state of... -1 = all.</param>
            <param name="Output">The suggested output channel for the monitoring.</param>
            <param name="Gain">Suggested Gain, ranging from 0 to 0x7fffffff (-inf to +12 dB), 0x20000000 equals 0 dB.</param>
            <param name="State">Monitoring state... 0 = off, 1 = on. Other settings may be possible depending on the drivers, e.g.:
            <para>0 = input monitoring off.</para>
            <para>1 = input monitoring on.</para>
            <para>2 = playback monitoring off.</para>
            <para>3 = playback monitoring on.</para>
            </param>
            <param name="Pan">Suggested Pan, ranging from 0 = left to 0x7fffffff = right (centre should be 0x40000000).</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            If the hardware does not support patching and mixing a straight 1 to 1 routing is suggested. 
            The driver should ignore all the information of ASIOMonitor it cannot deal with, usually these might be either or all of output, gain, pan.
            <para>
            Output is the base channel of a stereo channel pair, i.e. output is always an even channel (0,2,4...). 
            If an odd input channel should be monitored and no panning or output routing can be applied, the driver has to use the next higher output (imply a hard right pan).
            Note that the output, gain and pan settings are just suggestions, and may be ignored by the device/driver.
            </para>
            <para>Some cards/drivers might also support direct output monitoring, in such case use the <paramref name="Input" /> parameter to denote the output channel to monitor and specify an appropriate <paramref name="State" /> value.</para>
            <para>
            ADM has originally been based on a mono in - stereo out scheme. Meaning if you need to monitor a stereo input channel pair you need to call this twice, both using the same output value, but using an odd and an even input value.
            In such case set the odd input to pan hard left and the even input to pan hard right.
            </para>
            <para>
            Also note, that if you have channels in-between not activated in ASIO these will not counted. 
            So if for example channels 3 and 4 are inactive, ADM input 3 is related to the physical input channel 5!
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.SetDSD(System.Boolean)">
            <summary>
            Sets the device's sample format to DSD or PCM.
            </summary>
            <param name="DSD">Set the sample format to DSD?</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            When a device is switched between PCM and DSD formats, the ASIO channels' format will change accordingly, as reported by <see cref="M:ManagedBass.Asio.BassAsio.ChannelGetInfo(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelInfo@)" />.
            Any <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetFormat(System.Boolean,System.Int32,ManagedBass.Asio.AsioSampleFormat)" /> and <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetRate(System.Boolean,System.Int32,System.Double)" /> settings that have been applied will be reset to defaults. 
            Other channel settings are unchanged.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">DSD is not supported by the device/driver.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.SetNotify(ManagedBass.Asio.AsioNotifyProcedure,System.IntPtr)">
            <summary>
            Sets a notification callback on the ASIO driver.
            </summary>
            <param name="Procedure">User defined notification function... <see langword="null"/> = disable notifications.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>A previously set notification callback can be changed (or removed) at any time, by calling this function again.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
        </member>
        <member name="P:ManagedBass.Asio.BassAsio.Unicode">
            <summary>
            Gets or Sets the character set used in device information text: if <see langword="false"/>, ANSI is used (default), else UTF-16 is used.
            </summary>
            <remarks>
            <para>Throws <see cref="T:ManagedBass.BassException"/> on Error setting value.</para>
            This function determines the character set that is used in the <see cref="T:ManagedBass.Asio.AsioDeviceInfo" /> structure and in <see cref="M:ManagedBass.Asio.BassAsio.AddDevice(System.Guid,System.String,System.String)" /> function calls.
            It does not affect ASIO channel names in the <see cref="T:ManagedBass.Asio.AsioChannelInfo" /> and <see cref="T:ManagedBass.Asio.AsioInfo" /> structure.
            <para>The character set choice is finalised in the first <see cref="M:ManagedBass.Asio.BassAsio.GetDeviceInfo(System.Int32,ManagedBass.Asio.AsioDeviceInfo@)" />, <see cref="M:ManagedBass.Asio.BassAsio.AddDevice(System.Guid,System.String,System.String)" /> or <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> call, and it cannot be changed after that.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.NotAvailable">This function is only available before any devices have been enumerated.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Start(System.Int32,System.Int32)">
            <summary>
            Starts the current Asio device.
            </summary>
            <param name="BufferLength">Buffer length in samples... 0 = use current length.</param>
            <param name="Threads">The number of processing threads to use... 0 = use current number.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            Before starting the device, channels must be enabled using <see cref="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)" />.
            Once started, channels can't be enabled or disabled until the device is stopped, using <see cref="M:ManagedBass.Asio.BassAsio.Stop" />.
            <para>
            The default number of processing threads is 1, which means that the <see cref="T:ManagedBass.Asio.AsioProcedure" /> functions of the enabled channels get called in series (starting with the lowest input channel).
            Multiple channels can be processed in parallel if multiple threads are created for that purpose via the threads parameter.
            The number of threads is automatically capped at the number of enabled channels with an <see cref="T:ManagedBass.Asio.AsioProcedure" /> function, which is sufficient to have them all processed simultaneously.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The device has already been started.</exception>
            <exception cref="F:ManagedBass.Errors.NoChannel">No channels have been enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.Stop">
            <summary>
            Stops the current Asio device.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="P:ManagedBass.Asio.BassAsio.CurrentDevice" /> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device hasn't been started.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)">
            <summary>
            Enable/disable processing of an Asio channel.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <param name="Procedure">The user defined function to process the channel... <see langword="null" /> = disable the channel.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            All ASIO channels are mono.
            Stereo (and above) channels can be formed by joining multiple channels together using <see cref="M:ManagedBass.Asio.BassAsio.ChannelJoin(System.Boolean,System.Int32,System.Int32)" />.
            </para>
            <para>Use <see cref="M:ManagedBass.Asio.BassAsio.Start(System.Int32,System.Int32)" /> to begin processing the enabled channels.</para>
            <para>
            You might also use this function on an already enabled ASIO channel if you just want to change the <see cref="T:ManagedBass.Asio.AsioProcedure" /> which should be used.
            However changing the callback procedure to <see langword="null" /> would disable the channel - which is only possible, if the ASIO device is stopped.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device has been started - it needs to be stopped before (dis)enabling channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelEnableMirror(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Enables an output channel, and makes it mirror another channel.
            </summary>
            <param name="Channel">The output channel number... 0 = first.</param>
            <param name="Input2">Mirroring an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel2">The channel to mirror.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function allows an input or output channel to be duplicated in other output channel.
            This can be achieved using normal <see cref="T:ManagedBass.Asio.AsioProcedure" /> processing, but it's more efficient to let BassAsio simply copy the data from one channel to another.
            </para>
            <para>
            Mirror channels can't be joined together to form multi-channel mirrors.
            Instead, to mirror multiple channels, an individual mirror should be setup for each of them.
            </para>
            <para>After <see cref="M:ManagedBass.Asio.BassAsio.Start(System.Int32,System.Int32)" /> has been called to begin processing, it's not possible to setup new mirror channels, but it is still possible to change the channel that a mirror is mirroring.</para>
            <para>
            When mirroring an output channel that hasn't been enabled, the mirror channel will just produce silence.
            When mirroring an input channel that hasn't already been enabled, the channel is automatically enabled for processing when <see cref="M:ManagedBass.Asio.BassAsio.Start(System.Int32,System.Int32)" /> is called, so that it can be mirrored.
            If the mirror is switched to a disabled input channel once processing has begun, then it will produce silence.
            </para>
            <para>
            A mirror channel can be made to have a different volume level to the channel that it's mirroring, using <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetVolume(System.Boolean,System.Int32,System.Double)" />.
            The volume setting is cumulative.
            For example, if the mirror channel has a volume setting of 0.5 and the mirrored channel has a volume setting of 0.4, the effective volume of the mirror channel will be 0.2 (0.5 x 0.4).
            </para>
            <para><see cref="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)" /> can be used to disable a mirror channel.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device has been started - it needs to be stopped before enabling channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">At least one of the channels is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">It is not possible to mirror channels that do not have the same sample format.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelGetFormat(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's sample format.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <returns>If an error occurs, -1 (<see cref="F:ManagedBass.Asio.AsioSampleFormat.Unknown"/>) is returned, use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelGetInfo(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelInfo@)">
            <summary>
            Retrieves information on an Asio channel.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Asio.AsioChannelInfo" /> structure to store the information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelGetInfo(System.Boolean,System.Int32)">
            <summary>
            Retrieves information on an Asio channel.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.Asio.AsioChannelInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelGetLevel(System.Boolean,System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a channel.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code. 
            If successful, the level of the channel is returned, ranging from 0 (silent) to 1 (max).
            If the channel's native sample format is floating-point, it is actually possible for the level to go above 1.
            </returns>
            <remarks>
            This function measures the level of a single channel, and is not affected by any other channels that are joined with it.
            <para>Volume settings made via <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetVolume(System.Boolean,System.Int32,System.Double)" /> affect the level reading of output channels, but not input channels.</para>
            <para>
            When an input channel is paused, it is still possible to get its level.
            Paused output channels will have a level of 0.
            </para>
            <para>Level retrieval is not supported when the sample format is DSD.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device hasn't been started, or the channel isn't enabled.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">Level retrieval is not supported for the channel's sample format (please report).</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelGetRate(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's sample rate.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <returns>If succesful, the channel's sample rate is returned (0 = device rate), else -1 is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelGetVolume(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's volume setting.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first, -1 = master.</param>
            <returns>If successful, the channel's volume setting is returned, else -1 is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>To set a channel volume use <see cref="M:ManagedBass.Asio.BassAsio.ChannelSetVolume(System.Boolean,System.Int32,System.Double)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelIsActive(System.Boolean,System.Int32)">
            <summary>
            Checks if a channel is enabled for processing.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <returns>One <see cref="T:ManagedBass.Asio.AsioChannelActive"/> value is returned.</returns>
            <remarks>
            When a channel is joined to another, the status of the other channel is returned, as that is what determines whether the channel is enabled for processing - whether it's been enabled itself is of no consequence while it is joined to another. 
            For example, if channel B is joined to channel A, and channel A is not enabled, then neither is channel B.
            </remarks>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelJoin(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Join a channel to another.
            </summary>
            <param name="Input">Dealing with input channels? <see langword="false" /> = output channels.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <param name="Channel2">The channel to join it to... -1 = remove current join.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            All ASIO channels are mono.
            By joining them, stereo (and above) channels can be formed, making it simpler to process stereo (and above) sample data.
            </para>
            <para>
            By default, channels can only be joined to preceding channels.
            For example, channel 1 can be joined to channel 0, but not vice versa.
            The <see cref="F:ManagedBass.Asio.AsioInitFlags.JoinOrder"/> flag can be used in the <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> call to remove that restriction.
            When joining a group of channels, there should be one channel enabled via <see cref="M:ManagedBass.Asio.BassAsio.ChannelEnable(System.Boolean,System.Int32,ManagedBass.Asio.AsioProcedure,System.IntPtr)" /> with the rest joined to it - 
            do not join a channel to a channel that is itself joined to another channel.
            Mirror channels, setup using <see cref="M:ManagedBass.Asio.BassAsio.ChannelEnableMirror(System.Int32,System.Boolean,System.Int32)" />, cannot be joined with.
            </para>
            <para>
            If a channel has two or more other channels joined to it, then the joined channels will default to being in numerically ascending order in the <see cref="T:ManagedBass.Asio.AsioProcedure" /> callback function's sample data unless the <see cref="F:ManagedBass.Asio.AsioInitFlags.JoinOrder"/> flag was used in the <see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> call, 
            in which case they will be in the order in which they were joined via this function.
            In the latter case, if this function is called on an already joined channel, the channel will be moved to the end of the joined group.
            </para>
            <para>
            While a channel is joined to another, it automatically takes on the attributes of the other channel - the other channel's settings determine the sample format, the sample rate and whether it is enabled.
            The volume setting remains individual though, allowing balance control over the joined channels.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device has been started - it needs to be stopped before (dis)enabling channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">It is not possible to join channels that do not have the same sample format.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelPause(System.Boolean,System.Int32)">
            <summary>
            Suspends processing of a channel.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Channels can only be disabled when the device is stopped.
            When you want to stop processing only some of the enabled channels, there are few ways that could be done.
            You could quickly stop the device, disable the unwanted channels, and restart the device. 
            In the case of output channels, you could fill the channels' buffers with silence (0s) in the <see cref="T:ManagedBass.Asio.AsioProcedure" />.
            Or you could pause the channels, using this function. 
            The less channels BassAsio has to process, the less CPU it'll use, so stopping and restarting the device would be the most efficient, but that could cause a slight break in the sound of the other channels. 
            Filling the buffers with silence is the least efficient, as BassAsio will still process the data as if it was "normal", but it does mean that other channels are unaffected.
            Pausing is a compromise between the two - the channels will still be enabled, but BassAsio will bypass any additional processing (resampling/etc) that may normally be required.</para>
            <para>Use <see cref="M:ManagedBass.Asio.BassAsio.ChannelReset(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelResetFlags)" /> to resume processing of a paused channel.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelReset(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelResetFlags)">
            <summary>
            Resets the attributes of a channel (or all channels).
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first, -1 = all channels.</param>
            <param name="Flags">The attributes to reset. A combination of <see cref="T:ManagedBass.Asio.AsioChannelResetFlags"/>.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>When resetting all channels (channel = -1), the resetting only applies to all channels of the specified type, ie. input or output, not both.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device has been started - it needs to be stopped before disabling or unjoining channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelSetFormat(System.Boolean,System.Int32,ManagedBass.Asio.AsioSampleFormat)">
            <summary>
            Sets a channel's sample format.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <param name="Format">The sample format.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The sample format can vary between ASIO devices/drivers, which could mean a lot of extra/duplicate code being required.
            To avoid that extra work, BassAsio can automatically convert the sample data, whenever necessary, to/from a format of your choice. 
            The native format of a channel can be retrieved via <see cref="M:ManagedBass.Asio.BassAsio.ChannelGetInfo(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelInfo@)" />.
            </para>
            <para>
            The PCM format options are only available when the device's format is PCM, and the DSD format options are only available when the device's format is DSD. 
            If a device supports both, it can be switched between DSD and PCM via <see cref="M:ManagedBass.Asio.BassAsio.SetDSD(System.Boolean)" />.
            </para>
            <para>For performance reasons, it's best not to use 24-bit sample data whenever possible, as 24-bit data requires a bit more processing than the other formats.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination, or <paramref name="Format" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">Format conversion is not available for the channel's native sample format (please report).</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelSetRate(System.Boolean,System.Int32,System.Double)">
            <summary>
            Sets a channel's sample rate.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first.</param>
            <param name="Rate">The sample rate... 0 = device rate.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            For optimal quality and performance, it is best to set the device to the sample rate you want via <see cref="P:ManagedBass.Asio.BassAsio.Rate" />, but that's not always possible. 
            Which is where this function and resampling comes into play.
            16 point sinc interpolation is used, giving a good blend of sound quality and performance.
            It is also SSE2 and 3DNow optimized for an extra boost with supporting CPUs.
            </para>
            <para>When a channel's sample rate is the same as the device rate, resampling is bypassed, so there's no unnecessary performance hit.</para>
            <para>Resampling is not supported when the sample format is DSD.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description></description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description></description></item>
            <item><term>BASS_ERROR_FORMAT</term><description></description></item>
            </list>
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid, or <paramref name="Rate" /> is below 0.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">Format conversion is not available for the channel's native sample format (please report).</exception>
        </member>
        <member name="M:ManagedBass.Asio.BassAsio.ChannelSetVolume(System.Boolean,System.Int32,System.Double)">
            <summary>
            Sets a channel's volume.
            </summary>
            <param name="Input">Dealing with an input channel? <see langword="false" /> = an output channel.</param>
            <param name="Channel">The input/output channel number... 0 = first, -1 = master.</param>
            <param name="Volume">The volume level... 0 (silent)...1.0 (normal). Above 1.0 amplifies the sound.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Asio.BassAsio.LastError" /> to get the error code.</returns>
            <remarks>
            <para></para>
            <para>
            Apart from the master volume (channel = -1), this function applies a volume level to a single channel, and does not affect any other channels that are joined with it. 
            This allows balance control over joined channels, by setting the individual volume levels accordingly.
            The final level of a channel is = master volume * channel volume.
            </para>
            <para>The volume "curve" is linear, but logarithmic levels can be easily used. See the example below.</para>
            <para>
            ASIO drivers do not provide volume control themselves, so the volume adjustments are applied to the sample data by BassAsio. 
            This also means that changes do not persist across sessions, and the channel volume levels will always start at 1.0.
            </para>
            <para>When the channel's sample format is DSD, a 0 volume setting will mute the channel and anything else will be treated as 1.0 (normal).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Asio.BassAsio.Init(System.Int32,ManagedBass.Asio.AsioInitFlags)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Input" /> and <paramref name="Channel" /> combination is invalid, or <paramref name="Volume" /> is below 0.</exception>
        </member>
        <member name="T:ManagedBass.Asio.AsioChannelControls">
            <summary>
            Used with <see cref="M:ManagedBass.Asio.BassAsio.Future(ManagedBass.Asio.AsioFuture,System.IntPtr)" /> and the Get/SetInput resp. Get/SetOutput selector.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelControls.Channel">
            <summary>
            the channel index
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelControls.IsInput">
            <summary>
            TRUE = Input, FALSE = Output
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelControls.Gain">
            <summary>
            the gain value, ranging 0 - 0x7fffffffL (-inf to +12 dB)
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelControls.Meter">
            <summary>
            returned meter value, ranging 0 - 0x7fffffffL (-inf to +12 dB)
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioChannelControls.Future">
            <summary>
            up to 32 chars
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioChannelInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Asio.BassAsio.ChannelGetInfo(System.Boolean,System.Int32,ManagedBass.Asio.AsioChannelInfo@)" /> to retrieve information on the current device.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioChannelInfo.Group">
            <summary>
            The channel's group.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioChannelInfo.Format">
            <summary>
            The channel's sample format
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioChannelInfo.Name">
            <summary>
            The name of the channel.
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioDeviceInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Asio.BassAsio.GetDeviceInfo(System.Int32,ManagedBass.Asio.AsioDeviceInfo@)" /> to retrieve information on an asio device.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioDeviceInfo.Name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioDeviceInfo.Driver">
            <summary>
            The filename of the driver being used.
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="M:ManagedBass.Asio.AsioDeviceInfo.ToString">
            <summary>
            Returns the <see cref="P:ManagedBass.Asio.AsioDeviceInfo.Name"/> of the device.
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioInfo">
            <summary>
            Used with <see cref="P:ManagedBass.Asio.BassAsio.Info" /> to retrieve information on the current device.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.InitFlags">
            <summary>
            Flags used when initialising the AsioDevice.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.Name">
            <summary>
            The name of the device/driver.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.DriverVersion">
            <summary>
            The driver version.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.Inputs">
            <summary>
            The number of input channels available.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.Outputs">
            <summary>
            The number of output channels available.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.MinBufferLength">
            <summary>
            The minimum Buffer Length, in samples.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.MaxBufferLength">
            <summary>
            The maximum Buffer Length, in samples.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.PreferredBufferLength">
            <summary>
            The preferred/default Buffer Length, in samples.
            </summary>
        </member>
        <member name="P:ManagedBass.Asio.AsioInfo.BufferLengthGranularity">
            <summary>
            The Buffer Length granularity, that is the smallest possible Length change... -1 = the possible Buffer lengths increase in powers of 2.
            </summary>
        </member>
        <member name="M:ManagedBass.Asio.AsioInfo.ToString">
            <summary>
            Returns the <see cref="P:ManagedBass.Asio.AsioInfo.Name"/> of the AsioDevice.
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioInputMonitor">
            <summary>
            Used with <see cref="M:ManagedBass.Asio.BassAsio.Future(ManagedBass.Asio.AsioFuture,System.IntPtr)" /> and the SetInputMonitor selector.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInputMonitor.Input">
            <summary>
            this Input was set to monitor (or off), -1: all
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInputMonitor.Output">
            <summary>
            suggested output for monitoring the Input (if so)
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInputMonitor.Gain">
            <summary>
            suggested gain, ranging 0 - 0x7fffffffL (-inf to +12 dB)
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInputMonitor.State">
            <summary>
            TRUE = on, FALSE = off
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioInputMonitor.Pan">
            <summary>
            suggested pan, 0 = all left, 0x7fffffff = right
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioIOFormat">
            <summary>
            Used with <see cref="M:ManagedBass.Asio.BassAsio.Future(ManagedBass.Asio.AsioFuture,System.IntPtr)" /> and the DSD IoFormat selector.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioIOFormat.FormatType">
            <summary>
            Format Type
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioIOFormat.Future">
            <summary>
            up to 508 chars
            </summary>
        </member>
        <member name="T:ManagedBass.Asio.AsioTransportParameters">
            <summary>
            Used with <see cref="M:ManagedBass.Asio.BassAsio.Future(ManagedBass.Asio.AsioFuture,System.IntPtr)" /> and the Transport selector.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportParameters.command">
            <summary>
            One of the <see cref="T:ManagedBass.Asio.AsioTransportCommand"/> values (other values might be available).
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportParameters.SamplePosition">
            <summary>
            Number of samples data.
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportParameters.Track">
            <summary>
            Track Index
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportParameters.TrackSwitches">
            <summary>
            512 Tracks on/off
            </summary>
        </member>
        <member name="F:ManagedBass.Asio.AsioTransportParameters.Future">
            <summary>
            Max 64 characters.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.BassWasapi">
            <summary>
            Wraps basswasapi.dll: Windows Audio Session API driver library
            </summary>
            <remarks>
            <para>BASSWASAPI is basically a wrapper for Windows Audio Session API drivers, with the addition of channel joining, format conversion and resampling.</para>
            <para>
            BASSWASAPI requires a soundcard with a Windows Session API drivers installed (Vista or above).
            It also makes use of SSE2 and 3DNow optimizations, but is fully functional without them.
            BASS is not required by BASSWASAPI, but BASS can of course be used to decode, apply DSP/FX, etc.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Wasapi.BassWasapi.DefaultDevice">
            <summary>
            Identifier for Default Device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.BassWasapi.DefaultInputDevice">
            <summary>
            Identifier for Default Recording Device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.BassWasapi.DefaultLoopbackDevice">
            <summary>
            Identifier for Default Loopback Device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.BassWasapi.CPUUsage">
            <summary>
            Retrieves the current CPU usage of BASSWASAPI.
            </summary>
            <returns>The BASSWASAPI CPU usage as a percentage of total CPU time.</returns>
            <remarks>This function includes the time taken by the <see cref="T:ManagedBass.Wasapi.WasapiProcedure" /> callback functions.</remarks>
        </member>
        <member name="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice">
            <summary>
            Gets or Sets the Wasapi device to use for susequent calls in the current thread... 0 = first device. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </summary>
            <remarks>
            <para>Throws <see cref="T:ManagedBass.BassException"/> on Error setting value.</para>
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system;
            instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </para>
            <para>
            All of the BassWasapi functions that do not have their own "device" parameter make use of this device selection.
            When one of them is called, BassWasapi will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BassWasapi will automatically select the lowest device that is initialized.
            This means that when using a single device, there is no need to use this function;
            BassWasapi will automatically use the device that is initialized.
            Even if you free the device, and initialize another, BassWasapi will automatically switch to the one that is initialized.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)">
            <summary>
            Retrieves information on a Wasapi device (endpoint).
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Wasapi.WasapiDeviceInfo" /> class to store the information at.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Wasapi devices (endpoints) for a setup dialog. 
            <para>Note: Input (capture) devices can be determined by evaluating <see cref="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsInput"/> and <see cref="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsLoopback"/> members.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Wasapi">WASAPI is not available</exception>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a Wasapi device (endpoint).
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>An instance of <see cref="T:ManagedBass.Wasapi.WasapiDeviceInfo"/> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            This function can be used to enumerate the available Wasapi devices (endpoints) for a setup dialog. 
            <para>Note: Input (capture) devices can be determined by evaluating <see cref="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsInput"/> and <see cref="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsLoopback"/> members.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Wasapi">WASAPI is not available</exception>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.SetNotify(ManagedBass.Wasapi.WasapiNotifyProcedure,System.IntPtr)">
            <summary>
            Sets a device change notification callback.
            </summary>
            <param name="Procedure">User defined notification function... <see langword="null" /> = disable notifications.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>A previously set notification callback can be changed (or removed) at any time, by calling this function again.</remarks>
        </member>
        <member name="P:ManagedBass.Wasapi.BassWasapi.DeviceCount">
            <summary>
            Gets the total number of available Wasapi devices.
            </summary>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.CheckFormat(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags)">
            <summary>
            Checks if a particular sample format is supported by a device (endpoint).
            </summary>
            <param name="Device">The device to use... 0 = first device, -1 = default device, -2 = default input device. <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" /> can be used to enumerate the available devices.</param>
            <param name="Frequency">The sample rate to check.</param>
            <param name="Channels">The number of channels to check... 1 = mono, 2 = stereo, etc.</param>
            <param name="Flags">
            Any combination of <see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Shared"/> and <see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Exclusive"/>.
            The HIWORD can be used to limit the sample formats that are checked in exclusive mode.
            The default is to check 32-bit floating-point, 32-bit integer, 24-bit integer, 16-bit integer, 8-bit integer, in that order.
            A <see cref="T:ManagedBass.Wasapi.WasapiFormat"/> value can be used to bypass the formats that precede it in that list.
            </param>
            <returns>If the sample format is supported, the maximum supported resolution (a <see cref="T:ManagedBass.Wasapi.WasapiFormat" /> value) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Call this method prior to <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> in order to make sure the requested format is supported by the Wasapi output device/driver (endpoint).
            <para>
            Shared and exclusive modes may have different sample formats available.
            Only the "mix format" (available from <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" />) is generally supported in shared mode.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Wasapi">WASAPI is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Device">The <paramref name="Device" /> number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">The driver could not be initialized.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">Unsupported sample format or number of channels.</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetInfo(ManagedBass.Wasapi.WasapiInfo@)">
            <summary>
            Retrieves information on the Wasapi device being used.
            </summary>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Wasapi.WasapiInfo" /> structure to store the information at.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This method can be used to get the effective settings used with an initialized Wasapi device (endpoint).
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="P:ManagedBass.Wasapi.BassWasapi.Info">
            <summary>
            Retrieves information on the Wasapi device being used.
            </summary>
            <returns>An instance of the <see cref="T:ManagedBass.Wasapi.WasapiInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            This method can be used to get the effective settings used with an initialized Wasapi device (endpoint).
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Free">
            <summary>
            Frees the Wasapi device/driver (endpoint).
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function should be called for all initialized devices before the program closes.
            Freed devices do not need to have been stopped with <see cref="M:ManagedBass.Wasapi.BassWasapi.Stop(System.Boolean)" /> beforehand.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Buffer">An <see cref="T:System.IntPtr"/> to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the device (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the device's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />, but it gets the data from the device's buffer instead of decoding it from a channel, 
            which means that the device doesn't miss out on any data.
            In order to do this, the device must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            Internally, a BASS stream is used for that, so the usual <see cref="T:ManagedBass.DataFlags"/> are supported.
            That also means that BASS needs to have been initialized first; it specifically uses the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. 
            If the device is subsequently freed, this method call will fail.
            </para>
            <para>
            As in BASS, simultaneously using multiple devices is supported in the BASSWASAPI API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" /> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device was not initialized using buffering (<see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer"/>).</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetData(System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Buffer">A float[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the device (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the device's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />, but it gets the data from the device's buffer instead of decoding it from a channel, 
            which means that the device doesn't miss out on any data.
            In order to do this, the device must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            Internally, a BASS stream is used for that, so the usual <see cref="T:ManagedBass.DataFlags"/> are supported.
            That also means that BASS needs to have been initialized first; it specifically uses the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. 
            If the device is subsequently freed, this method call will fail.
            </para>
            <para>
            As in BASS, simultaneously using multiple devices is supported in the BASSWASAPI API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" /> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device was not initialized using buffering (<see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer"/>).</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.PutData(System.IntPtr,System.Int32)">
            <summary>
            Adds sample data to an output device buffer ("push" device).
            </summary>
            <param name="Buffer">The pointer to the sample data to provide.</param>
            <param name="Length">The amount of data in bytes. <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)" /> with the <see cref="F:ManagedBass.DataFlags.Available"/> flag can be used to check how much data is queued.</param>
            <returns>
            If successful, the the amount of data copied from the provided buffer will be returned
            (which may be less than requested if it doesn't all fit in the device buffer, see the <see cref="P:ManagedBass.Wasapi.WasapiInfo.BufferLength"/> property), else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            You must have initialized the device via <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> with <see cref="T:ManagedBass.Wasapi.WasapiProcedure" /> = <see langword="null" />.
            <para>As much data as possible will be placed in the device's buffer; this function will have to be called again for any remainder.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, ouput will stall until more data is provided.
            <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)" /> with the <see cref="F:ManagedBass.DataFlags.Available"/> flag can be used to check how much data is buffered.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device is being fed by a <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/> callback function, or it is an input device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.PutData(System.Single[],System.Int32)">
            <summary>
            Adds sample data to an output device buffer ("push" device).
            </summary>
            <param name="Buffer">float[] providing the sample data.</param>
            <param name="Length">The amount of data in bytes. <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)" /> with the <see cref="F:ManagedBass.DataFlags.Available"/> flag can be used to check how much data is queued.</param>
            <returns>
            If successful, the the amount of data copied from the provided buffer will be returned
            (which may be less than requested if it doesn't all fit in the device buffer, see the <see cref="P:ManagedBass.Wasapi.WasapiInfo.BufferLength"/> property), else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            You must have initialized the device via <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> with <see cref="T:ManagedBass.Wasapi.WasapiProcedure" /> = <see langword="null" />.
            <para>As much data as possible will be placed in the device's buffer; this function will have to be called again for any remainder.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, ouput will stall until more data is provided.
            <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)" /> with the <see cref="F:ManagedBass.DataFlags.Available"/> flag can be used to check how much data is buffered.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device is being fed by a <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/> callback function, or it is an input device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Lock(System.Boolean)">
            <summary>
            Locks the device to the current thread.
            </summary>
            <param name="State">If <see langword="false" />, unlock WASAPI, else lock it.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Locking a device prevents other threads from accessing the device buffer, including a <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/>.
            Other threads wanting to access a locked device will block until it is unlocked, so a device should only be locked very briefly.
            A device must be unlocked in the same thread that it was locked.
            </remarks>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetMute(ManagedBass.Wasapi.WasapiVolumeTypes)">
            <summary>
            Gets the mute status of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Mode">The type of volume to get.</param>
            <returns><see langword="true" />, if the device/session is muted and <see langword="false" /> if unmuted, else -1. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no volume control available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.SetMute(ManagedBass.Wasapi.WasapiVolumeTypes,System.Boolean)">
            <summary>
            Sets the mute status of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Mode">The type of volume to set.</param>
            <param name="Mute"><see langword="true" /> to mute the device, <see langword="false" /> to unmute the device.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no volume control available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetDeviceLevel(System.Int32,System.Int32)">
            <summary>
            Gets the audio meter information of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Device">The device to use... 0 = first device. <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" /> can be used to get the total number of devices.</param>
            <param name="Channel">The channel number to get the audio level meter information from (0=first, -1=all).</param>
            <returns>The audio level between 0.0 (silence) and 1.0 (maximum).</returns>
            <remarks>
            This method returns the global session level for the device which might include the level of other applications using the same device in shared-mode.
            <para>
            This function gets the level from the device/driver, or WASAPI if the device does not have its own level meter.
            If the latter case, the level will be unavailable when exclusive mode is active.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Wasapi">WASAPI is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Device" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">The device driver does not support level retrieval.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetVolume(ManagedBass.Wasapi.WasapiVolumeTypes)">
            <summary>
            Retrieves the current volume level.
            </summary>
            <param name="Curve">Volume curve to use.</param>
            <returns>If successful, the volume level is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Session volume always uses <see cref="F:ManagedBass.Wasapi.WasapiVolumeTypes.WindowsHybridCurve"/>.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no volume control available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.SetVolume(ManagedBass.Wasapi.WasapiVolumeTypes,System.Single)">
            <summary>
            Sets the volume of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Curve">Volume curve to use.</param>
            <param name="Volume">The new volume to set between 0.0 (silent) and 1.0 (maximum) if linear, or else a dB level.</param>
            <returns>Returns <see langword="true" /> on success, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Session volume only affects the current process, so other users of the device are unaffected.
            It has no effect on exclusive mode output, and maps to the device volume with input devices (so does affect other users).
            Session volume always uses <see cref="F:ManagedBass.Wasapi.WasapiVolumeTypes.WindowsHybridCurve"/>.
            If you need to control the volume of the stream only, you need to apply that directly within the <see cref="T:ManagedBass.Wasapi.WasapiProcedure" /> yourself.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no volume control available.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Volume" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)">
            <summary>
            Initializes a Wasapi device/driver (endpoint).
            </summary>
            <param name="Device">The device to use... 0 = first device, -1 = default output device, -2 = default input device. <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" /> can be used to enumerate the available devices.</param>
            <param name="Frequency">The sample rate to use... 0 = "mix format" sample rate.</param>
            <param name="Channels">The number of channels to use... 0 = "mix format" channels, 1 = mono, 2 = stereo, etc.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wasapi.WasapiInitFlags"/>.</param>
            <param name="Buffer">
            The length of the device's buffer in seconds.
            This is a minimum and the driver may choose to use a larger buffer;
            <see cref="P:ManagedBass.Wasapi.BassWasapi.Info" /> can be used to confirm what the buffer size is.
            For an output device, the buffer size determines the latency.
            </param>
            <param name="Period">
            The interval (in seconds) between callback function calls... 0 = use default.
            If the specified period is below the minimum update period, it will automatically be raised to that.
            <para>
            The update period specifies the time between <see cref="T:ManagedBass.Wasapi.WasapiProcedure" /> calls.
            The <see cref="T:ManagedBass.Wasapi.WasapiDeviceInfo" /> (see <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" />) "minperiod" and "defperiod" values are actually minimum/default update periods.
            </para>
            </param>
            <param name="Procedure">
            The user defined function to process the channel.
            Use <see langword="null" /> to create a Wasapi "push" device (to which you can feed sample data via <see cref="M:ManagedBass.Wasapi.BassWasapi.PutData(System.IntPtr,System.Int32)" />).
            </param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If the device was successfully initialized, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            For convenience, devices are always initialized to use their highest sample resolution and that is then converted to 32-bit floating-point, so that <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/> callback functions and the <see cref="M:ManagedBass.Wasapi.BassWasapi.PutData(System.IntPtr,System.Int32)" /> and <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)" /> functions are always dealing with the same sample format.
            The device's sample format can be obtained via <see cref="P:ManagedBass.Wasapi.BassWasapi.Info" />.
            </para>
            <para>
            WASAPI does not support arbitrary sample formats, like DirectSound does.
            In particular, only the "mix format" (available from <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" />) is generally supported in shared mode.
            <see cref="M:ManagedBass.Wasapi.BassWasapi.CheckFormat(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags)" /> can be used to check whether a particular sample format is supported.
            The BASSmix add-on can be used to play (or record) in otherwise unsupported sample formats, as well as playing multiple sources.
            </para>
            <para>The initialized device will not begin processing data until <see cref="M:ManagedBass.Wasapi.BassWasapi.Start" /> is called.</para>
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system; instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" /> is used to switch the current device.
            When successful, <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> automatically sets the current thread's device to the one that was just initialized.
            </para>
            <para>When using the default output or input device, <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" /> can be used to find out which device it was mapped to.</para>
            <para>In SHARED mode you must initialize the device with the current WASAPI mixer sample rate and number of channels (see the <see cref="T:ManagedBass.Wasapi.WasapiDeviceInfo" /> "mixfreq" and "mixchans" properties).</para>
            <para>In EXCLUSIVE mode you might use any sample rate and number of channels which are supported by the device/driver.</para>
            <para>This function must be successfully called before any input or output can be performed.</para>
            <para>
            In EXCLUSIVE mode, the "period" value will affect what's an acceptable "buffer" value (it appears that the buffer must be at least 4x the period).
            In SHARED mode, it's the other way round, the "period" will be reduced to fit the "buffer" if necessary (with a minimum of the "defperiod" value).
            The system will limit them to an acceptable range, so for example, you could use a very small value (eg. 0.0001) for both, to get the minimum possible latency.
            </para>
            <para>
            Note: When initializing an input (capture or loopback) device, it might be the case, that the device is automatically muted once initialized.
            You can use the <see cref="M:ManagedBass.Wasapi.BassWasapi.GetMute(ManagedBass.Wasapi.WasapiVolumeTypes)" />/<see cref="M:ManagedBass.Wasapi.BassWasapi.SetMute(ManagedBass.Wasapi.WasapiVolumeTypes,System.Boolean)" /> methods to check and probably toggle this.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Wasapi">WASAPI is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Device">The <paramref name="Device" /> number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">A device has already been initialized. You must call <see cref="M:ManagedBass.Wasapi.BassWasapi.Free" /> before you can initialize again.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified (a <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/> must be provided for an input device).</exception>
            <exception cref="F:ManagedBass.Errors.Driver">The driver could not be initialized.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The specified format is not supported by the device. If the <see cref="F:ManagedBass.Wasapi.WasapiInitFlags.AutoFormat"/> flag was specified, no other format could be found either.</exception>
            <exception cref="F:ManagedBass.Errors.Init">The <see cref="F:ManagedBass.Bass.NoSoundDevice"/> has not been initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Busy">The device is busy (eg. in "exclusive" use by another process).</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery error.</exception>
        </member>
        <member name="P:ManagedBass.Wasapi.BassWasapi.IsStarted">
            <summary>
            Checks, if the current Wasapi device/driver (endpoint) has been already started (via <see cref="M:ManagedBass.Wasapi.BassWasapi.Start" />).
            </summary>
            <returns>Returns <see langword="true" />, if the device has been started, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Start">
            <summary>
            Starts processing the current Wasapi device/driver (endpoint).
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Before starting the device, it must be initialized using <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" />.
            Use <see cref="M:ManagedBass.Wasapi.BassWasapi.Stop(System.Boolean)" /> to stop processing the device.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.Stop(System.Boolean)">
            <summary>
            Stops the current Wasapi device/driver (endpoint).
            </summary>
            <param name="Reset">Flush the device buffer?
            <para>
            <see langword="true" /> will clear the output buffer.
            Otherwise it is like pausing, eg. <see cref="M:ManagedBass.Wasapi.BassWasapi.Start" /> will resume playing the buffered data.
            </para>
            </param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If the device buffer is left unflushed (<paramref name="Reset"/> = <see langword="false"/>), a subsequent <see cref="M:ManagedBass.Wasapi.BassWasapi.Start" /> call will resume things with the buffered data, otherwise it will resume with fresh data.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The device hasn't been started.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetLevel">
            <summary>
            Retrieves the level (peak amplitude) of the current Wasapi device/driver (endpoint).
            </summary>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" />, but it gets the level from the devices's buffer instead of decoding data from a channel, which means that the device doesn't miss out on any data. 
            The <see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer"/> flag needs to have been specified in the device's initialization to enable the use of this function.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device was not initialized using buffering (<see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer"/>).</exception>
        </member>
        <member name="M:ManagedBass.Wasapi.BassWasapi.GetLevel(System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retreives the level
            </summary>
            <param name="Levels">An array to receive the levels.</param>
            <param name="Length"></param>
            <param name="Flags"></param>
            <returns>true on success, else false. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the Error code.</returns>
            <remarks>
            This function uses <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)"/> internally, so it behaves identically to that.
            The <see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer"/> flag needs to have been specified in the device's initialization to enable the use of this function.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The device was not initialized using buffering (<see cref="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer"/>).</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length"/> is not valid.</exception>
        </member>
        <member name="P:ManagedBass.Wasapi.BassWasapi.Version">
            <summary>
            Gets the Version of BassWasapi that is loaded.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiNotifyProcedure">
            <summary>
            User defined notification callback function.
            </summary>
            <param name="Notify">The notification</param>
            <param name="Device">The device that the notification applies to.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Wasapi.BassWasapi.SetNotify(ManagedBass.Wasapi.WasapiNotifyProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiProcedure">
            <summary>
            User defined WASAPI output/input processing callback function (to be used with <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" />).
            </summary>
            <param name="Buffer">Pointer to the buffer to put the sample data for an output device, or to get the data from an input device. The sample data is always 32-bit floating-point.</param>
            <param name="Length">The number of bytes to process.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> was called.</param>
            <returns>In the case of an output device, the number of bytes written to the buffer. In the case of an input device, 0 = stop the device, else continue.</returns>
            <remarks>
            <para>
            An output/input processing function should obviously be as quick as possible, to avoid buffer underruns (output) or overruns (input).
            Using a larger buffer makes that less crucial.
            <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check how much data is buffered.
            </para>
            <para>
            An output device's <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/> may return less data than requested, but be careful not to do so by too much, too often.
            If the buffer gets exhausted, output will stall until more data is provided.
            If you do return less than the requested amount of data, the number of bytes should still equate to a whole number of samples.
            </para>
            <para>
            When multiple channels are used, the sample data of the channels is interleaved.
            For example, with 2 channels (ie. stereo), the sample data would be arranged as channel 1, channel 2, channel 1, channel 2, channel 1, etc.
            </para>
            <para>When an output channel needs to be empty/silent but still enabled, the channel's function could fill the buffer with 0s to achieve that.</para>
            <para>Do not call <see cref="M:ManagedBass.Wasapi.BassWasapi.Free" /> from within a callback function.</para>
            <para>
            Prior to calling this function, BassWasapi will set the thread's device context to the device that the channel belongs to.
            So when using multiple devices, <see cref="P:ManagedBass.Wasapi.BassWasapi.CurrentDevice" /> can be used to determine which device the channel is on.
            </para>
            <para>
            It is not supported to change the <see cref="T:ManagedBass.Wasapi.WasapiProcedure" /> once a device was initialized via <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" />.
            If you need to change some internal processing logic during processing, you might use some kind of "if" statements within this callback procedure.
            </para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Unknown">
            <summary>
            Unknown flags. 
            e.g. the WASAPI device is not present.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Enabled">
            <summary>
            The WASAPI device is enabled (active).
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Default">
            <summary>
            The WASAPI device is the default device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Initialized">
            <summary>
            The WASAPI device is initialized.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Loopback">
            <summary>
            The WASAPI device is a loopback device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Input">
            <summary>
            The WASAPI device is an Input (capture) device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Unplugged">
            <summary>
            The WASAPI device is unplugged.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceInfoFlags.Disabled">
            <summary>
            The WASAPI device is disabled.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiDeviceType">
            <summary>
            Wasapi Device Type to be used with <see cref="T:ManagedBass.Wasapi.WasapiDeviceInfo"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.NetworkDevice">
            <summary>
            A network device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Speakers">
            <summary>
            A speakers device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.LineLevel">
            <summary>
            A line level device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Headphones">
            <summary>
            A headphone device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Microphone">
            <summary>
            A microphone device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Headset">
            <summary>
            A headset device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Handset">
            <summary>
            A handset device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Digital">
            <summary>
            A digital device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.SPDIF">
            <summary>
            A S/PDIF device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.HDMI">
            <summary>
            A HDMI device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiDeviceType.Unknown">
            <summary>
            An unknown device.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiFormat">
            <summary>
            BassWasapi sample formats to be used with <see cref="T:ManagedBass.Wasapi.WasapiInfo" /> and <see cref="M:ManagedBass.Wasapi.BassWasapi.GetInfo(ManagedBass.Wasapi.WasapiInfo@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiFormat.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiFormat.Float">
            <summary>
            32-bit floating-point.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiFormat.Bit8">
            <summary>
            8-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiFormat.Bit16">
            <summary>
            16-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiFormat.Bit24">
            <summary>
            24-bit integer.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiFormat.Bit32">
            <summary>
            32-bit integer.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiInitFlags">
            <summary>
            BassWasapi initialization flags to be used with <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiInitFlags.Shared">
            <summary>
            Init the device (endpoint) in shared mode.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiInitFlags.Exclusive">
            <summary>
            Init the device (endpoint) in exclusive mode.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiInitFlags.AutoFormat">
            <summary>
            Automatically choose another sample format if the specified format is not supported.
            If possible, a higher sample rate than freq will be used, rather than a lower one.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiInitFlags.Buffer">
            <summary>
            Enable double buffering, for use by <see cref="M:ManagedBass.Wasapi.BassWasapi.GetData(System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Wasapi.BassWasapi.GetLevel"/>. 
            This requires the BASS <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device to have been initilized, via <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.
            Internally, a BASS stream is used for that, so the usual <see cref="T:ManagedBass.DataFlags"/> flags are supported.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiInitFlags.EventDriven">
            <summary>
            Enables the event-driven WASAPI system.
            It is only supported when a <see cref="T:ManagedBass.Wasapi.WasapiProcedure"/> function is provided, ie. not when using <see cref="M:ManagedBass.Wasapi.BassWasapi.PutData(System.IntPtr,System.Int32)"/>.
            When used with shared mode, the User-provided 'Buffer' and 'period' lengths are ignored 
            and WASAPI decides what Buffer to use (<see cref="P:ManagedBass.Wasapi.BassWasapi.Info"/> can be used to check that).
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiNotificationType">
            <summary>
            BassWasapi Notification type to be used with <see cref="M:ManagedBass.Wasapi.BassWasapi.SetNotify(ManagedBass.Wasapi.WasapiNotifyProcedure,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiNotificationType.Enabled">
            <summary>
            The device has been enabled.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiNotificationType.Disabled">
            <summary>
            The device has been disabled.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiNotificationType.DefaultOutput">
            <summary>
            The device is now the default Input device.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiNotificationType.DefaultInput">
            <summary>
            The device is now the default output device.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiVolumeTypes">
            <summary>
            The BassWasapi Volume curve to use with <see cref="M:ManagedBass.Wasapi.BassWasapi.GetVolume(ManagedBass.Wasapi.WasapiVolumeTypes)" /> and <see cref="M:ManagedBass.Wasapi.BassWasapi.SetVolume(ManagedBass.Wasapi.WasapiVolumeTypes,System.Single)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiVolumeTypes.Device">
            <summary>
            Use the device volume.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiVolumeTypes.LogaritmicCurve">
            <summary>
            Logarithmic curve.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiVolumeTypes.LinearCurve">
            <summary>
            Linear curve.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiVolumeTypes.WindowsHybridCurve">
            <summary>
            Windows' hybrid curve.
            </summary>
        </member>
        <member name="F:ManagedBass.Wasapi.WasapiVolumeTypes.Session">
            <summary>
            Use the session volume.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiDeviceInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Wasapi.BassWasapi.GetDeviceInfo(System.Int32,ManagedBass.Wasapi.WasapiDeviceInfo@)" /> to retrieve information on a Wasapi device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.Type">
            <summary>
            The Type of the devices.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.MinimumUpdatePeriod">
            <summary>
            The minimum update period (in seconds) of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.DefaultUpdatePeriod">
            <summary>
            The default update period (in seconds) of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.MixFrequency">
            <summary>
            The shared-mode format mixers sample rate.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.MixChannels">
            <summary>
            The shared-mode format mixers number of channels.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.Name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.ID">
            <summary>
            The ID of the driver being used.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsDefault">
            <summary>
            Gets whether the device is the system default device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsEnabled">
            <summary>
            Gets whether the device is enabled.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsInput">
            <summary>
            Gets whether the device is input device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsLoopback">
            <summary>
            Gets whether the device is a loopback device (output capture).
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsInitialized">
            <summary>
            Gets whether the device is initialized (using <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)"/>).
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsUnplugged">
            <summary>
            Gets whether the device is unplugged.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiDeviceInfo.IsDisabled">
            <summary>
            Gets whether the device is disabled.
            </summary>
        </member>
        <member name="M:ManagedBass.Wasapi.WasapiDeviceInfo.ToString">
            <summary>
            Returns the <see cref="P:ManagedBass.Wasapi.WasapiDeviceInfo.Name"/> of the device.
            </summary>
        </member>
        <member name="T:ManagedBass.Wasapi.WasapiInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Wasapi.BassWasapi.GetInfo(ManagedBass.Wasapi.WasapiInfo@)" /> to retrieve information on the current device.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.InitFlags">
            <summary>
            The flags parameter of the <see cref="M:ManagedBass.Wasapi.BassWasapi.Init(System.Int32,System.Int32,System.Int32,ManagedBass.Wasapi.WasapiInitFlags,System.Single,System.Single,ManagedBass.Wasapi.WasapiProcedure,System.IntPtr)" /> call.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.Format">
            <summary>
            The device's sample format used.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.Frequency">
            <summary>
            The sample rate used.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.Channels">
            <summary>
            The number of channels used (1 = mono, 2 = stereo, etc.).
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.BufferLength">
            <summary>
            The buffer size in bytes.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.MaxVolume">
            <summary>
            The maximum volume setting in dB.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.MinVolume">
            <summary>
            The minimum volume setting in dB.
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.VolumeStep">
            <summary>
            The volume step size in dB. 
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.IsEventDriven">
            <summary>
            Is the device used in event-driven mode?
            </summary>
        </member>
        <member name="P:ManagedBass.Wasapi.WasapiInfo.IsExclusive">
            <summary>
            Is the device used in exclusive mode?
            </summary>
        </member>
        <member name="T:ManagedBass.Winamp.BassWinamp">
            <summary>
            BassWinamp: Wraps bass_winamp.dll.
            </summary>
            <remarks>
            Adds Winamp Input plugins support.
            BassWinamp doesn't support Bass plugin system.
            </remarks>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Winamp.BassWinamp.InputTimeout">
            <summary>
            Winamp input timeout (in milliseconds) to wait until timing out, because the plugin is not using the output system.
            </summary>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.AboutPlugin(System.Int32,System.IntPtr)">
            <summary>
            Shows the about dialog of the loaded Winamp input plug-in.
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <param name="Window">The application's main window... <see cref="F:System.IntPtr.Zero"/> = the current foreground window.</param>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.ConfigPlugin(System.Int32,System.IntPtr)">
            <summary>
            Shows the configuration dialog of the loaded Winamp input plug-in.
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <param name="Window">The application's main window... <see cref="F:System.IntPtr.Zero"/> = the current foreground window.</param>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.FindPlugins(System.String,ManagedBass.Winamp.WinampFindPluginFlags)">
            <summary>
            Gets a list of all winamp input plug-ins in a given directory.
            <see cref="F:ManagedBass.Winamp.WinampFindPluginFlags.CommaList"/> is ignored.
            </summary>
            <param name="PluginDirectory">The path of the directory to search in.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.Winamp.WinampFindPluginFlags"/>.</param>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.GetExtentions(System.Int32)">
            <summary>
            Gets the supported file filter extensions of the given winamp input plug-in.
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <returns>Returns a array of strings representing the supported extensions of the winamp input plugin.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.IsSeekable(System.Int32)">
            <summary>
            Returns weather the Winamp input plugin supports seeking?
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <returns><see langword="true" /> if the input plugin support seeking, else <see langword="false" /> is returned.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.GetFileInfo(System.String,System.String@,System.Int32@)">
            <summary>
            Returns information about a given file.
            </summary>
            <param name="File">The name of the file to retrieve the information from.</param>
            <param name="Title">Returns the title of the given file.</param>
            <param name="LengthMs">Returns the length of the given file in milliseconds.</param>
            <returns><see langword="true" /> if the information was retrieved successfully, else <see langword="false" /> is returned.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.GetName(System.Int32)">
            <summary>
            Gets the name of the winamp input plugin.
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <returns>The name of the plugin, or <see langword="null" /> if the call failed.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.GetUsesOutput(System.Int32)">
            <summary>
            Returns weather the Winamp input plugin make use of the winamp output?
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <returns><see langword="true" /> if the input plugin uses output, else <see langword="false" /> is returned.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.GetVersion(System.Int32)">
            <summary>
            Gets the version of a loaded Winamp input plug-in.
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
            <returns>The version number. HIWORD = Major, LOWORD = Minor.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.InfoDialog(System.String,System.IntPtr)">
            <summary>
            Shows the Winamp input plugin information dialog for a given file (like pressing Alt+3 in Winamp).
            </summary>
            <param name="File">The name of the file to retrieve the information from.</param>
            <param name="Window">The application's main window... <see cref="F:System.IntPtr.Zero"/> = the current foreground window.</param>
            <returns><see langword="true" /> if the info dialog was called successfully, else <see langword="false" /> is returned.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.LoadPlugin(System.String)">
            <summary>
            Loads a Winamp input plug-in.
            </summary>
            <param name="File">The file name of the plug-in to load.</param>
            <returns>The handle of the loaded winamp input plug-in or 0 if it failed.</returns>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.UnloadPlugin(System.Int32)">
            <summary>
            Unloads a Winamp input plug-in which had been loaded via <see cref="M:ManagedBass.Winamp.BassWinamp.LoadPlugin(System.String)" /> before.
            </summary>
            <param name="Handle">The handle of the winamp input plugin.</param>
        </member>
        <member name="M:ManagedBass.Winamp.BassWinamp.CreateStream(System.String,ManagedBass.BassFlags)">
            <summary>
            Creates a stream from a Winamp input plug-in.
            </summary>
            <param name="FileName">Filename for which a stream should be created.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
        </member>
        <member name="T:ManagedBass.Winamp.WinampFindPluginFlags">
            <summary>
            Flags to be used with <see cref="M:ManagedBass.Winamp.BassWinamp.FindPlugins(System.String,ManagedBass.Winamp.WinampFindPluginFlags)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Winamp.WinampFindPluginFlags.Input">
            <summary>
            Find input plug-ins. Should and must always be specified.
            </summary>
        </member>
        <member name="F:ManagedBass.Winamp.WinampFindPluginFlags.Recursive">
            <summary>
            Recursively loop through all sub-directories as well.
            </summary>
        </member>
        <member name="F:ManagedBass.Winamp.WinampFindPluginFlags.CommaList">
            <summary>
            Return the result as a comma seperated list in the format: item1,item2,"item with , commas",item4,"item with space"
            <para>If not specified a list of null-terminated Ansi strings will be returned ending with a double-null.</para>
            </summary>
        </member>
        <member name="T:ManagedBass.Wma.BassWma">
            <summary>
            Wraps basswma.dll
            </summary>
            <remarks>
            Supports: .wma, .wmv
            </remarks>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Wma.BassWma.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.GetWMObject(System.Int32)">
            <summary>
            Retrieves a pointer to the IWMReader interface of a WMA stream, or IWMWriter interface of a WMA encoder.
            </summary>
            <param name="Handle">The WMA stream or encoder handle.</param>
            <returns>If succesful, then a pointer to the requested object is returned, otherwise <see cref="F:System.IntPtr.Zero" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function allows those that are familiar with the Windows Media Format SDK to access the internal object interface, for extra functionality. 
            If you create any objects through a retrieved interface, make sure you release the objects before calling <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" />.
            </para>
            <para>See the Windows Media Format SDK for information on the IWMReader and associated interfaces.</para>
            <para>
            When streaming local (not internet) files, this function may actually return an IWMSyncReader interface instead of an IWMReader interface. 
            The type of interface can be determined by querying other interfaces from it.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.String,ManagedBass.BassFlags,System.String,System.String)">
            <summary>
            Streams a WMA file authenticating using given <paramref name="UserName"/> and <paramref name="Password"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.IntPtr,System.Int64,ManagedBass.BassFlags,System.String,System.String)">
            <summary>
            Streams a WMA file from Memory (<see cref="T:System.IntPtr"/>) authenticating using given <paramref name="UserName"/> and <paramref name="Password"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.CreateStream(System.Byte[],System.Int64,ManagedBass.BassFlags,System.String,System.String)">
            <summary>
            Streams a WMA file from Memory (byte[]) authenticating using given <paramref name="UserName"/> and <paramref name="Password"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Buffer">Pointer to the buffer containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>There is generally no need to call this function if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag has been set on the encoder, as the encoder will automatically be fed the data that its source BASS channel produces.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Buffer">byte[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>There is generally no need to call this function if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag has been set on the encoder, as the encoder will automatically be fed the data that its source BASS channel produces.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Buffer">short[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>There is generally no need to call this function if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag has been set on the encoder, as the encoder will automatically be fed the data that its source BASS channel produces.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Buffer">int[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>There is generally no need to call this function if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag has been set on the encoder, as the encoder will automatically be fed the data that its source BASS channel produces.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.Single[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Buffer">float[] containing the sample data.</param>
            <param name="Length">The number of BYTES in the buffer.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>There is generally no need to call this function if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag has been set on the encoder, as the encoder will automatically be fed the data that its source BASS channel produces.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeOpen(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,ManagedBass.Wma.WMEncodeProcedure,System.IntPtr)">
            <summary>
            Initializes WMA encoding to a UserName defined function.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/></param>
            <param name="Bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="Procedure">The UserName defined function to receive the encoded data (see <see cref="T:ManagedBass.Wma.WMEncodeProcedure" />).</param>
            <param name="User">User instance data to Password to the callback function.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Encoding to a UserName defined function allows any storage or delivery method to be used for the encoded WMA data. For example, encoding to memory.</para>
            <para>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format and bitrate.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeOpenFile(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.String)">
            <summary>
            Initializes WMA encoding to a file.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/>.</param>
            <param name="Bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="File">The filename to write.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format and bitrate.</exception>
            <exception cref="F:ManagedBass.Errors.Create">Could not create the file to write the WMA stream.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeOpenNetwork(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes WMA encoding to the network.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/>.</param>
            <param name="Bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="Port">The port number for clients to conenct to... 0 = let the system choose a port.</param>
            <param name="Clients">The maximum number of clients (up to 50) that can be connected.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If you chose to let the system select a port, you can retrieve the port number using <see cref="M:ManagedBass.Wma.BassWma.EncodeGetPort(System.Int32)" />.</para>
            <para>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            VBR encoding is not recommended for network encoding.
            </para>
            <para>The <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Queue"/> flag is not necessary with this function as the data is always queued and fed to the encoder asynchronously.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format and bitrate.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Clients" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeOpenNetwork(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Initializes WMA encoding to the network, using multiple bitrates.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/>.</param>
            <param name="Bitrates">Array of encoding bitrates (in bits per second, e.g. 128000) to use, terminated with a 0 element (so the number of elements in the array must be one more than the effective bitrates used).</param>
            <param name="Port">The port number for clients to conenct to... 0 = let the system choose a port.</param>
            <param name="Clients">The maximum number of clients (up to 50) that can be connected.</param>
            <returns>If succesful, the new encoder's handle is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:ManagedBass.Wma.BassWma.EncodeOpenNetwork(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.Int32,System.Int32)" />, but with the additional ability to specify multiple bitrates.
            <para>When encoding/broadcasting in multiple bitrates, the UserName will automatically get the best available bitrate for their bandwidth.</para>
            <para>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            VBR encoding is not recommended for network encoding.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format and bitrate.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Clients" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeOpenPublish(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.String,System.String,System.String)">
            <summary>
            Initializes WMA encoding to a publishing point on a Windows Media server.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/>.</param>
            <param name="Bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="Url">URL of the publishing point on the Windows Media server.</param>
            <param name="UserName">Username to use in connecting to the server... if either this or Password is <see langword="null" />, then no username/password is sent to the server.</param>
            <param name="Password">Password to use in connecting to the server.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            VBR encoding is not recommended for network encoding.</para>
            <para>The <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Queue"/> flag is not necessary with this function as the data is always queued and fed to the encoder asynchronously.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">Could not connect to the server.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format and bitrate.</exception>
            <exception cref="F:ManagedBass.Errors.WmaAccesDenied">Access was denied. Check the <paramref name="UserName" /> and <paramref name="Password" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeOpenPublish(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32[],System.String,System.String,System.String)">
            <summary>
            Initializes WMA encoding to a publishing point on a Windows Media server, using multiple bitrates.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/>.</param>
            <param name="Bitrates">Array of encoding bitrates to use, terminated with a 0 (in bits per second, e.g. 128000).</param>
            <param name="Url">URL of the publishing point on the Windows Media server.</param>
            <param name="UserName">Username to use in connecting to the server... if either this or Password is <see langword="null" />, then no username/password is sent to the server.</param>
            <param name="Password">Password to use in connecting to the server.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:ManagedBass.Wma.BassWma.EncodeOpenPublish(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.String,System.String,System.String)"/>, but with the additional ability to specify multiple bitrates.
            <para>When encoding/broadcasting in multiple bitrates, the user will automatically get the best available bitrate for their bandwidth.</para>
            <para>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            VBR encoding is not recommended for network encoding.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">Could not connect to the server.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format and bitrate.</exception>
            <exception cref="F:ManagedBass.Errors.WmaAccesDenied">Access was denied. Check the <paramref name="UserName" /> and <paramref name="Password" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeSetNotify(System.Int32,ManagedBass.Wma.ClientConnectProcedure,System.IntPtr)">
            <summary>
            Sets a client connection notification callback on a network encoder.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Procedure">User defined notification function... <see langword="null" /> = disable notifications.</param>
            <param name="User">User instance data to Password to the callback function.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>A previously set notification callback can be changed (or removed) at any time, by calling this function again.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder is not a network encoder, so no port is being used.</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,ManagedBass.Wma.WMATagFormat)">
            <summary>
            Sets a tag in a WMA encoding.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Tag">The pointer to the tag to set.</param>
            <param name="Value">The pointer to the tag's text/data.</param>
            <param name="Format">The format of the tag and value strings.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Where the tags are located in the encoded stream depends on when this function is used.
            Calling this function before beginning encoding data puts the tags in the stream's header.
            Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> has been called.</para>
            <para>
            To set tags mid-stream (after encoding has begun), the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Script"/> flag needs to have been specified in the encoder's creation.
            A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).
            </para>
            <para>
            When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not.
            So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).
            </para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> (with <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/>).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Tag" /> and/or <paramref name="Value" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeSetTag(System.Int32,System.String,System.String)">
            <summary>
            Sets a tag in a WMA encoding.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Tag">The tag to set.</param>
            <param name="Value">The tag's text/data.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Where the tags are located in the encoded stream depends on when this function is used.
            Calling this function before beginning encoding data puts the tags in the stream's header.
            Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> has been called.</para>
            <para>
            To set tags mid-stream (after encoding has begun), the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Script"/> flag needs to have been specified in the encoder's creation.
            A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).
            </para>
            <para>
            When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not.
            So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).
            </para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> (with <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/>).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Tag" /> and/or <paramref name="Value" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeSetTag(System.Int32,System.String,System.IntPtr,System.Int32)">
            <summary>
            Sets a binary tag in a WMA encoding.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Tag">The tag to set.</param>
            <param name="Length">The number of bytes provided as binary data in the tag.</param>
            <param name="Value">The pointer to the binary tag's data.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Where the tags are located in the encoded stream depends on when this function is used.
            Calling this function before beginning encoding data puts the tags in the stream's header.
            Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> has been called.</para>
            <para>
            To set tags mid-stream (after encoding has begun), the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Script"/> flag needs to have been specified in the encoder's creation.
            A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).
            </para>
            <para>
            When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not.
            So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).
            </para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> (with <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/>).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Tag" /> and/or <paramref name="Value" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeSetTag(System.Int32,System.String,System.Byte[],System.Int32)">
            <summary>
            Sets a binary tag in a WMA encoding.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <param name="Tag">The tag to set.</param>
            <param name="Length">The number of bytes provided as binary data in the tag.</param>
            <param name="Value">The byte[] containing the binary tag's data.</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Where the tags are located in the encoded stream depends on when this function is used.
            Calling this function before beginning encoding data puts the tags in the stream's header.
            Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:ManagedBass.Wma.BassWma.EncodeWrite(System.Int32,System.IntPtr,System.Int32)" /> has been called.</para>
            <para>
            To set tags mid-stream (after encoding has begun), the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Script"/> flag needs to have been specified in the encoder's creation.
            A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).
            </para>
            <para>
            When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not.
            So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).
            </para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> (with <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/>).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Tag" /> and/or <paramref name="Value" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeGetClients(System.Int32)">
            <summary>
            Retrieves the number of clients currently connected to the encoder.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <returns>If succesful, the number of clients is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder was not created with <see cref="M:ManagedBass.Wma.BassWma.EncodeOpenNetwork(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.Int32,System.Int32)" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeGetPort(System.Int32)">
            <summary>
            Retrieves the network port for clients to connect to.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <returns>If succesful, the port number is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            If you have choosen to let the system select a port (e.g. in your <see cref="M:ManagedBass.Wma.BassWma.EncodeOpenNetwork(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,System.Int32,System.Int32)" /> or <see cref="M:ManagedBass.Wma.BassWma.EncodeOpenNetwork(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32[],System.Int32,System.Int32)" />), 
            this is the function to retrieve the port actually being used.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The encoder is not a network encoder, so no port is being used.</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeClose(System.Int32)">
            <summary>
            Finishes encoding and closes the file or network port.
            </summary>
            <param name="Handle">The encoder handle.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.EncodeGetRates(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags)">
            <summary>
            Retrieves the WMA encoding bitrates available for a specified sample format.
            </summary>
            <param name="Frequency">The sample rate in Hz, or a BASS channel handle if the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Source"/> flag is specified.</param>
            <param name="Channels">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Wma.WMAEncodeFlags"/>.</param>
            <returns>If succesful, an array of the available bitrates is returned (int[], in bits per second), else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>When requesting VBR rates, the rates returned are quality settings. For example, 10 = 10% quality, 25 = 25% quality, etc... 100% quality is lossless.</para>
            <para>
            The WMA codec expects 16-bit or 24-bit sample data depending on the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag, but BassWma will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            Of course, it makes little sense to encode 8-bit or 16-bit data in 24-bit.
            </para>
            <para>
            The WMA codec currently supports the following sample rates: 8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000.
            And the following number of channels: 1, 2, 6, 8.
            But not all combinations of these are supported.
            To encode other sample formats, the data will first have to be resampled to a supported format.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.WM9">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">No codec could be found to support the specified sample format.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Wma.BassWma.CanSeekNetworkStreams">
            <summary>
            Enable network seeking?
            seek (bool): If true seeking in network files/streams is enabled (default is false).
            If true, it allows seeking before the entire file has been downloaded/cached.
            Seeking is slow that way, so it's disabled by default.
            </summary>
        </member>
        <member name="P:ManagedBass.Wma.BassWma.PlayWMVAudio">
            <summary>
            Play audio from WMV (video) files?
            playwmv (bool): If true (default) BASSWMA will play the audio from WMV video files.
            If false WMV files will not be played.
            </summary>
        </member>
        <member name="P:ManagedBass.Wma.BassWma.PrebufferInternetStreams">
            <summary>
            Prebuffer internet streams on creation, before returning from BassWma.StreamCreateFile()?
            prebuf (bool): The Windows Media modules must prebuffer a stream before starting decoding/playback of it.
            This option determines when/where to wait for that to be completed.
            The Windows Media modules must prebuffer a stream before starting decoding/playback of it.
            This option determines whether the stream creation function (eg. BassWma.CreateStream())
            will wait for the prebuffering to complete before returning.
            If playback of a stream is attempted before it has prebuffered,
            it will stall and then resume once it has finished prebuffering.
            The prebuffering progress can be monitored via Bass.StreamGetFilePosition() (FileStreamPosition.WmaBuffer).
            This option is enabled by default.
            </summary>
        </member>
        <member name="P:ManagedBass.Wma.BassWma.UseBassFileHandling">
            <summary>
            Use BASS file handling.
            bassfile (bool): Default is disabled (false).
            When enabled (true) BASSWMA uses BASS's file routines when playing local files.
            It uses the IStream interface to do that.
            This would also allow to support the "offset" parameter for WMA files with Bass.CreateStream().
            The downside of enabling this feature is, that it stops playback while encoding from working.
            </summary>
        </member>
        <member name="P:ManagedBass.Wma.BassWma.AsyncDecoding">
            <summary>
            Use a seperate thread to decode the data?
            async (bool): If true BASSWMA will decode the data in a seperate thread.
            If false (default) the normal file system will be used.
            The WM decoder can by synchronous (decodes data on demand) or asynchronous (decodes in the background).
            With the background decoding, BASSWMA buffers the data that it receives from the decoder for the STREAMPROC to access.
            The start of playback/seeking may well be slightly delayed due to there being no data available immediately.
            Internet streams are only supported by the asynchronous system,
            but local files can use either, and BASSWMA uses the synchronous system by default.
            </summary>
        </member>
        <member name="M:ManagedBass.Wma.BassWma.GetTags(System.String)">
            <summary>
            Get the tags from a file, can be used on DRM protected files (not thread-safe!).
            </summary>
            <param name="File">Filename from which to get the tags.</param>
            <returns>If succesful, an array of the requested tags is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function gives the same tags as <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" /> with <see cref="F:ManagedBass.TagType.WMA"/>, which is a pointer to a series of null-terminated UTF-8 strings (converted to string[]), the final string ending with a double null. 
            Unlike <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />, this function can also be used with DRM-protected WMA files without a DRM licence, as it does not require a stream to be created.
            </remarks>
            <exception cref="F:ManagedBass.Errors.WmaCodec">The Windows Media modules (v9 or above) are not installed.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened, or it is not a WMA file.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="T:ManagedBass.Wma.ClientConnectProcedure">
            <summary>
            User defined client connection notification callback function.
            </summary>
            <param name="Handle">The encoder handle (as returned by <see cref="M:ManagedBass.Wma.BassWma.EncodeSetNotify(System.Int32,ManagedBass.Wma.ClientConnectProcedure,System.IntPtr)" />).</param>
            <param name="Connect">The client's IP address... "xxx.xxx.xxx.xxx:port".</param>
            <param name="IP">The client is connecting?</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Wma.BassWma.EncodeSetNotify(System.Int32,ManagedBass.Wma.ClientConnectProcedure,System.IntPtr)" /> was called.</param>
            <remarks>A client connection notification can be used to keep track of who's connected, where they're from, and for long they've been connected.</remarks>
        </member>
        <member name="T:ManagedBass.Wma.WMEncodeProcedure">
            <summary>
            Encoded data processing callback function.
            </summary>
            <param name="Handle">The encoder handle (as returned by <see cref="M:ManagedBass.Wma.BassWma.EncodeOpen(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,ManagedBass.Wma.WMEncodeProcedure,System.IntPtr)" />).</param>
            <param name="Type">The type of data to process</param>
            <param name="Buffer">The pointer to the data to process. The buffer can contain the sample data or the header. The sample data is in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed.</param>
            <param name="Length">The number of bytes in the buffer.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Wma.BassWma.EncodeOpen(System.Int32,System.Int32,ManagedBass.Wma.WMAEncodeFlags,System.Int32,ManagedBass.Wma.WMEncodeProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            <para>
            When encoding begins, an initial header is given. When encoding is completed, an updated header is given (with the duration info, etc.).
            When encoding to a file (whether that's on disk or not), the initial header should be replaced by the updated one.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Wma.WMAEncodeFlags">
            <summary>
            WMA encoding flags.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Unicode">
            <summary>
            File is a Unicode (16-bit characters) filename.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Default">
            <summary>
            Default encoding, no tags.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.RatesCBR">
            <summary>
            GetRates: get available CBR quality settings.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Byte">
            <summary>
            8 bit sample data.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Float">
            <summary>
            32-bit floating-point sample data.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Standard">
            <summary>
            Standard WMA encoding.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Professional">
            <summary>
            WMA Professional encoding.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit">
            <summary>
             Enable 24-bit encoding.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.PCM">
            <summary>
            Save uncompressed PCM data.
            </summary>
            <remarks>
            When the sample data is floating-point (<see cref="F:ManagedBass.Wma.WMAEncodeFlags.Float"/> flag is used), the <see cref="F:ManagedBass.Wma.WMAEncodeFlags.Encode24Bit"/> flag is considered;
            24-bit data is written with it and 16-bit without.
            The "bitrate" parameter is ignored, except that it should be non-0.
            </remarks>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.RatesVBR">
            <summary>
            GetRates: get available VBR quality settings.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Script">
            <summary>
            Enable the specification of tags mid-stream (after encoding has begun).
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Queue">
            <summary>
            Queue data to feed encoder asynchronously
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMAEncodeFlags.Source">
            <summary>
            Use a BASS channel as source (provided in Frequency parameter).
            Channels parameter is ignored.
            If the BASSenc add-on is loaded, then the <see cref="P:ManagedBass.Enc.BassEnc.DSPPriority" /> setting is used to determine where in the channel's DSP chain the encoding is performed, otherwise priority -1000 is used.
            </summary>
        </member>
        <member name="T:ManagedBass.Wma.WMATagFormat">
            <summary>
            The "type" of the tag and values strings for use with <see cref="M:ManagedBass.Wma.BassWma.EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,ManagedBass.Wma.WMATagFormat)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMATagFormat.Ansi">
            <summary>
            ANSI strings.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMATagFormat.Unicode">
            <summary>
            Unicode (UTF-16) strings (recommended to be used with .Net).
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMATagFormat.Utf8">
            <summary>
            UTF-8 strings.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMATagFormat.Binary">
            <summary>
            Write a binary tag.
            <para>The length of the binary data is given in the high word.</para>
            </summary>
        </member>
        <member name="T:ManagedBass.Wma.WMEncodeType">
            <summary>
            WMA encoding callback flags for use with <see cref="T:ManagedBass.Wma.WMEncodeProcedure" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMEncodeType.Header">
            <summary>
            The data in the buffer is the header.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMEncodeType.Data">
            <summary>
            The data in the buffer is encoded sample data.
            </summary>
        </member>
        <member name="F:ManagedBass.Wma.WMEncodeType.Done">
            <summary>
            The encoding has finished... buffer and length will be <see cref="F:System.IntPtr.Zero" /> and 0 respectively.
            </summary>
        </member>
        <member name="T:ManagedBass.Adx.ADXLoopTag">
            <summary>
            ADX Loop tag structure
            </summary>
        </member>
        <member name="F:ManagedBass.Adx.ADXLoopTag.LoopEnabled">
            <summary>
            Is looping is enabled.
            </summary>
        </member>
        <member name="F:ManagedBass.Adx.ADXLoopTag.SampleStart">
            <summary>
            The sample start position.
            </summary>
        </member>
        <member name="F:ManagedBass.Adx.ADXLoopTag.ByteStart">
            <summary>
            The byte start position.
            </summary>
        </member>
        <member name="F:ManagedBass.Adx.ADXLoopTag.SampleEnd">
            <summary>
            The sample end position.
            </summary>
        </member>
        <member name="F:ManagedBass.Adx.ADXLoopTag.ByteEnd">
            <summary>
            The byte end position.
            </summary>
        </member>
        <member name="M:ManagedBass.Adx.ADXLoopTag.Read(System.Int32)">
            <summary>
            Read the tag from a channel.
            </summary>
        </member>
        <member name="T:ManagedBass.Adx.BassAdx">
            <summary>
            Wraps BassAdx
            </summary> 
            <remarks>
            Supports .adx
            </remarks>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.Adx.BassAdx.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Adx.BassAdx.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassAix">
            <summary>
            Wraps BassAix
            </summary> 
            <remarks>
            
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAix.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassAix.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassAix.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassAix.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassAix.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassAix.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassAix.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassAix.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassOfr">
            <summary>
            Wraps BassOfr
            </summary> 
            <remarks>
            Supports .ofr, .ofs
            </remarks>
        </member>
        <member name="M:ManagedBass.BassOfr.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassOfr.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassOfr.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassOfr.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassOfr.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassOfr.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassOfr.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.BassOfr.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="T:ManagedBass.BassZXTune">
            <summary>
            Adds support for chiptune tracker formats to BASS audio library.
            </summary>
        </member>
        <member name="M:ManagedBass.BassZXTune.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassZXTune.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="F:ManagedBass.BassZXTune.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassZXTune.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.BassZXTune.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.BassZXTune.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.BassZXTune.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="T:ManagedBass.WaDsp.BassWaDsp">
            <summary>
            BassWaDsp provides a set of functions for calling Winamp DSP plugins.
            </summary>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ChannelRemoveDSP(System.Int32)">
            <summary>
            Removes a Winamp DSP from the Bass DSP chain which had been set up with <see cref="M:ManagedBass.WaDsp.BassWaDsp.ChannelSetDSP(System.Int32,System.Int32,System.Int32)" /> before.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns><see langword="true" />, if successfully removed, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ChannelSetDSP(System.Int32,System.Int32,System.Int32)">
            <summary>
            Assigns a loaded Winamp DSP to a standard BASS channel as a new DSP.
            <para>This method is pretty close to the <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" /> method (which is in fact internally used) but instead of setting up a user DSP method the Winamp DSP will be set up.</para>
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Handle">The BASS channel handle (HSTREAM, HMUSIC, or HRECORD) which to assign to the Winamp DSP.</param>
            <param name="Priority">The priority of the new DSP, which determines it's position in the Bass DSP chain - DSPs with higher priority are called before those with lower.</param>
            <returns>If succesful, then the new DSP's handle (HDSP) is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>
            The Winamp DSP and this method can be used with 8-bit, 16-bit or float channels.
            Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit and float to 16-bit and back will take place.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> or <paramref name="Handle" /> is not a valid handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Config(System.Int32)">
            <summary>
            Invokes the config dialog of a loaded and started Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The Winamp DSP must have been started via <see cref="M:ManagedBass.WaDsp.BassWaDsp.Start(System.Int32,System.Int32,System.Int32)" /> prior to calling this method.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
            <exception cref="F:ManagedBass.Errors.Start"><see cref="M:ManagedBass.WaDsp.BassWaDsp.Start(System.Int32,System.Int32,System.Int32)" /> has not been called before.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Free">
            <summary>
            Frees all resources used by BASS_WADSP.
            </summary>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.WaDsp.BassWaDsp.Init(System.IntPtr)" /> has not been called before.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.FreeDSP(System.Int32)">
            <summary>
            Frees and unloads a Winamp DSP library from memory which has been loaded with <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" /> before.
            </summary>
            <param name="Plugin">The plugin handle to unload (as returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The Winamp DSP will automatically be stopped, if it was started before.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.GetFakeWinampWnd(System.Int32)">
            <summary>
            Gets the window handle of the fake Winamp window which has been created internally when a Winamp DSP was loaded with <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns>An IntPtr representing the window handle of the fake Winamp window or <see cref="F:System.IntPtr.Zero" /> if an error occured. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other problem (the internal fake Winamp window could not be created).</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.GetModule(System.Int32)">
            <summary>
            Returns the currently selected plugin module of a Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns>The selected module number (first = 0), or -1, if an error occured. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
            <exception cref="F:ManagedBass.Errors.Start"><see cref="M:ManagedBass.WaDsp.BassWaDsp.Start(System.Int32,System.Int32,System.Int32)" /> was not called (no module selected so far).</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.GetModuleCount(System.Int32)">
            <summary>
            Returns the number of modules contained in the loaded Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns>The number of available modules or -1 if an error occured. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>Winamp DSPs might implement multiple different modules within the same DSP plugin.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.GetModuleName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a certain module of a loaded Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Module">The module number to get the name from (the first module is 0).</param>
            <returns>The name of the module on success or <see langword="null" /> on error (or if no module with that number exists). Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Winamp DSPs might provide multiple independent modules.
            You might get the number of available modules with <see cref="M:ManagedBass.WaDsp.BassWaDsp.GetModuleCount(System.Int32)" />.
            However, you can only start one module at a time for a certain Winamp DSP.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Module" /> number is invalid.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.GetModuleNames(System.Int32)">
            <summary>
            Returns all module names of a Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns>All names of all modules contained in the Winamp DSP.</returns>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.GetName(System.Int32)">
            <summary>
            Returns the name of the loaded Winamp DSP plugin.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns>The name of the plugin on success or <see langword="null" /> on error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
        </member>
        <member name="P:ManagedBass.WaDsp.BassWaDsp.Version">
            <summary>
            Gets the version of the bass_wadsp.dll that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Init(System.IntPtr)">
            <summary>
            Initializes BASS_WADSP, call this right after you have called <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.
            </summary>
            <param name="Win">The main window handle of your application or <see cref="F:System.IntPtr.Zero" /> for console applications.</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Already"><see cref="M:ManagedBass.WaDsp.BassWaDsp.Init(System.IntPtr)" /> has already been called and can not be called again.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)">
            <summary>
            Loads a Winamp DSP library.
            </summary>
            <param name="DspFile">The fully qualified path and name of the Winamp DSP library you want to load.</param>
            <param name="X">The X-coordinate of the fake Winamp window to create.</param>
            <param name="Y">The Y-coordinate of the fake Winamp window to create.</param>
            <param name="Width">The width of the fake Winamp window to create.</param>
            <param name="Height">The height of the fake Winamp window to create.</param>
            <param name="Procedure">An optional <see cref="T:ManagedBass.WaDsp.WinampWinProcedure" /> which should be used instead of the internal window process message handler. Or <see langword="null" />, if you want BASS_WADSP to handle it by default.</param>
            <returns>The handle of the loaded plugin, which is needed in all further method calls.</returns>
            <remarks>
            Most Winamp DSP plugins do save their location and visibility state in an own .ini file.
            So the parameters specifying the location and size are in most cases only uses for the first time a plugin is used.
            So don't worry, if they do not take effect.
            <para>In most cases the internal Windows message process handler should be fine and sufficient - however, if you encounter problems you might implement your own.</para>
            <para>Make sure to call <see cref="M:ManagedBass.WaDsp.BassWaDsp.FreeDSP(System.Int32)" /> when the Winamp DSP is not needed anymore and should be unloaded and removed from memory.</para>
            <para>
            Winamp DSPs are designed to run only for one stream.
            So if you have multiple streams or multiple players in your application and you want to use the same Winamp DSP you need to create temporary copies of the library files.
            Then you should load each individual library copy with this function.
            This will enable you to load multiple instances of the same Winamp DSP.
            Each loaded instance can then be used for individual streams.
            </para>
            <para>NOTE: Do not use this method while you have already loaded the same Winamp plugin, as this might result in any unexpected behavior, since some Winamp plugins might crash when they are loaded twice.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="DspFile" /> can not be found or loaded.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="DspFile" /> doesn't seem to be a Winamp DSP library file.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other problem (the internal fake Winamp window could not be created).</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesDSP(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The IntPtr to the memory block containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesDSP(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of byte values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesDSP(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of Int16 values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesDSP(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of Int32 values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesDSP(System.Int32,System.Single[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of float values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesStream(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC" />).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The pointer to the memory block containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>
            The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.
            </returns>
            <remarks>
            This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this.
            In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>
            This method can be used with 8-bit, 16-bit or float channels.
            Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit and float to 16-bit and back will take place.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesStream(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC" />).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of byte values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>
            The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.
            </returns>
            <remarks>
            This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this.
            In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>
            This method can be used with 8-bit, 16-bit or float channels.
            Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit and float to 16-bit and back will take place.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesStream(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC" />).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of Int16 values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>
            The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.
            </returns>
            <remarks>
            This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this.
            In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>
            This method can be used with 8-bit, 16-bit or float channels.
            Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit and float to 16-bit and back will take place.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesStream(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC" />).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of Int32 values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>
            The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.
            </returns>
            <remarks>
            This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this.
            In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>
            This method can be used with 8-bit, 16-bit or float channels.
            Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit and float to 16-bit and back will take place.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.ModifySamplesStream(System.Int32,System.Single[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:ManagedBass.DSPProcedure" /> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC" />).
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Buffer">The array of float values containing the sample data to modify.</param>
            <param name="Length">The number of bytes contained in the buffer.</param>
            <returns>
            The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.
            </returns>
            <remarks>
            This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this.
            In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>
            This method can be used with 8-bit, 16-bit or float channels.
            Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit and float to 16-bit and back will take place.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoFree">
            <summary>
            Free the temporary plugin info resources.
            </summary>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>Should and must be called after <see cref="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoLoad(System.String)" /> when the plugin info is not needed anymore.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoLoad(System.String)" /> has not been called.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoGetModuleCount">
            <summary>
            Returns the number of modules contained in the Winamp DSP which has been loaded into the temporary plugin info workspace.
            </summary>
            <returns>The number of available modules or -1 if an error occured. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>Winamp DSPs might implement multiple different modules within the same DSP plugin.</remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoLoad(System.String)" /> has not been called.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoGetModuleName(System.Int32)">
            <summary>
            Returns the name of a certain module of a Winamp DSP which has been loaded into the temporary plugin info workspace.
            </summary>
            <param name="Module">The module number to get the name from (the first module is 0).</param>
            <returns>The name of the module on success or <see langword="null" /> on error (or if no module with that number exists). Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Winamp DSPs might provide multiple independent modules.
            You might get the number of available modules with <see cref="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoGetModuleCount" />.
            <para>You can use this method in a setup dialog to list all the available modules of a Winamp DSP.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoLoad(System.String)" /> has not been called.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Module" /> number is invalid.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoGetModuleNames">
            <summary>
            Returns all module names of a Winamp DSP which has been loaded into the temporary plugin info workspace.
            </summary>
            <returns>All names of all modules contained in the Winamp DSP.</returns>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoGetName">
            <summary>
            Returns the name of the Winamp DSP plugin which has been loaded into the temporary plugin info workspace.
            </summary>
            <returns>The name of the plugin on success or <see langword="null" /> on error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoLoad(System.String)" /> has not been called.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.PluginInfoLoad(System.String)">
            <summary>
            Loads a Winamp DSP library into the temporary plugin info workspace.
            </summary>
            <param name="DspFile">The fully qualified path and name of the Winamp DSP library you want to load.</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The temporary plugin info workspace can be used to retrieve general information about a Winamp DSP without starting it.
            <para>This method will be used in the same way <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" /> is used.</para>
            <para>NOTE: Do not use this method while you have already loaded the same Winamp plugin (e.g. via <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />) as this might result in any unexpected behavior, since some Winamp plugins might crash when they are loaded twice.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="DspFile" /> can not be found or loaded.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="DspFile" /> doesn't seem to be a Winamp DSP library file.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.SetChannel(System.Int32,System.Int32)">
            <summary>
            Assigns a channel to a Winamp DSP.
            <para>You only need this method, if you do NOT use the default <see cref="M:ManagedBass.WaDsp.BassWaDsp.ChannelSetDSP(System.Int32,System.Int32,System.Int32)" /> method, but use your own DSP callback (see <see cref="T:ManagedBass.DSPProcedure" />).</para>
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Handle">The BASS channel handle (HSTREAM, HMUSIC, or HRECORD) which to assign to the Winamp DSP.</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>You must use this method when implementing your own <see cref="T:ManagedBass.DSPProcedure" /> callback before starting to play the channel.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> or <paramref name="Handle" /> is not a valid handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.SetFileName(System.Int32,System.String)">
            <summary>
            Set the file name for a loaded Winamp DSP plugin.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="File">The file name to set.</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Some Winamp DSPs require or simply display a current playing file name.
            Use this method to set this file name.
            It will then be used in the internal Window message handler for the related fake Winamp windows.
            In most cases it is not required to set any file name at all.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.SetSongTitle(System.Int32,System.String)">
            <summary>
            Set the song title for a loaded Winamp DSP plugin.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Title">The song title to set.</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Some Winamp DSPs require or simply display a current song title.
            Use this method to set this song title.
            It will then be used in the internal Window message handler for the related fake Winamp window.
            In most cases it is not required to set any song title at all - however streaming DSP might use this for updating it's metadata.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Start(System.Int32,System.Int32,System.Int32)">
            <summary>
            Starts a Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <param name="Module">The module number to start (the first module is 0).</param>
            <param name="Handle">The BASS channel handle (HSTREAM, HMUSIC, or HRECORD) for which to start the Winamp DSP. Or 0 if not applicable.</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Winamp DSPs might provide multiple independent modules.
            You might get the number of available modules with <see cref="M:ManagedBass.WaDsp.BassWaDsp.GetModuleCount(System.Int32)" /> or the name of a certain module with <see cref="M:ManagedBass.WaDsp.BassWaDsp.GetModule(System.Int32)" />. 
            However, you can only start one module at a time for a certain Winamp DSP.
            The stream channel is only needed here because some Winamp DSPs might already request some information, which can be provided in this case.
            However, if you don't have created a stream so far, just leave the value to 0 and all is fine.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> or the <paramref name="Handle" /> is not a valid handle.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Module" /> is not a valid module.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The plugin/module was already started (you need to call <see cref="M:ManagedBass.WaDsp.BassWaDsp.Stop(System.Int32)" /> before starting it again).</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other plugin problem (the plugin could not be initialized).</exception>
        </member>
        <member name="M:ManagedBass.WaDsp.BassWaDsp.Stop(System.Int32)">
            <summary>
            Stops a Winamp DSP.
            </summary>
            <param name="Plugin">The plugin handle (returned by <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).</param>
            <returns><see langword="true" /> on success, else <see langword="false" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>If the Winamp DSP was already assigned to a channel using <see cref="M:ManagedBass.WaDsp.BassWaDsp.ChannelSetDSP(System.Int32,System.Int32,System.Int32)" /> the DSP will be removed automatically from the channel when it is stopped.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Plugin" /> is not a valid plugin handle.</exception>
            <exception cref="F:ManagedBass.Errors.Start"><see cref="M:ManagedBass.WaDsp.BassWaDsp.Start(System.Int32,System.Int32,System.Int32)" /> has not been called before.</exception>
        </member>
        <member name="T:ManagedBass.WaDsp.BassWaDspIpc">
            <summary>
            Communication to Winamp is done via the classic Win32 Message API.
            Most DSP plugins use this to ask for certain values.
            These definitions are the most commonly used messages, which might be handled by the fake winamp window which we create.
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetVersion">
            <summary>
            Version will be 0x20yx for winamp 2.yx. 
            Versions previous to Winamp 2.0 typically use 0x1zyx for 1.zx versions.
            <para>int version = SendMessage(hwnd_winamp,WM_WA_IPC,0,BassWaDspIpc.GetVersion);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.StartPlay">
            <summary>
            Using IPC_STARTPLAY is like hitting 'Play' in Winamp, mostly.
            <para>SendMessage(hwnd_winamp,WM_WA_IPC,0,BassWaDspIpc.StartPlay);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.IsPlaying">
            <summary>
            Returns the status of playback.
            If it returns 1, it is playing.
            if it returns 3, it is paused.
            if it returns 0, it is not playing.
            <para>int res = SendMessage(hwnd_winamp,WM_WA_IPC,0,BassWaDspIpc.IsPlaying);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetOutputTime">
            <summary>
            Returns the position in milliseconds of the current song (mode = 0), 
            or the song length, in seconds (mode = 1).
            Returns -1 if not playing or error.
            <para>int res = SendMessage(hwnd_winamp,WM_WA_IPC,mode,BassWaDspIpc.GetOutputTime);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetListLength">
            <summary>
            Returns the length of the current playlist, in tracks.
            <para>int length = SendMessage(hwnd_winamp,WM_WA_IPC,0,BassWaDspIpc.GetListLength);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetListPosition">
            <summary>
            Returns the playlist position [index].
            <para>int pos=SendMessage(hwnd_winamp,WM_WA_IPC,0,BassWaDspIpc.GetListPosition);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetInfo">
            <summary>
            Returns info about the current playing song.
            The value it returns depends on the value of 'mode' (wParam):
            0 - SampleRate (i.e. 44100), 1 - Bitrate  (i.e. 128), 2 - Channels (i.e. 2)
            <para>int inf=SendMessage(hwnd_winamp,WM_WA_IPC,mode,BassWaDspIpc.GetInfo);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetPlaylistFile">
            <summary>
            Gets the filename of the playlist entry [index].
            Returns a pointer to it.
            Returns <see langword="null" /> on error.
            <para>char *name=SendMessage(hwnd_winamp,WM_WA_IPC,index,BassWaDspIpc.GetPlaylistFile);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.GetPlaylistTitle">
            <summary>
            Gets the title of the playlist entry [index].
            Returns a pointer to it.
            Returns <see langword="null" /> on error.
            <para>char *name=SendMessage(hwnd_winamp,WM_WA_IPC,index,BassWaDspIpc.GetPlaylistTitle);</para>
            </summary>
        </member>
        <member name="F:ManagedBass.WaDsp.BassWaDspIpc.Ipc">
            <summary>
            Is defined as Win32's WM_USER an.
            When a message of this value arrives, we know, that we might handle it by ourself.
            </summary>
        </member>
        <member name="T:ManagedBass.WaDsp.WinampWinProcedure">
            <summary>
            User defined Window Message Process Handler (to be used with <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" />).
            <para>
            Normally this is not needed, since BASS_WADSP implements a default handler which emulates most functions needed by Winamp DSPs.
            However, some very special Winamp DSPs might require something special.
            So you might implement your own windows message handler here.
            </para>
            </summary>
            <param name="hwnd">The Window handle we are dealing with - which is the hidden fake window which BASS_WADSP has created during <see cref="M:ManagedBass.WaDsp.BassWaDsp.Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.WaDsp.WinampWinProcedure)" /> and which emulates a Winamp 1.x class.</param>
            <param name="msg">The window message send. You typically might only react on WM_USER messages (also defined as <see cref="T:ManagedBass.WaDsp.BassWaDspIpc" />).</param>
            <param name="wParam">The wParam message parameter see the Winamp SDK for further details.</param>
            <param name="lParam">The lParam message parameter see the Winamp SDK for further details.</param>
            <returns>See the Winamp SDK documentation for information.</returns>
            <remarks>
            <para>The <see cref="T:ManagedBass.WaDsp.BassWaDspIpc" /> enumeration defines all lParam values which you should typically handle. See the Winamp SDK for further details.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Sfx.BassSfx">
            <summary>
            BassSfx is an extention to the BASS audio library, providing a set of functions for rendering Sonique Visualization plugins or Winamp visualization plugins on a provided device context (hDC).
            </summary>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.Sfx.BassSfx.LastError">
            <summary>
            Retrieves the error code for the most recent BASS_SFX function call.
            </summary>
            <returns>
            If no error occured during the last BASS_SFX function call then BASS_SFX_OK is returned, else one of the <see cref="T:ManagedBass.Sfx.BassSfxError" /> values is returned. 
            See the function description for an explanation of what the error code means.
            </returns>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.Free">
            <summary>
            Frees all resources used by SFX.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>This function should be called before your program exits.</remarks>
        </member>
        <member name="P:ManagedBass.Sfx.BassSfx.Version">
            <summary>
            Gets the version number of the bass_sfx.dll that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)">
            <summary>
            Initialize the SFX library. This will initialize the library for use.
            </summary>
            <param name="hInstance">Your application instance handle.</param>
            <param name="hWnd">Your main windows form handle.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned.</returns>
            <remarks>
            Call this method prior to any other BASS_SFX methods.
            <para>Call <see cref="M:ManagedBass.Sfx.BassSfx.Free" /> to free all resources and before your program exits.</para>
            </remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Already">Already initialized.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginClicked(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calls the 'clicked' function of a Sonique visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="X">The x coordinate of the click relative to the top left of your visual window.</param>
            <param name="Y">The y coordinate of the click relative to the top left of your visual window.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>
            This function is only valid for Sonique Visualization plugins.
            You must have created a plugin object using <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" /> before you can use this function.
            </remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginConfig(System.Int32)">
            <summary>
            Shows the configuration dialog window for the SFX plugin (Winamp only).
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)">
            <summary>
            Creates a plugin object for use in the SFX.
            </summary>
            <param name="File">The filename and path of the plugin to load.</param>
            <param name="hWnd">The handle of the window where the plugin is to be rendered.</param>
            <param name="Width">The initial width for the plugins rendering window.</param>
            <param name="Height">The initial height for the plugins rendering window.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.Sfx.BassSfxFlags"/>.</param>
            <returns>If successful, the new SFX plugin handle is returned, else 0 is returned.</returns>
            <remarks>
            Once you create a plugin using this function you can perform a number of different function calls on it.
            The <paramref name="Width" /> and <paramref name="Height" /> parameters are only useful for BassBox, WMP, and Sonique plugins.
            Winamp ignores these parameters so you can just pass in 0 for winamp plugins.
            Windows Media Player plugins can be created using the full path to a dll file or by using the CLSID GUID from the registry.
            <para>Mainly you might use the <see cref="M:ManagedBass.Sfx.BassSfx.PluginStart(System.Int32)" />, <see cref="M:ManagedBass.Sfx.BassSfx.PluginSetStream(System.Int32,System.Int32)" /> or <see cref="M:ManagedBass.Sfx.BassSfx.PluginRender(System.Int32,System.Int32,System.IntPtr)" /> methods.</para>
            </remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.FileOpen">Can't open the plugin file.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Format">Unsupported plugin format.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.GUID">Can't open WMP plugin using specified GUID.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginFlags(System.Int32,ManagedBass.Sfx.BassSfxFlags,ManagedBass.Sfx.BassSfxFlags)">
            <summary>
            Modifies and/or retrieves a plugin's flags.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.Sfx.BassSfxFlags"/>.</param>
            <param name="Mask">The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 (<see cref="F:ManagedBass.Sfx.BassSfxFlags.Default" />) in order to just retrieve the current flags.</param>
            <returns>If successful, the plugin's updated flags are returned, else -1 is returned. Use <see cref="P:ManagedBass.Sfx.BassSfx.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginFree(System.Int32)">
            <summary>
            Free a sonique visual plugin and resources from memory.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>It is very important to call this function after you are done using a plugin to avoid memory leaks.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginGetName(System.Int32)">
            <summary>
            Gets the name of a loaded SFX plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, the name of the plugin is returned, else <see langword="null" /> is returned.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginGetType(System.Int32)">
            <summary>
            Get the type of visual plugin loaded.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, the type of plugin is returned.</returns>
            <remarks>You must have created a plugin object using <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" /> before you can use this function.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginModuleGetActive(System.Int32)">
            <summary>
            Gets the active module for a visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, the active module (zero based index) is returned, else -1 is returned.</returns>
            <remarks>
            Visual plugins might provide multiple independent modules.
            You might get the number of available modules with <see cref="M:ManagedBass.Sfx.BassSfx.PluginModuleGetCount(System.Int32)" />.
            However, you can only start/activate one module at a time for a certain visual plugin.
            <para>Note: Sonique plugins only ever have 1 module. Winamp plugins can have multiple modules. So this call is really only useful for Winamp.</para>
            </remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginModuleGetCount(System.Int32)">
            <summary>
            Gets the number of modules available in the visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, the number of modules is returned, else -1 is returned.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginModuleGetName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a certain module of a loaded visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Module">The module number to get the name from (the first module is 0).</param>
            <returns>The name of the module on success or <see langword="null" /> on error (or if no module with that number exists).</returns>
            <remarks>
            Visual plugins might provide multiple independent modules.
            You might get the number of available modules with <see cref="M:ManagedBass.Sfx.BassSfx.PluginModuleGetCount(System.Int32)" />.
            However, you can only start/activate one module at a time for a certain visual plugin.
            <para>Note: Sonique plugins only ever have 1 module. Winamp plugins can have multiple modules. So this call is really only useful for Winamp.</para>
            <para>You can use this method in a setup dialog to list all the available modules of a visual plugin.</para>
            </remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginModuleSetActive(System.Int32,System.Int32)">
            <summary>
            Sets the active module for a visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Module">The module number to set active (the first module is 0).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>
            Visual plugins might provide multiple independent modules.
            You might get the number of available modules with <see cref="M:ManagedBass.Sfx.BassSfx.PluginModuleGetCount(System.Int32)" />.
            However, you can only start/activate one module at a time for a certain visual plugin.
            <para>Note: Sonique plugins only ever have 1 module. Winamp plugins can have multiple modules. So this call is really only useful for Winamp.</para>
            </remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginRender(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Renders a Sonique, BassBox or Windows Media Player visual plugin to a device context.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Channel">The BASS channel to render, can be a HSTREAM or HMUSIC handle.</param>
            <param name="hDC">The device context handle of the control to which you want to render the plugin.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>Only for use with Sonique, BassBox or Windows Media Player plugins.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginResize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes a visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Width">The new width of your visual window.</param>
            <param name="Height">The new height of your visual window.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>You must have created a plugin object using <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" /> before you can use this function.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginResizeMove(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes and moves a visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Left">The new left location of your visual window.</param>
            <param name="Top">The new top location of your visual window.</param>
            <param name="Width">The new width of your visual window.</param>
            <param name="Height">The new height of your visual window.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>You must have created a plugin object using <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" /> before you can use this function.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginSetStream(System.Int32,System.Int32)">
            <summary>
            Sets a BASS channel on a SFX plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <param name="Channel">The BASS channel to render, can be a HSTREAM or HMUSIC handle.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginStart(System.Int32)">
            <summary>
            Starts a visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>Use <see cref="M:ManagedBass.Sfx.BassSfx.PluginStop(System.Int32)" /> to stop a SFX plugin.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.PluginStop(System.Int32)">
            <summary>
            Stops a visual plugin.
            </summary>
            <param name="Handle">The SFX plugin handle (as obtained by <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" />).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <remarks>Use <see cref="M:ManagedBass.Sfx.BassSfx.PluginStart(System.Int32)" /> to start a SFX plugin.</remarks>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Handle">Invalid SFX handle.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.WMPGetPlugin(System.Int32,ManagedBass.Sfx.BassSfxPluginInfo@)">
            <summary>
            Retrieves information on a registered windows media player plugin.
            </summary>
            <param name="Index">The plugin to get the information of... 0 = first.</param>
            <param name="Info"><see cref="T:ManagedBass.Sfx.BassSfxPluginInfo" /> instance where to store the plugin information at.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.WMPGetPlugin(System.Int32)">
            <summary>
            Retrieves information on a registered windows media player plugin.
            </summary>
            <param name="Index">The plugin to get the information of... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.Sfx.BassSfxPluginInfo" /> on success, else <see langword="null" />.</returns>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfx.WMPGetPluginCount">
            <summary>
            Returns the total number of WMP plugins currently available for use.
            </summary>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Init"><see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Memory">Memory error.</exception>
            <exception cref="F:ManagedBass.Sfx.BassSfxError.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="T:ManagedBass.Sfx.BassSfxError">
            <summary>
            BASS_SFX error codes as returned by <see cref="P:ManagedBass.Sfx.BassSfx.LastError" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.Unknown">
            <summary>
            Some other mystery problem.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.OK">
            <summary>
            All is OK.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.Memory">
            <summary>
            Memory error.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.FileOpen">
            <summary>
            Can't open the file.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.Handle">
            <summary>
            Invalid handle.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.Already">
            <summary>
            Already initialized.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.Format">
            <summary>
            Unsupported plugin format.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.Init">
            <summary>
            <see cref="M:ManagedBass.Sfx.BassSfx.Init(System.IntPtr,System.IntPtr)" /> has not been successfully called.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxError.GUID">
            <summary>
            Can't open WMP plugin using specified GUID.
            </summary>
        </member>
        <member name="T:ManagedBass.Sfx.BassSfxFlags">
            <summary>
            Visual plugin's flags, to be used with <see cref="M:ManagedBass.Sfx.BassSfx.PluginFlags(System.Int32,ManagedBass.Sfx.BassSfxFlags,ManagedBass.Sfx.BassSfxFlags)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxFlags.Default">
            <summary>
            Default flags (use GDI rendering).
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxFlags.SoniqueOpenGL">
            <summary>
            Render sonique plugins using OpenGL.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxFlags.SoniqueOpenGLDoubleBuffer">
            <summary>
            Use OpenGL double buffering.
            </summary>
        </member>
        <member name="T:ManagedBass.Sfx.BassSfxPlugin">
            <summary>
            Flag which identifies the type/kind of the visual plugin.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxPlugin.Unknown">
            <summary>
            An unknown plugin type (not supported).
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxPlugin.Sonique">
            <summary>
            Sonique visual plugin.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxPlugin.Winamp">
            <summary>
            Winamp visual plugin.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxPlugin.WMP">
            <summary>
            Windows Media Player visual plugin.
            </summary>
        </member>
        <member name="F:ManagedBass.Sfx.BassSfxPlugin.BBP">
            <summary>
            BassBox visual plugin.
            </summary>
        </member>
        <member name="T:ManagedBass.Sfx.BassSfxPluginInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Sfx.BassSfx.WMPGetPlugin(System.Int32,ManagedBass.Sfx.BassSfxPluginInfo@)" /> to retrieve information on a registered Windows Media Player plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.Sfx.BassSfxPluginInfo.Name">
            <summary>
            The description of the plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.Sfx.BassSfxPluginInfo.ClsId">
            <summary>
            The classid of the windows media player plugin that can be used with <see cref="M:ManagedBass.Sfx.BassSfx.PluginCreate(System.String,System.IntPtr,System.Int32,System.Int32,ManagedBass.Sfx.BassSfxFlags)" /> to create the plugin for use in BASS_SFX.
            </summary>
        </member>
        <member name="M:ManagedBass.Sfx.BassSfxPluginInfo.ToString">
            <summary>
            The description of the plugin.
            </summary>
            <returns>The description of the plugin.</returns>
        </member>
        <member name="T:ManagedBass.Vst.BassVst">
            <summary>
            BassVst allows the usage of VST effect plugins as well as VST instruments (VSTi plugins) with BASS.
            </summary>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ChannelCreate(System.Int32,System.Int32,System.String,ManagedBass.BassFlags)">
            <summary>
            Creates a new BASS stream based on any VST instrument plugin (VSTi).
            </summary>
            <param name="Frequency">The sample rate of the VSTi output (e.g. 44100).</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1.</param>
            <param name="DllFile">The fully qualified path and file name to the VSTi plugin (a DLL file name).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new vst handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            On success, the function returns the new vstHandle that must be given to the other functions.
            The returned VST handle can also be given to the typical Bass.Channel* functions.
            Use <see cref="M:ManagedBass.Vst.BassVst.ChannelFree(System.Int32)" /> to delete and free a VST instrument channel.
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ChannelFree(System.Int32)">
            <summary>
            Deletes and frees a VST instrument channel.
            </summary>
            <param name="VstHandle">The VSTi channel to delete (as created by <see cref="M:ManagedBass.Vst.BassVst.ChannelCreate(System.Int32,System.Int32,System.String,ManagedBass.BassFlags)" />).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Note, that you cannot delete VST effects assigned to this channels this way; for this purpose, please call <see cref="M:ManagedBass.Vst.BassVst.ChannelRemoveDSP(System.Int32,System.Int32)" />.
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ChannelRemoveDSP(System.Int32,System.Int32)">
            <summary>
            Removes a VST effect from a channel and destroys the VST instance.
            </summary>
            <param name="Channels">The channel handle from which to remove the VST effect... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If you do not call <see cref="M:ManagedBass.Vst.BassVst.ChannelRemoveDSP(System.Int32,System.Int32)" /> explicitly and you have assigned a channel to the effect, the effect is removed automatically when the channel handle is deleted by BASS (like for any other DSP as well).</para>
            <para>For various reasons, the underlying DLL is unloaded from memory with a little delay, however, this has also the advantage that subsequent adding/removing of DLLs to channels has no bad performance impact.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)">
            <summary>
            Assigns a VST effects (defined by a DLL file name) to any BASS channels.
            <para>This overload implements the Unicode overload for the dllFile name, so the BASS_UNICODE flag will automatically be added if not already set.</para>
            </summary>
            <param name="Channels">The channel handle... a HSTREAM, HMUSIC, or HRECORD. Or 0, if you want to test, if the dll is a valid VST plugin.</param>
            <param name="DllFile">The fully qualified path and file name to the VST effect plugin (a DLL file name).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.Vst.BassVstDsp"/></param>
            <param name="Priority">Same meaning as for <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" /> - DSPs with higher priority are called before those with lower.</param>
            <returns>On success, the method returns the new vstHandle that must be given to all the other functions, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The VST plugin is implemented via a DSP callback on the channel.
            That means when you play the channel (or call <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> if it's a decoding channel), the sample data will be sent to the VST effect at the same time.
            If the channel is freed all DSPs are removed automatically, also all VST DSPs are removed as well.
            If you want or need to free the VST DSP manually you can call <see cref="M:ManagedBass.Vst.BassVst.ChannelRemoveDSP(System.Int32,System.Int32)" />.
            <para>For testing if a DLL is a valid VST effect, you can set Channels to 0 - however, do not forget to call <see cref="M:ManagedBass.Vst.BassVst.ChannelRemoveDSP(System.Int32,System.Int32)" /> even in this case.</para>
            <para>
            You may safely assign the same DLL to different channels at the same time - the library makes sure, every channel is processed indepeningly.
            But take care to use the correct vstHandles in this case.
            </para>
            <para>
            Finally, you can use any number of VST effects on a channel.
            They are processed alongside with all other BASS DSPs in the order of it's priority.
            </para>
            <para>
            To set or get the parameters of a VST effect you might use <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" /> alongside with <see cref="M:ManagedBass.Vst.BassVst.GetParam(System.Int32,System.Int32)" /> and <see cref="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)" /> to enumerate over the total number of effect parameters.
            To retrieve details about an individual parameter you might use <see cref="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32,ManagedBass.Vst.BassVstParamInfo@)" />.
            If the VST effect supports an embedded editor you might also invoke this one with <see cref="M:ManagedBass.Vst.BassVst.EmbedEditor(System.Int32,System.IntPtr)" />.
            If the embedded editor also supports localization you might set the language in advance with <see cref="M:ManagedBass.Vst.BassVst.SetLanguage(System.String)" />.
            </para>
            <para>If you need to temporarily bypass the VST effect you might call <see cref="M:ManagedBass.Vst.BassVst.SetBypass(System.Int32,System.Boolean)" /> - <see cref="M:ManagedBass.Vst.BassVst.GetBypass(System.Int32)" /> will tell you the current bypass status though.</para>
            <para>Use <see cref="M:ManagedBass.Vst.BassVst.GetInfo(System.Int32,ManagedBass.Vst.BassVstInfo@)" /> to get even more details about a loaded VST plugin.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.EmbedEditor(System.Int32,System.IntPtr)">
            <summary>
            Many VST effects come along with an graphical parameters editor; with the following function, you can embed these editors to your user interface.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ParentWindow">The IntPtr to the window handle (HWND) of the parents window in which the editor should be embedded (e.g. use a new modeless dialog or user control).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            To embed the editor to another window, call this function with parentWindow set to the HWND of the parent window.
            To check, if an effect has an editor, see the hasEditor flag set by <see cref="M:ManagedBass.Vst.BassVst.GetInfo(System.Int32,ManagedBass.Vst.BassVstInfo@)" />.
            </para>
            <para>To "unembed" the editor, call this function with <paramref name="ParentWindow"/> set to <see langword="null" />.</para>
            <para>
            If you create the editor window independently of a real channel (by skipping the channel parameter when calling <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />) and the editor displays any spectrums, VU-meters or such, 
            the data for this come from the most recent channel using the same effect and the same scope.
            The scope can be set by <see cref="M:ManagedBass.Vst.BassVst.SetScope(System.Int32,System.Int32)" /> to any ID, the default is 0.
            </para>
            <para>In order to create a new window in which the editor should be embedded, it is a good idea to call <see cref="M:ManagedBass.Vst.BassVst.GetInfo(System.Int32,ManagedBass.Vst.BassVstInfo@)" /> in order to retrieve the editors height and width.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetBypass(System.Int32)">
            <summary>
            Gets the current bypasses state of the the effect processing.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetChunk(System.Int32,System.Boolean)">
            <summary>
            Gets the VST plug-in state as a plain byte array (memory chunk storage).
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="IsPreset"><see langword="true" /> when saving a single program; <see langword="false" /> for all programs.</param>
            <returns>The array of bytes representing the VST plug-in state - or <see langword="null" /> if the VST doesn't support the chunk data mode.</returns>
            <remarks>
            There are two ways to store the current state of a VST plug-In:
            Either trough the parameter interfaces (<see cref="M:ManagedBass.Vst.BassVst.GetParam(System.Int32,System.Int32)" /> and <see cref="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)" />) or as an opaque memory block (chunk mode).
            <para>
            You might first queries this method to see, if the VST supports the chunk mode.
            If it is not implemented (<see langword="null" /> is returned), the values of all parameters might be used to save the plug-in state.
            </para>
            <para>
            Chunk storage allows to save additional data (besides the parameter state) which is specific to the VST plug-in.
            Please note, that if you decide to use the chunk storage, you have to take care of saving and loading parameter states on your own (see <see cref="M:ManagedBass.Vst.BassVst.SetChunk(System.Int32,System.Boolean,System.Byte[],System.Int32)" /> for details)!
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetInfo(System.Int32,ManagedBass.Vst.BassVstInfo@)">
            <summary>
            Gets general information about a VST effect plugin.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Vst.BassVstInfo" /> where to store the parameter information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            VST effects that have no input channels (so called "Instruments") are not loaded by BASS_VST.
            So you can assume chansIn and chansOut to be at least 1.
            </para>
            <para>
            Multi-channel streams should work correctly, if supported by a effect.
            If not, only the first chansIn channels are processed by the effect, the other ones stay unaffected.  
            The opposite, eg. assigning multi-channel effects to stereo channels, should be no problem at all.
            </para>
            <para>
            If mono effects are assigned to stereo channels, the result will be mono, expanded to both channels.
            This behaviour can be switched of using the <see cref="F:ManagedBass.Vst.BassVstDsp.KeepChannels"/> in <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.BASS_VST_GetInfo(System.Int32)">
            <summary>
            Gets general information about a VST effect plugin.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>If successful, an instance of <see cref="T:ManagedBass.Vst.BassVstInfo" /> is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            VST effects that have no input channels (so called "Instruments") are not loaded by BASS_VST.
            So you can assume chansIn and chansOut to be at least 1.
            </para>
            <para>
            Multi-channel streams should work correctly, if supported by a effect.
            If not, only the first chansIn channels are processed by the effect, the other ones stay unaffected.  
            The opposite, eg. assigning multi-channel effects to stereo channels, should be no problem at all.
            </para>
            <para>
            If mono effects are assigned to stereo channels, the result will be mono, expanded to both channels.
            This behaviour can be switched of using the <see cref="F:ManagedBass.Vst.BassVstDsp.KeepChannels"/> in <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetParam(System.Int32,System.Int32)">
            <summary>
            Get the value of a single VST effect parameter.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ParamIndex">The index of the parameter (must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" />).</param>
            <returns><see langword="true" /> on success.</returns>
            <remarks>
            <para>
            All VST effect parameters are in the range from 0.0 to 1.0 (float), however, from the view of a VST effect, they may represent completely different values.
            E.g. some might represent a multiplier to some internal constants and will result in number of samples or some might represent a value in dB etc.
            </para>
            <para>You can use <see cref="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32,ManagedBass.Vst.BassVstParamInfo@)" /> to get further information about a single parameter, which will also present you with the current value in a readable format.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)">
            <summary>
            Returns the number of editable parameters for the VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>The number of editable parameters or if the effect has no editable parameters, 0 is returned.</returns>
            <remarks>
            To set or get the individual parameters of a VST effect you might use <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" /> alongside with <see cref="M:ManagedBass.Vst.BassVst.GetParam(System.Int32,System.Int32)" /> and <see cref="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)" /> to enumerate over the total number of effect parameters.
            To retrieve details about an individual parameter you might use <see cref="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32,ManagedBass.Vst.BassVstParamInfo@)" />.
            If the VST effect supports an embedded editor you might also invoke this one with <see cref="M:ManagedBass.Vst.BassVst.EmbedEditor(System.Int32,System.IntPtr)" />.
            If the embedded editor also supports localization you might set the language in advance with <see cref="M:ManagedBass.Vst.BassVst.SetLanguage(System.String)" />.
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32,ManagedBass.Vst.BassVstParamInfo@)">
            <summary>
            Get some common information about an editable parameter to a <see cref="T:ManagedBass.Vst.BassVstParamInfo" /> object.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ParamIndex">The index of the parameter (must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" />).</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.Vst.BassVstParamInfo" /> where to store the parameter information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32)">
            <summary>
            Get some common information about an editable parameter to a <see cref="T:ManagedBass.Vst.BassVstParamInfo" /> class.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ParamIndex">The index of the parameter (must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" />).</param>
            <returns>If successful, an instance of the <see cref="T:ManagedBass.Vst.BassVstParamInfo" /> is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetProgram(System.Int32)">
            <summary>
            Returns the currently selected program for the VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>The currect selected program number. Valid program numbers are between 0 and <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" /> minus 1.</returns>
            <remarks>
            After construction (using <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />), always the first program (0) is selected.
            <para>
            With <see cref="M:ManagedBass.Vst.BassVst.SetProgram(System.Int32,System.Int32)" /> you can change the selected program.
            Functions as <see cref="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)" /> will always change the selected program's settings.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)">
            <summary>
            Returns the number of editable programs for the VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>The number of available programs or 0 if no program is available.</returns>
            <remarks>
            Many (not all!) effects have more than one "program" that can hold a complete set of parameters each.
            Moreover, some of these programs may be initialized to some useful "factory defaults".
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetProgramName(System.Int32,System.Int32)">
            <summary>
            Gets the name of any program of a VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ProgramIndex">The program number for which to get the name, must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" />.</param>
            <returns>The name of the program given or <see langword="null" /> if not valid.</returns>
            <remarks>The names are limited to 24 characters. This function does not change the selected program!</remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetProgramNames(System.Int32)">
            <summary>
            Returns a list of all available program names.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>An array of strings representing the list of available program names. The index corresponds to the program numbers.</returns>
            <remarks>This function does not change the selected program!</remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.GetProgramParam(System.Int32,System.Int32)">
            <summary>
            Returns the parameters of a given program.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ProgramIndex">The program number for which to query the parameter values, must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" />.</param>
            <returns>An array of float values representing the parameter values of the given program or <see langword="null" /> if the program (VST effect) has no parameters or an error occurred.</returns>
            <remarks>
            <para>The parameters of the currently selected program can also be queried by <see cref="M:ManagedBass.Vst.BassVst.GetParam(System.Int32,System.Int32)" />.</para>
            <para>
            The function returns the parameters as an array of floats.
            The number of elements in the returned array is equal to <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" />.
            </para>
            <para>This function does not change the selected program!</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ProcessEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)">
            <summary>
            Sends a MIDI message/event to the VSTi plugin.
            </summary>
            <param name="VstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:ManagedBass.Vst.BassVst.ChannelCreate(System.Int32,System.Int32,System.String,ManagedBass.BassFlags)" />).</param>
            <param name="MidiChannel">The Midi channel number to use (0 to 15).</param>
            <param name="EventType">The Midi event/status value to use (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="Param">The data bytes to send with the message to compose a data byte 1 and 2.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Use one of the <see cref="T:ManagedBass.Midi.MidiEventType" /> commands similar to <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" />.
            <para>
            Set <paramref name="MidiChannel" /> to 0xFFFF and <paramref name="EventType" /> to the raw command to send. 
            The raw command must be encoded as 0x00xxyyzz with xx=MIDI command, yy=MIDI databyte #1, zz=MIDI databyte #2.
            <paramref name="Param" /> should be set to 0 in this case.
            </para>
            <para>
            Send SysEx commands by setting <paramref name="MidiChannel" /> to 0xEEEE. 
            <paramref name="EventType" /> will denote the type of event to send (see <see cref="T:ManagedBass.Midi.MidiEventType" /> about possible values for <paramref name="Param" /> in such case).
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ProcessEventRaw(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sends a SysEx or MIDI (short)message/event to the VSTi plugin.
            </summary>
            <param name="VstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:ManagedBass.Vst.BassVst.ChannelCreate(System.Int32,System.Int32,System.String,ManagedBass.BassFlags)" />).</param>
            <param name="Message">The pointer to your Midi message data to send (byte[]).</param>
            <param name="Length">The length of a SysEx message or 0 in case of a normal Midi (short)message.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            To send a Midi (short)message : 
            The raw message must be encoded as 0x00xxyyzz with xx=MIDI command, yy=MIDI databyte #1, zz=MIDI databyte #2.
            <paramref name="Length" /> should be set to 0 in this case.
            </para>
            <para>
            To send a SysEx message:
            <paramref name="Message" /> must be set to a pointer to the bytes to send and <paramref name="Length" /> must be set to the number of bytes to send.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.ProcessEventRaw(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sends a SysEx or MIDI (short)message/event to the VSTi plugin.
            </summary>
            <param name="VstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:ManagedBass.Vst.BassVst.ChannelCreate(System.Int32,System.Int32,System.String,ManagedBass.BassFlags)" />).</param>
            <param name="Message">The byte array containing your Midi message data to send.</param>
            <param name="Length">The length of a SysEx message or 0 in case of a normal Midi (short)message.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            To send a Midi (short)message : 
            The raw message must be encoded as 0x00xxyyzz with xx=MIDI command, yy=MIDI databyte #1, zz=MIDI databyte #2.
            <paramref name="Length" /> should be set to 0 in this case.
            </para>
            <para>
            To send a SysEx message:
            <paramref name="Message" /> must be set to a pointer to the bytes to send and <paramref name="Length" /> must be set to the number of bytes to send.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.Resume(System.Int32)">
            <summary>
            Call this function after position changes or sth. like that.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Some VST effects will use an internal buffer for effect calculation and handling.
            This will reset the internal VST buffers which may remember some "old" data.
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetBypass(System.Int32,System.Boolean)">
            <summary>
            Bypasses the effect processing (state=<see langword="true" />) or switch back to normal processing (state=<see langword="false" />).
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="State"><see langword="true" /> to bypasses the effect processing; <see langword="false" /> to switch back to normal processing.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            By default bypassing is OFF and the effect will be processed normally.
            Use <see cref="M:ManagedBass.Vst.BassVst.GetBypass(System.Int32)" /> returns the current state.
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetCallback(System.Int32,ManagedBass.Vst.VstProcedure,System.IntPtr)">
            <summary>
            Assign a callback function to a vstHandle.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="Procedure">The user defined callback delegate (see <see cref="T:ManagedBass.Vst.VstProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>Unless defined otherwise, the callback function should always return 0.</remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetChunk(System.Int32,System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Sets the VST plug-in state with a plain byte array (memory chunk storage).
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="IsPreset"><see langword="true" /> when restoring a single program; <see langword="false" /> for all programs.</param>
            <param name="Chunk">The byte array containing the memory chunk storage to set.</param>
            <param name="Length">The number of bytes to write.</param>
            <returns>The number of bytes written.</returns>
            <remarks>
            Might be used to restore a VST plug-in state which was previously saved via <see cref="M:ManagedBass.Vst.BassVst.GetChunk(System.Int32,System.Boolean)" />.
            <para>After restoring a plug-in state you might need to retrieve the program names again (see <see cref="M:ManagedBass.Vst.BassVst.GetProgramName(System.Int32,System.Int32)" /> and <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" />) as they might have changed.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetChunk(System.Int32,System.Boolean,System.Byte[])">
            <summary>
            Sets the VST plug-in state with a plain byte array (memory chunk storage).
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="IsPreset"><see langword="true" /> when restoring a single program; <see langword="false" /> for all programs.</param>
            <param name="Chunk">The byte array containing the memory chunk storage to set.</param>
            <returns>The number of bytes written.</returns>
            <remarks>
            Might be used to restore a VST plug-in state which was previously saved via <see cref="M:ManagedBass.Vst.BassVst.GetChunk(System.Int32,System.Boolean)" />.
            <para>After restoring a plug-in state you might need to retrieve the program names again (see <see cref="M:ManagedBass.Vst.BassVst.GetProgramName(System.Int32,System.Int32)" /> and <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" />) as they might have changed.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetLanguage(System.String)">
            <summary>
            Set the VST language to be used by any plugins.
            </summary>
            <param name="Language">The desired language as ISO 639.1, e.g. "en", "de", "es"...</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Some VST effects come along localized.
            With this function you can set the desired language as ISO 639.1 -- eg. "en" for english, "de" for german, "es" for spanish and so on.
            The default language is english.
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)">
            <summary>
            Set a value of a single VST effect parameter.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ParamIndex">The index of the parameter (must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" />).</param>
            <param name="NewValue">The new value to set in the range from 0.0 to 1.0 (float). See the documentation of the actual VST implementation for details of the effective value representation.</param>
            <returns><see langword="true" /> on success.</returns>
            <remarks>
            <para>
            All VST effect parameters are in the range from 0.0 to 1.0 (float), however, from the view of a VST effect, they may represent completely different values.
            E.g. some might represent a multiplier to some internal constants and will result in number of samples or some might represent a value in dB etc.
            </para>
            <para>So it is a good idea to call <see cref="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32,ManagedBass.Vst.BassVstParamInfo@)" /> after you modified a parameter, in order to to get further information about the parameter in question, which will also present you with the current value in a readable format.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetProgram(System.Int32,System.Int32)">
            <summary>
            Sets (changes) the selected program for the VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ProgramIndex">The program number to set (between 0 and <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" /> minus 1.).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>You might call <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" /> to check, if the VST effect has any editable programs available.
            <para>
            With <see cref="M:ManagedBass.Vst.BassVst.GetProgram(System.Int32)" /> you can check, which is the current selected program.
            Functions as as <see cref="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)" /> will always change the selected program's settings.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetProgramName(System.Int32,System.Int32,System.String)">
            <summary>
            Sets the name of any program of a VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ProgramIndex">The program number for which to set the name, must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" />.</param>
            <param name="Name">The new name to use. Names are limited to 24 characters, BASS_VST truncates the names, if needed.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This function does not change the selected program!</remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetProgramParam(System.Int32,System.Int32,System.Single[])">
            <summary>
            Set all parameters of any program in a VST effect.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="ProgramIndex">The program number for which to set the parameter values, must be smaller than <see cref="M:ManagedBass.Vst.BassVst.GetProgramCount(System.Int32)" />.</param>
            <param name="Param">An array with the parameter values to set. The array needs to have as many elements as defined by <see cref="M:ManagedBass.Vst.BassVst.GetParamCount(System.Int32)" /> or as returned be <see cref="M:ManagedBass.Vst.BassVst.GetProgramParam(System.Int32,System.Int32)" />.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function does not change the selected program!
            <para>If you use <see cref="M:ManagedBass.Vst.BassVst.SetCallback(System.Int32,ManagedBass.Vst.VstProcedure,System.IntPtr)" />, the <see cref="F:ManagedBass.Vst.BassVstAction.ParametersChanged"/> event is only posted if you select a program with parameters different from the prior.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Vst.BassVst.SetScope(System.Int32,System.Int32)">
            <summary>
            Sets the scope of an Editor to a given ID.
            </summary>
            <param name="VstHandle">The VST effect handle as returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="Scope">The ID to set the scope to.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
        </member>
        <member name="T:ManagedBass.Vst.BassVstAction">
            <summary>
            VST action parameters as used within the <see cref="T:ManagedBass.Vst.VstProcedure" /> callback.
            <para>See also <see cref="M:ManagedBass.Vst.BassVst.SetCallback(System.Int32,ManagedBass.Vst.VstProcedure,System.IntPtr)" />.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAction.ParametersChanged">
            <summary>
            Some parameters are changed by the editor opened by <see cref="M:ManagedBass.Vst.BassVst.EmbedEditor(System.Int32,System.IntPtr)" />, NOT called if you call <see cref="M:ManagedBass.Vst.BassVst.SetParam(System.Int32,System.Int32,System.Single)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAction.EditorResized">
            <summary>
            The embedded editor window should be resized, the new width/height can be found in param1/param2 and in <see cref="M:ManagedBass.Vst.BassVst.GetInfo(System.Int32,ManagedBass.Vst.BassVstInfo@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAction.AudioMaster">
            <summary>
            Can be used to subclass the audioMaster callback (see the VST SDK), param1 is a pointer to a instance of the <see cref="T:ManagedBass.Vst.BassVstAudioMasterParam" /> class.
            </summary>
        </member>
        <member name="T:ManagedBass.Vst.BassVstDispatcherOpCodes">
            <summary>
            VST Dispatcher OpCodes.
            <para>For more info see the Steinberg VST SDK documentation.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.Open">
            <summary>
            Initialise.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.Close">
            <summary>
            Exit, release all memory and other resources!
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetProgram">
            <summary>
            Program number in "value".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetProgram">
            <summary>
            Returns the current program number.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetProgramName">
            <summary>
            User changed program name (max 24 char + 0) to as passed in string.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetProgramName">
            <summary>
            Stuff program name (max 24 char + 0) into string.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetParamLabel">
            <summary>
            Stuff parameter "index" label (max 8 char + 0) into string.
            <para>Examples: 'sec', 'dB', 'type'</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetParamDisplay">
            <summary>
            Stuff parameter "index" textual representation into string.
            <para>Examples: '0.5', '-3', 'PLATE'</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetParamName">
            <summary>
            Stuff parameter "index" label (max 8 char + 0) into string.
            <para>Examples: 'Time', 'Gain', 'RoomType'</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetVu">
            <summary>
            Called if (flags &amp; (effFlagsHasClip | effFlagsHasVu)).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetSampleRate">
            <summary>
            System: In opt (float value in Hz; for example 44100.0Hz).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetBlockSize">
            <summary>
            System: In value (this is the maximun size of an audio block, pls check sampleframes in process call).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.MainsChanged">
            <summary>
            System: The user has switched the 'power on' button to value (0 off, else on). This only switches audio  processing; you should flush delay buffers etc.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditGetRect">
            <summary>
            Editor: Stuff rect (top, left, bottom, right) into ptr.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditOpen">
            <summary>
            Editor: System dependant Window pointer in ptr.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditClose">
            <summary>
            Editor: No arguments.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditDraw">
            <summary>
            Editor: Draw method, ptr points to rect (MAC Only).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditMouse">
            <summary>
            Editor: index: x, value: y (MAC Only).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditKey">
            <summary>
            Editor: System keycode in value.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditIdle">
            <summary>
            Editor: no arguments. Be gentle!
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditTop">
            <summary>
            Editor: Window has topped, no arguments.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditSleep">
            <summary>
            Editor: Window goes to background.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.Identify">
            <summary>
            Returns 'NvEf'.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetChunk">
            <summary>
            Host requests pointer to chunk into (void**)ptr, byteSize returned.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetChunk">
            <summary>
            Plug-in receives saved chunk, byteSize passed.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.ProcessEvents">
            <summary>
            VstEvents* in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.CanBeAutomated">
            <summary>
            Parameter index in "index".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.String2Parameter">
            <summary>
            Parameter index in "index", string in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetNumProgramCategories">
            <summary>
            No arguments. This is for dividing programs into groups (like GM).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetProgramNameIndexed">
            <summary>
            Get program name of category "value", program "index" into "ptr".
            <para>Category (that is, "value") may be -1, in which case program indices are enumerated linearily (as usual); otherwise, each category starts over with index 0.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.CopyProgram">
            <summary>
            Copy current program to destination "index"
            <para>Note: implies setParameter connections, configuration.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.ConnectInput">
            <summary>
            Input at "index" has been (dis-)connected; "value" == 0: disconnected, else connected.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.ConnectOutput">
            <summary>
            Onput at "index" has been (dis-)connected; "value" == 0: disconnected, else connected.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetInputProperties">
            <summary>
            "index", VstPinProperties* in ptr, return != 0 means true.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetOutputProperties">
            <summary>
            "index", VstPinProperties* in ptr, return != 0 means true.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetPlugCategory">
            <summary>
            No parameter, return value is category.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetCurrentPosition">
            <summary>
            Realtime: for external dsp, see flag bits below.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetDestinationBuffer">
            <summary>
            Realtime: for external dsp, see flag bits below. returns float*.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.OfflineNotify">
            <summary>
            Offline: ptr = VstAudioFile array, value = count, index = start flag.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.OfflinePrepare">
            <summary>
            Offline: ptr = VstOfflineTask array, value = count.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.OfflineRun">
            <summary>
            Offline: ptr = VstOfflineTask array, value = count.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.ProcessVarIo">
            <summary>
            VstVariableIo* in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetSpeakerArrangement">
            <summary>
            VstSpeakerArrangement* pluginInput in "value"; VstSpeakerArrangement* pluginOutput in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetBlockSizeAndSampleRate">
            <summary>
            Block size in "value", sampleRate in "opt"
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetBypass">
            <summary>
            On/Off in "value" (0 = off, 1 = on).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetEffectName">
            <summary>
            char* name (max 32 bytes) in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetErrorText">
            <summary>
            char* text (max 256 bytes) in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetVendorString">
            <summary>
            Fills "ptr" with a string identifying the vendor (max 64 char).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetProductString">
            <summary>
            Fills "ptr" with a string with product name (max 64 char).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetVendorVersion">
            <summary>
            Returns vendor-specific version.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.VendorSpecific">
            <summary>
            No definition, vendor specific handling.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.CanDo">
            <summary>
            "ptr" contains one of the 'plugCanDos' strings (e.g. "bypass").
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetTailSize">
            <summary>
            Returns tail size; 0 is default (return 1 for 'no tail').
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.Idle">
            <summary>
            Idle call in response to audioMasterneedIdle. Must return 1 to keep idle calls beeing issued.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetIcon">
            <summary>
            GUI: void* in "ptr", not yet defined.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetViewPosition">
            <summary>
            GUI: set view position (in window) to x "index" y "value"
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetParameterProperties">
            <summary>
            Of param "index", VstParameterProperties* in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.KeysRequired">
            <summary>
            Returns 0: needs keys (default for 1.0 plugs), 1: don't need.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetVstVersion">
            <summary>
            Returns 2 for VST 2; older versions return 0; 2100 for VST 2.1...2400 for VST 2.4.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditKeyDown">
            <summary>
            Character in "index", virtual in "value", modifiers in "opt", return -1 if not used, return 1 if used.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EditKeyUp">
            <summary>
            Character in "index", virtual in "value", modifiers in "opt", return -1 if not used, return 1 if used.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetEditKnobMode">
            <summary>
            Mode in "value": 0: circular, 1:circular relativ, 2:linear.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetMidiProgramName">
            <summary>
            Passed "ptr" points to MidiProgramName struct.
            <para>Struct will be filled with information for 'thisProgramIndex'.
            Returns number of used programIndexes, if 0 is returned, no MidiProgramNames supported.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetCurrentMidiProgram">
            <summary>
            Returns the programIndex of the current program.
            <para>Passed "ptr" points to MidiProgramName struct, struct will be filled with information for the current program.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetMidiProgramCategory">
            <summary>
            Passed "ptr" points to MidiProgramCategory struct.
            <para>Struct will be filled with information for 'thisCategoryIndex'.
            Returns number of used categoryIndexes, if 0 is returned, no MidiProgramCategories supported.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.HasMidiProgramsChanged">
            <summary>
            Returns 1 if the MidiProgramNames or MidiKeyNames had changed on this channel, 0 otherwise. "ptr" ignored.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetMidiKeyName">
            <summary>
            Passed "ptr" points to MidiKeyName struct.
            <para>Struct will be filled with information for 'thisProgramIndex' and 'thisKeyNumber'.
            If keyName is "" the standard name of the key will be displayed. If 0 is returned, no MidiKeyNames are defined for 'thisProgramIndex'.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.BeginSetProgram">
            <summary>
            Called before a new program is loaded.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.EndSetProgram">
            <summary>
            Called when the program is loaded.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetSpeakerArrangement">
            <summary>
            VstSpeakerArrangement** pluginInput in "value". VstSpeakerArrangement** pluginOutput in "ptr".
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.ShellGetNextPlugin">
            <summary>
            This opcode is only called, if plugin is of type kPlugCategShell. Returns the next plugin's uniqueID.
            <para>"ptr" points to a char buffer of size 64, which is to be filled with the name of the plugin including the terminating zero.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.StartProcess">
            <summary>
            Called before the start of process call.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.StopProcess">
            <summary>
            Called after the stop of process call.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetTotalSampleToProcess">
            <summary>
            Called in offline (non RealTime) Process before process is called, indicates how many sample will be processed.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetPanLaw">
            <summary>
            PanLaw : Type (Linear, Equal Power,.. see enum PanLaw Type) in "value", Gain in "opt": for Linear : [1.0 means 0dB PanLaw], [~0.58 means -4.5dB], [0.5 means -6.02dB].
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.BeginLoadBank">
            <summary>
            Called before a Bank is loaded, "ptr" points to VstPatchChunkInfo structure.
            <para>Return -1 if the Bank can not be loaded, return 1 if it can be loaded else 0 (for compatibility).</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.BeginLoadProgram">
            <summary>
            Called before a Program is loaded, "ptr" points to VstPatchChunkInfo structure.
            Return -1 if the Program can not be loaded, return 1 if it can be loaded else 0 (for compatibility).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.SetProcessPrecision">
            <summary>
            Sets the processing precision in "value" (0=32 bit, 1=64 bit).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetNumMidiInputChannels">
            <summary>
            Returns the number of used MIDI input channels (1-15).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.GetNumMidiOutputChannels">
            <summary>
            Returns the number of used MIDI output channels (1-15).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDispatcherOpCodes.NumOpcodes">
            <summary>
            Returns the number of available OpCodes
            </summary>
        </member>
        <member name="T:ManagedBass.Vst.BassVstDsp">
            <summary>
            VST DSP flags to be used within the <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" /> method.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDsp.Unicode">
            <summary>
            File is a Unicode (16-bit characters) filename.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDsp.Default">
            <summary>
            Default VST DSP processing.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstDsp.KeepChannels">
            <summary>
            By default, mono effects assigned to stereo channels are mixed down before processing and converted back to stereo afterwards.
            Set this flag to avoid this behaviour in which case only the first channel is affected by processing.
            </summary>
        </member>
        <member name="T:ManagedBass.Vst.BassVstAudioMasterParam">
            <summary>
            This class is only needed if you subclass the audioMaster callback using <see cref="F:ManagedBass.Vst.BassVstAction.AudioMaster"/> in the <see cref="T:ManagedBass.Vst.VstProcedure" /> (see the VST DSK for more information).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.AEffect">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.OpCode">
            <summary>
            Parameter forwarded from the audioMaster callback (one of the <see cref="T:ManagedBass.Vst.BassVstDispatcherOpCodes" />).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.Index">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.Value">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.Pointer">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.Option">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstAudioMasterParam.DoDefault">
            <summary>
            Set this to 0 if you want to skip the normal BASS_VST audioMaster processing.
            In this case the return value is forwarded to the effect.
            </summary>
        </member>
        <member name="T:ManagedBass.Vst.BassVstInfo">
            <summary>
            <see cref="M:ManagedBass.Vst.BassVst.GetInfo(System.Int32,ManagedBass.Vst.BassVstInfo@)" /> writes some information about a vstHandle returned by <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" /> to this BassVstInfo structure.
            </summary>
            <remarks>
            <para>
            VST effects that have no input channels (so called "Instruments") are not loaded by BASS_VST.
            So you can assume <see cref="F:ManagedBass.Vst.BassVstInfo.ChansIn"/> and <see cref="F:ManagedBass.Vst.BassVstInfo.ChansOut"/> to be at least 1.
            </para>
            <para>
            Multi-channel streams should work correctly, if supported by a effect.
            If not, only the first chansIn channels are processed by the effect, the other ones stay unaffected.  
            The opposite, eg. assigning multi-channel effects to stereo channels, should be no problem at all.
            </para>
            <para>
            If mono effects are assigned to stereo channels, the result will be mono, expanded to both channels.
            This behaviour can be switched of using the <see cref="F:ManagedBass.Vst.BassVstDsp.KeepChannels"/> in <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.
            </para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.ChannelHandle">
            <summary>
            The Channel Handle as given to <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.UniqueID">
            <summary>
            A unique ID for the effect (the IDs are registered at Steinberg).
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstInfo.EffectName">
            <summary>
            The effect name (empty string is returned if a plugin does not provide these information).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.EffectVersion">
            <summary>
            The effect version (example 0x01010000 for version 1.1.0.0).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.EffectVstVersion">
            <summary>
            The VST version, the effect was written for (example 0x02030000 for version 2.3.0.0).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.HostVstVersion">
            <summary>
            The VST version supported by BASS_VST (e.g. 2.4).
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstInfo.ProductName">
            <summary>
            The product name (may be empty).
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstInfo.VendorName">
            <summary>
            The vendor name (may be empty).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.VendorVersion">
            <summary>
            The vendor-specific version number (example 0x01010000 for version 1.1.0.0).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.ChansIn">
            <summary>
            Maximum number of possible input channels (should be at least 1 here).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.ChansOut">
            <summary>
            Maximum number of possible output channels (should be at least 1 here).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.InitialDelay">
            <summary>
            For algorithms which need input in the first place, in number of samples.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.HasEditor">
            <summary>
            Has this plugin an embedded editor?
            <para>If <see langword="true" />, the <see cref="M:ManagedBass.Vst.BassVst.EmbedEditor(System.Int32,System.IntPtr)" /> method can be called.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.EditorWidth">
            <summary>
            Initial/current width of the embedded editor, see also <see cref="F:ManagedBass.Vst.BassVstAction.EditorResized"/>.
            <para>For a very few plugins, editorWidth and editorHeight may be 0 if the editor is not yet opened.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.EditorHeight">
            <summary>
            Initial/current height of the embedded editor, see also <see cref="F:ManagedBass.Vst.BassVstAction.EditorResized"/>.
            <para>For a very few plugins, editorWidth and editorHeight may be 0 if the editor is not yet opened.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.AEffect">
            <summary>
            The underlying AEffect object (see the VST SDK).
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.IsInstrument">
            <summary>
            <see langword="true" />=the VST plugin is an instrument, <see langword="false" />=the VST plugin is an effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Vst.BassVstInfo.DspHandle">
            <summary>
            The internal DSP handle.
            </summary>
        </member>
        <member name="T:ManagedBass.Vst.BassVstParamInfo">
            <summary>
            Common information structure about an editable parameter to a VST plugin parameter to be used with <see cref="M:ManagedBass.Vst.BassVst.GetParamInfo(System.Int32,System.Int32,ManagedBass.Vst.BassVstParamInfo@)" />.
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstParamInfo.Name">
            <summary>
            Name of the parameter (empty strings returned if a plugin does not provide these information).
            <para>Examples: Time, Gain, RoomType</para>
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstParamInfo.Unit">
            <summary>
            Unit of the parameter.
            <para>Examples: sec, dB, type</para>
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstParamInfo.Display">
            <summary>
            The current value in a readable format (empty strings returned if a plugin does not provide these information).
            <para>Examples: 0.5, -3, PLATE</para>
            </summary>
        </member>
        <member name="P:ManagedBass.Vst.BassVstParamInfo.DefaultValue">
            <summary>
            The default value (in the range of 0.0 and 1.0).
            </summary>
        </member>
        <member name="T:ManagedBass.Vst.VstProcedure">
            <summary>
            User defined VST callback method to be used with <see cref="M:ManagedBass.Vst.BassVst.SetCallback(System.Int32,ManagedBass.Vst.VstProcedure,System.IntPtr)" />.
            </summary>
            <param name="VstHandle">The VST plugin handle as returned from <see cref="M:ManagedBass.Vst.BassVst.ChannelSetDSP(System.Int32,System.String,ManagedBass.Vst.BassVstDsp,System.Int32)" />.</param>
            <param name="Action">The action parameter, one of the <see cref="T:ManagedBass.Vst.BassVstAction" /> values (see below).</param>
            <param name="Param1">The first parameter (see the VST SDK for further details).</param>
            <param name="Param2">The second parameter (see the VST SDK for further details).</param>
            <param name="User">The user parameter as specified in the <see cref="M:ManagedBass.Vst.BassVst.SetCallback(System.Int32,ManagedBass.Vst.VstProcedure,System.IntPtr)" /> call.</param>
            <returns>Unless defined otherwise, the callback function should always return 0.</returns>
        </member>
        <member name="T:ManagedBass.DShow.BassDShow">
            <summary>
            BASS_DSHOW/xVideo is an extention to the BASS audio library, providing a set of functions for rendering direct show audio and video content.
            </summary>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.CallbackItemByIndex(ManagedBass.DShow.BassDShowCallbackItem,System.Int32)">
            <summary>
            This method is an alternative way to get item names on methods that require callbacks.
            </summary>
            <param name="CallbackType">The type of value to get (one of the <see cref="T:ManagedBass.DShow.BassDShowCallbackItem" /> values or a valid video HSTREAM to return the name of a connected filter from that channel).</param>
            <param name="Index">The index of the requered item (must be greater than 0).</param>
            <returns>If successful, the name of the requested item type is returned - else <see langword="null" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.CaptureCreate(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Creates a capture stream from audio/video capture devices.
            </summary>
            <param name="Audio">The audio device index (use 0 to disable audio capture).</param>
            <param name="Video">The video device index (use 0 to disable video capture).</param>
            <param name="AudioProfile">The audio profile to use (as returned by <see cref="M:ManagedBass.DShow.BassDShow.CaptureDeviceProfiles(System.Int32,ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumProfilesProcedure,System.IntPtr)" />).</param>
            <param name="VideoProfile">The video profile to use (as returned by <see cref="M:ManagedBass.DShow.BassDShow.CaptureDeviceProfiles(System.Int32,ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumProfilesProcedure,System.IntPtr)" />).</param>
            <param name="Flags">Any combination of <see cref="F:ManagedBass.BassFlags.Decode"/> and <see cref="F:ManagedBass.BassFlags.DShowStreamMix"/>.</param>
            <returns>If successful, the new capture handle is returned - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.CaptureDeviceProfiles(System.Int32,ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumProfilesProcedure,System.IntPtr)">
            <summary>
            Gets the available audio or video capture device profiles.
            </summary>
            <param name="Device">The device you want to get then profiles from (see <see cref="M:ManagedBass.DShow.BassDShow.CaptureGetDevices(ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)" />).</param>
            <param name="DeviceType">The type of capture device to get (one of the <see cref="T:ManagedBass.DShow.BassDShowCapture" /> values, either audio or video).</param>
            <param name="Procedure">The user defined callback receiving the available capture devices (see <see cref="T:ManagedBass.DShow.EnumProfilesProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the number of available capture device profiles are returned - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.CaptureFree(System.Int32)">
            <summary>
            Frees a capture stream.
            </summary>
            <param name="Handle">The capture stream handle to free (as returned by <see cref="M:ManagedBass.DShow.BassDShow.CaptureCreate(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)" />).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.CaptureGetDevices(ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)">
            <summary>
            Gets the available audio or video capture devices.
            </summary>
            <param name="DeviceType">The type of capture device to get (one of the <see cref="T:ManagedBass.DShow.BassDShowCapture" /> values, either audio or video).</param>
            <param name="Procedure">The user defined callback receiving the available capture devices (see <see cref="T:ManagedBass.DShow.EnumDevicesProcedure" />) or <see langword="null" /> to retrieve only the number of available devices.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the number of available capture devices found is returns - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            <para>When using <see langword="null" /> as a <paramref name="Procedure" /> callback value this will return the number of the devices from the system only.</para>
            <para>Another way to get the capture devices is by using the <see cref="M:ManagedBass.DShow.BassDShow.CallbackItemByIndex(ManagedBass.DShow.BassDShowCallbackItem,System.Int32)" /> method.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelAddFile(System.Int32,System.String)">
            <summary>
            Adds a new media file to a channel (e.g. for mixing multiple videos).
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Filename">The media file to add.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>This method can be used to mix multiple videos to the same channel.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelAddWindow(System.Int32,System.IntPtr)">
            <summary>
            Adds a new Video Window to the channel.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="hWnd">A valid window handle.</param>
            <returns>If successful, the new video window handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>
            You can use this function to a new video window to a channel.
            Adding new windows depends on the hardware capabilities (adding many new windows might result in a high CPU usage). 
            You can use the <see cref="M:ManagedBass.DShow.BassDShow.ChannelRemoveWindow(System.Int32,System.Int32)" /> function to remove an added video window.
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelColorRange(System.Int32,ManagedBass.DShow.BassDShowColorControl,ManagedBass.DShow.BassDShowColorRange@)">
            <summary>
            Retrieves the color controls range (min,max,step). 
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Id">One of <see cref="T:ManagedBass.DShow.BassDShowColorControl" /> values.</param>
            <param name="Ctrl">An instance of the <see cref="T:ManagedBass.DShow.BassDShowColorRange" /> structure to set the range info to.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>This function was tested successfully on VMR9. It may work on other renderers and also will depend on the hardware capabilities.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelColorRange(System.Int32,ManagedBass.DShow.BassDShowColorControl)">
            <summary>
            Retrieves the color controls range (min,max,step). 
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Id">One of <see cref="T:ManagedBass.DShow.BassDShowColorControl" />) values.</param>
            <returns>If an error occurred then <see langword="null" /> is returned, else an instance of <see cref="T:ManagedBass.DShow.BassDShowColorRange" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>This function was tested successfully on VMR9. It may work on other renderers and also will depend on the hardware capabilities.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelEnableStream(System.Int32,System.Int32)">
            <summary>
            Enables a stream within a video.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Index">The zero-based stream index to enable (use <see cref="M:ManagedBass.DShow.BassDShow.ChannelStreamsCount(System.Int32)" /> to get the number of streams).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelEnumerateStreams(System.Int32,ManagedBass.DShow.VideoStreamsProcedure,System.IntPtr)">
            <summary>
            Enumerates connected streams on a video handle.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Procedure">The callback function (see <see cref="T:ManagedBass.DShow.VideoStreamsProcedure" />) to retrieve the stream information.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successfull, the number of streams are returned, else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetAttribute(System.Int32,ManagedBass.DShow.BassDShowAttribute)">
            <summary>
            Gets an attribute value from a HSTREAM.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Attribute">One of <see cref="T:ManagedBass.DShow.BassDShowAttribute" /> values.</param>
            <returns>If successful, the current attribute value is returned - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetBitmap(System.Int32)">
            <summary>
            Retrieves the current video frame.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If successful, a pointer to an image (HBITMAP) is returned, else <see cref="F:System.IntPtr.Zero"/> is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>If the current video renderer is the NULL one, or a stream don't have video then a NULL value will be returned.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetConnectedFilters(System.Int32,ManagedBass.DShow.ConnectedFiltersProcedure,System.IntPtr)">
            <summary>
            Retrieves the connected filters to a channel.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Procedure">The user defined callback receiving the connected filters (see <see cref="T:ManagedBass.DShow.ConnectedFiltersProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the number of connected filters is returns - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            <para>When using <see langword="null" /> as a <paramref name="Procedure" /> callback value this will return the number of connected filters only.</para>
            <para>Another way to get the connected filters is by using the <see cref="M:ManagedBass.DShow.BassDShow.CallbackItemByIndex(ManagedBass.DShow.BassDShowCallbackItem,System.Int32)" /> method.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetInfo(System.Int32,ManagedBass.DShow.BassDShowChannelInfo@)">
            <summary>
            Retrieves information on a video channel.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Info"><see cref="T:ManagedBass.DShow.BassDShowChannelInfo" /> instance where to store the channel information at.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetInfo(System.Int32)">
            <summary>
            Retrieves information on a video channel.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>A <see cref="T:ManagedBass.DShow.BassDShowChannelInfo" /> instance containing the video info.</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetLength(System.Int32,ManagedBass.DShow.BassDShowMode)">
            <summary>
            Gets the length of the video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Mode">How to get the position. One of <see cref="T:ManagedBass.DShow.BassDShowMode" /> values.</param>
            <returns>
            If successful, the length of the video stream in units according to the <see cref="T:ManagedBass.DShow.BassDShowMode" /> used,
            else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.
            </returns>
            <remarks>0 is ussualy returned when the stream doesn't contain video or if an invalid channel handle was specified.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetPosition(System.Int32,ManagedBass.DShow.BassDShowMode)">
            <summary>
            Gets the current position of the video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Mode">How to get the position. One of <see cref="T:ManagedBass.DShow.BassDShowMode" /> values.</param>
            <returns>
            If successful, the current position of the video stream in units according to the <see cref="T:ManagedBass.DShow.BassDShowMode" /> used,
            else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.
            </returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetState(System.Int32)">
            <summary>
            Gets the current state of a channel (playing/stopped/paused).
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If successful, the current <see cref="T:ManagedBass.DShow.BassDShowState" /> is returns - else -1 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelGetStream(System.Int32,System.Int32)">
            <summary>
            Gets information about a video stream.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Index">The zero-based stream index to retrieve the info from (use <see cref="M:ManagedBass.DShow.BassDShow.ChannelStreamsCount(System.Int32)" /> to get the number of streams).</param>
            <returns>If an error occurred then <see langword="null" /> is returned, else the <see cref="T:ManagedBass.DShow.BassDShowStreams" /> instance is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelOverlayBMP(System.Int32,ManagedBass.DShow.BassDShowVideoBitmap)">
            <summary>
            Overlays a HDC to the video window.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Bitmap">An instance of the <see cref="T:ManagedBass.DShow.BassDShowVideoBitmap" /> class to overlay.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelPause(System.Int32)">
            <summary>
            Pauses playback of a video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelPlay(System.Int32)">
            <summary>
            Starts playback of a video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelRemoveDVP(System.Int32,System.Int32)">
            <summary>
            Removes a DVP function from a video stream.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Dvp">Handle of the DVP function to remove from the channel (return value of a previous <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetDVP(System.Int32,ManagedBass.DShow.DvpProcedure,System.IntPtr)" /> call).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelRemoveWindow(System.Int32,System.Int32)">
            <summary>
            Removes an added video window from the channel.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Window">A valid window handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.ChannelAddWindow(System.Int32,System.IntPtr)" />) to remove.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelRepaint(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Repaints a window less video renderer.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Window">A valid window handle.</param>
            <param name="HDC">A valid HDC.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>Sometimes window less video renderers needs to be repainted manually (e.g. if they cannot receive the WM_PAINT message).</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelResizeWindow(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes the rendering of a video stream to a new size.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Window">A valid window handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.ChannelAddWindow(System.Int32,System.IntPtr)" />) to resize or 0(zero) for the main video window.</param>
            <param name="Left">The left coordinate.</param>
            <param name="Top">The top coordinate.</param>
            <param name="Right">The right coordinate.</param>
            <param name="Bottom">The bottom coordinate.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetAttribute(System.Int32,ManagedBass.DShow.BassDShowAttribute,System.Single)">
            <summary>
            Sets an attribute value to a HSTREAM.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Attribute">One of the <see cref="T:ManagedBass.DShow.BassDShowAttribute" /> values.</param>
            <param name="NewValue">The new attribute value.</param>
            <remarks>Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetColors(System.Int32,ManagedBass.DShow.BassDShowColorControl,ManagedBass.DShow.BassDShowVideoColors)">
            <summary>
            Sets new values to color controls.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Id">Any combination of <see cref="T:ManagedBass.DShow.BassDShowColorControl"/> flags.</param>
            <param name="Colors">An instance of the <see cref="T:ManagedBass.DShow.BassDShowVideoColors" /> structure to apply the color changes from.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>This function was tested successfully on VMR9. It may work on other renderers and also will depend on the hardware capabilities.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetDVP(System.Int32,ManagedBass.DShow.DvpProcedure,System.IntPtr)">
            <summary>
            Sets up a user DVP function on a video stream.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Procedure">The callback function (see <see cref="T:ManagedBass.DShow.DvpProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successfull, the new DVP handle is returned, else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            DVP functions can be set any time on a channel. A channel support a infinite number of DVP callbacks, and it will be processed in the same order that was added.
            Use <see cref="M:ManagedBass.DShow.BassDShow.ChannelRemoveDVP(System.Int32,System.Int32)" /> to remove a DVP.
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetFullscreen(System.Int32,System.Boolean)">
            <summary>
            Toggles the rendering of a video stream between full screen (on/off).
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="FullScreen"><see langword="true" /> to toggle the rendering to full screen - <see langword="false" /> to turn full screen rendering off.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetPosition(System.Int32,System.Double,ManagedBass.DShow.BassDShowMode)">
            <summary>
            Sets the playback position of a video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Position">The new position to set.</param>
            <param name="Mode">How to retrieve the position. One of the <see cref="T:ManagedBass.DShow.BassDShowMode" /> values.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetSync(System.Int32,ManagedBass.DShow.VideoSyncProcedure,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a video channel.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelSetWindow(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Sets s video window handle.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Window">A valid window handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.ChannelAddWindow(System.Int32,System.IntPtr)" />) or 0 for the main video window.</param>
            <param name="hWnd">A valid window handle.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelStop(System.Int32)">
            <summary>
            Stops playback of a video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ChannelStreamsCount(System.Int32)">
            <summary>
            Gets the number of streams for a video handle.
            </summary>
            <param name="Handle">The video channel handle (as e.g. returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If successfull, the number of streams are returned, else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.DVDChannelMenu(System.Int32,ManagedBass.DShow.BassDShowDVDMenu,System.Int32,System.Int32)">
            <summary>
            Sets DVD MENU options.
            </summary>
            <param name="Handle">The DVD stream handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateDVD(System.String,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Option">One of the <see cref="T:ManagedBass.DShow.BassDShowDVDMenu" /> values.</param>
            <param name="Value1">The 1st value to set.</param>
            <param name="Value2">The 2nd value to set.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.DVDGetProperty(System.Int32,ManagedBass.DShow.BassDShowDVDGetProperty,System.Int32)">
            <summary>
            Gets DVD properties.
            </summary>
            <param name="Handle">The DVD stream handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateDVD(System.String,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Property">One of the <see cref="T:ManagedBass.DShow.BassDShowDVDGetProperty" /> values.</param>
            <param name="Value">The value to get.</param>
            <returns>The requested property result value (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.DVDSetProperty(System.Int32,ManagedBass.DShow.BassDShowDVDSetProperty,System.Int32)">
            <summary>
            Sets DVD properties.
            </summary>
            <param name="Handle">The DVD stream handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateDVD(System.String,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Property">One of the <see cref="T:ManagedBass.DShow.BassDShowDVDSetProperty" /> values.</param>
            <param name="NewValue">The new value to set.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="P:ManagedBass.DShow.BassDShow.LastError">
            <summary>
            Retrieves the error code for the most recent BASS_DSHOW function call.
            </summary>
            <returns>
            If no error occured during the last BASS_DSHOW function call then <see cref="F:ManagedBass.DShow.BassDShowError.OK"/> is returned, else one of the <see cref="T:ManagedBass.DShow.BassDShowError" /> values is returned. 
            See the function description for an explanation of what the error code means.
            </returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.Free">
            <summary>
            Frees all resources used by DSHOW, including all it's streams.
            </summary>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>This function will also free all streams created by BASS_DSHOW.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.GetAudioRenderers(ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)">
            <summary>
            Gets the available audio render devices available on the system.
            </summary>
            <param name="Procedure">The user defined callback receiving the available audio render devices (see <see cref="T:ManagedBass.DShow.EnumDevicesProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the number of available audio render devices found is returns - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            <para>When using <see langword="null" /> as a <paramref name="Procedure" /> callback value this will return the number of the audio render devices from the system only.</para>
            <para>Another way to get the capture devices is by using the <see cref="M:ManagedBass.DShow.BassDShow.CallbackItemByIndex(ManagedBass.DShow.BassDShowCallbackItem,System.Int32)" /> method.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.GetConfig(ManagedBass.DShow.BassDShowConfig)">
            <summary>
            Gets a BASS_DSHOW configuration option.
            </summary>
            <param name="Option">The option to set (one of the <see cref="T:ManagedBass.DShow.BassDShowConfig" /> values).</param>
            <returns>If successful, the config option value is returned (see below), else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.GetGraph(System.Int32)">
            <summary>
            Gets an instance IGraphBuilder interface of a channel.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If successful, the new video window handle is returned, else <see cref="F:System.IntPtr.Zero"/> is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>
            After getting an instance of the IGraphBuilder interface and add reference to it, and used it, the instance must be released by user, or memory leaks will appear.
            </remarks>
        </member>
        <member name="P:ManagedBass.DShow.BassDShow.Version">
            <summary>
            Retrieves the version number of the BASS_DSHOW that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.GetVideoAlpha(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a video window layer alpha blend value.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Window">A valid window handle as returned by <see cref="M:ManagedBass.DShow.BassDShow.ChannelAddWindow(System.Int32,System.IntPtr)" /> or 0(zero) for the main video window.</param>
            <param name="Layer">The video layer (0...15).</param>
            <returns>If an error occurred then -1 is returned, else the alpha blend value is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.Init(System.IntPtr,ManagedBass.DShow.BassDShowInit)">
            <summary>
            Initialize the DSHOW library. This will initialize the library for use.
            </summary>
            <param name="hWnd">The application's main window or 0 = the current foreground window (use this for console applications).</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.DShow.BassDShowInit"/> flags.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>Call this method prior to any other BASS_DSHOW methods.</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.LoadPlugin(System.String)">
            <summary>
            Loads a BASS_DSHOW plugin.
            </summary>
            <param name="File">The plugin filename to load.</param>
            <returns>If successful, the plugin handle is returned - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.LoadPluginDS(System.String,System.String)">
            <summary>
            Loads a DirectShow plugin.
            </summary>
            <param name="Guid">The CLSID/GUID string of the DirectShow filter to use.</param>
            <param name="Name">The name of the filter.</param>
            <returns>If successful, the plugin handle is returned - else 0 is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>The necesary DirectShow codec to decode the video must be available!</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.MIXChannelResize(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes a mixing channel
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Layer">The video layer (0...15).</param>
            <param name="Left">The left position of the video.</param>
            <param name="Top">The top position of the video.</param>
            <param name="Right">The right position of the video.</param>
            <param name="Bottom">The bottom position of the video.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.PluginGetInfo(System.Int32)">
            <summary>
            Gets information about a loaded plugin.
            </summary>
            <param name="Plugin">The plugin handled (as returned by <see cref="M:ManagedBass.DShow.BassDShow.LoadPlugin(System.String)" />).</param>
            <returns>If an error occurred then <see langword="null" /> is returned, else an instance of <see cref="T:ManagedBass.DShow.BassDShowPluginInfo" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.PluginGetInfo(System.Int32,ManagedBass.DShow.BassDShowPluginInfo@)">
            <summary>
            Gets information about a loaded plugin.
            </summary>
            <param name="Plugin">The plugin handled (as returned by <see cref="M:ManagedBass.DShow.BassDShow.LoadPlugin(System.String)" />).</param>
            <param name="Info">An instance of <see cref="T:ManagedBass.DShow.BassDShowPluginInfo" /> to store the information at.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.Register(System.String,System.String)">
            <summary>
            Registers you DSHOW/xVideo license.
            </summary>
            <param name="Email">Your email address.</param>
            <param name="Code">Your registration code.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.RemovePlugin(System.Int32)">
            <summary>
            Removes a loaded plugin and frees all resources.
            </summary>
            <param name="Plugin">The plugin handled to unload (as returned by <see cref="M:ManagedBass.DShow.BassDShow.LoadPlugin(System.String)" />).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.SetConfig(ManagedBass.DShow.BassDShowConfig,System.Int32)">
            <summary>
            Sets a BASS_DSHOW configuration option.
            </summary>
            <param name="Option">The option to set (one of the <see cref="T:ManagedBass.DShow.BassDShowConfig" /> values).</param>
            <param name="NewValue">The value to use.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.SetConfig(ManagedBass.DShow.BassDShowConfig,ManagedBass.DShow.BassDShowConfigFlag)">
            <summary>
            Sets a BASS_DSHOW configuration option.
            </summary>
            <param name="Option">The option to set (one of the <see cref="T:ManagedBass.DShow.BassDShowConfig" /> values).</param>
            <param name="NewValue">One of the <see cref="T:ManagedBass.DShow.BassDShowConfigFlag" /> values to use.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.SetVideoAlpha(System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            Sets a video window alpha blend value.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Window">A valid window handle as returned by <see cref="M:ManagedBass.DShow.BassDShow.ChannelAddWindow(System.Int32,System.IntPtr)" /> or 0(zero) for the main video window.</param>
            <param name="Layer">The video layer (0...15).</param>
            <param name="Alpha">The new alpha blend value (0...100).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.ShowFilterPropertyPage(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Shows a filter property page.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Filter">The filter number (must be greater than 0, see <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetConnectedFilters(System.Int32,ManagedBass.DShow.ConnectedFiltersProcedure,System.IntPtr)" />).</param>
            <param name="Parent">The parent window handle to use when showing th property page dialog.</param>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.StreamCreateDVD(System.String,System.IntPtr,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from a DVD or VOB file.
            </summary>
            <param name="Dvd">The DVD or VOB filename or <see langword="null" /> to render first DVD device.</param>
            <param name="Window">An initial window handle (can be <see cref="F:System.IntPtr.Zero"/>).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>The necesary codec to decode the video must be available!</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from a supported file.
            </summary>
            <param name="File">The filename to render.</param>
            <param name="Position">The position to begin playing from.</param>
            <param name="Window">An initial window handle (can be <see cref="F:System.IntPtr.Zero" />).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>
            <para>The necesary codec to decode the video must be available!</para>
            <para>When a start position is specified and the requested position is not available, playback it will start automaticaly from the begginning.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.StreamCreateMemory(System.IntPtr,System.Int64,System.IntPtr,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from memory data.
            </summary>
            <param name="Memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="Length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="Window">An initial window handle (can be <see cref="F:System.IntPtr.Zero" />).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>The necesary codec to decode the video must be available!</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.StreamCreateFileUser(ManagedBass.BassFlags,System.IntPtr,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>
            Creates a sample stream using user file procedures.
            </summary>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Window">An initial window handle (can be <see cref="F:System.IntPtr.Zero" />).</param>
            <param name="Procedures">The user defined file function (see <see cref="T:ManagedBass.FileProcedures" />).</param>
            <param name="User">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>The necesary codec to decode the video must be available!</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.StreamCreateFilter(System.String,System.String,System.IntPtr,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from a supported file using a given filter.
            </summary>
            <param name="File">The filename to render.</param>
            <param name="Filter">The CLSID/GUID string of the filter to use.</param>
            <param name="Window">An initial window handle (can be <see cref="F:System.IntPtr.Zero" />).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code.</returns>
            <remarks>The necesary codec to decode the video must be available!</remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.StreamFree(System.Int32)">
            <summary>
            Frees all resources of a video stream.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.VCamPush(System.Int32,System.IntPtr)">
            <summary>
            Send video from user file data to a virtual webcam.
            </summary>
            <param name="Window">A Handle to the application window.</param>
            <param name="Data">The pointer to the video data to push.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            Make sure that xVirtualCam is registered and running when calling this function, otherwise this function will return <see langword="false" />.
            <para>The <paramref name="Data"/> parameter can't be <see cref="F:System.IntPtr.Zero" />, and MUST be 320 * 240 * 4 in size (320 Width, 240 Height, 32 bits).</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.VCamPush(System.Int32,System.Byte[])">
            <summary>
            Send video from user file data to a virtual webcam.
            </summary>
            <param name="Window">A Handle to the application window.</param>
            <param name="Data">The video data to push.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            Make sure that xVirtualCam is registered and running when calling this function, otherwise this function will return <see langword="false" />.
            <para>The <paramref name="Data"/> parameter can't be <see cref="F:System.IntPtr.Zero" />, and MUST be 320 * 240 * 4 in size (320 Width, 240 Height, 32 bits).</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.VCamPush(System.Int32,System.Int64[])">
            <summary>
            Send video from user file data to a virtual webcam.
            </summary>
            <param name="Window">A Handle to the application window.</param>
            <param name="Data">The video data to push.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>
            Make sure that xVirtualCam is registered and running when calling this function, otherwise this function will return <see langword="false" />.
            <para>The <paramref name="Data"/> parameter can't be <see cref="F:System.IntPtr.Zero" />, and MUST be 320 * 240 * 4 in size (320 Width, 240 Height, 32 bits).</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.DShow.BassDShow.BASS_DSHOW_VCamStreamChannel(System.Int32,System.Boolean)">
            <summary>
            Send video data from a HSTREAM to a virtual webcam.
            </summary>
            <param name="Handle">The video channel handle (as returned by <see cref="M:ManagedBass.DShow.BassDShow.StreamCreateFile(System.String,System.Int32,System.IntPtr,ManagedBass.BassFlags)" />).</param>
            <param name="Stream">Enable (<see langword="true" />) or disable (<see langword="false" />) the streaming of a channel.</param>
            <returns>If an error occurred then <see langword="false" /> is returned, else <see langword="true" /> is returned (use <see cref="P:ManagedBass.DShow.BassDShow.LastError" /> to get the error code).</returns>
            <remarks>Make sure that xVirtualCam is registered and running when calling this function, otherwise this function will return <see langword="false" />.</remarks>
        </member>
        <member name="T:ManagedBass.DShow.ConnectedFiltersProcedure">
            <summary>
            User defined callback function to receive connected filters (see <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetConnectedFilters(System.Int32,ManagedBass.DShow.ConnectedFiltersProcedure,System.IntPtr)" />).
            </summary>
            <param name="Filter">A pointer to the connected filter instance (IBaseFilter). Note that this instance should be used inside the callback as it is released automaticaly once the callback returned.</param>
            <param name="FilterName">The name of the connected filter.</param>
            <param name="HasPropertyPage"><see langword="true" /> if the filter has a property page (dialog), <see langword="false" /> if not.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetConnectedFilters(System.Int32,ManagedBass.DShow.ConnectedFiltersProcedure,System.IntPtr)" /> was called.</param>
            <returns><see langword="true" /> to continue, else <see langword="false" />.</returns>
        </member>
        <member name="T:ManagedBass.DShow.DvpProcedure">
            <summary>
            User defined DSP callback function (to be used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetDVP(System.Int32,ManagedBass.DShow.DvpProcedure,System.IntPtr)" />).
            </summary>
            <param name="Handle">The DVP handle.</param>
            <param name="Channel">The video channel that the DVP applies to.</param>
            <param name="Buffer">The pointer to the sample data to apply the DVP to.</param>
            <param name="Length">The number of bytes to process.</param>
            <param name="DataType">One of the <see cref="T:ManagedBass.DShow.BassDShowDvpType" /> values.</param>
            <param name="Width">The video width.</param>
            <param name="Height">The video height.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetDVP(System.Int32,ManagedBass.DShow.DvpProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.DShow.EnumDevicesProcedure">
            <summary>
            User defined callback function to receive capture devices (see <see cref="M:ManagedBass.DShow.BassDShow.CaptureGetDevices(ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)" />) or audio render devices (see <see cref="M:ManagedBass.DShow.BassDShow.GetAudioRenderers(ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)" />).
            </summary>
            <param name="Name">The name of the capture (or audio render) device.</param>
            <param name="Guid">The GUID of the capture (or audio render) device.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.DShow.BassDShow.CaptureGetDevices(ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.DShow.BassDShow.GetAudioRenderers(ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)" /> was called.</param>
            <returns><see langword="true" /> to continue, else <see langword="false" />.</returns>
        </member>
        <member name="T:ManagedBass.DShow.EnumProfilesProcedure">
            <summary>
            User defined callback function to receive capture device profiles (see <see cref="M:ManagedBass.DShow.BassDShow.CaptureDeviceProfiles(System.Int32,ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumProfilesProcedure,System.IntPtr)" />).
            </summary>
            <param name="Profile">The profile name of the capture device.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.DShow.BassDShow.CaptureDeviceProfiles(System.Int32,ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumProfilesProcedure,System.IntPtr)" /> was called.</param>
            <returns><see langword="true" /> to continue, else <see langword="false" />.</returns>
        </member>
        <member name="T:ManagedBass.DShow.VideoStreamsProcedure">
            <summary>
            User defined callback function to enumerate connected streams (see <see cref="M:ManagedBass.DShow.BassDShow.ChannelEnumerateStreams(System.Int32,ManagedBass.DShow.VideoStreamsProcedure,System.IntPtr)" />).
            </summary>
            <param name="Format">The stream format (0: unknown, 1: video , 2: audio , 3: subtitle).</param>
            <param name="Name">The format name.</param>
            <param name="Index">The stream index (use this index to enable or disable it).</param>
            <param name="Enabled">Is this stream enabled?</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.DShow.BassDShow.ChannelEnumerateStreams(System.Int32,ManagedBass.DShow.VideoStreamsProcedure,System.IntPtr)" /> was called.</param>
            <returns><see langword="true" /> to continue, else <see langword="false" />.</returns>
        </member>
        <member name="T:ManagedBass.DShow.VideoSyncProcedure">
            <summary>
            User defined synchronizer callback function (see <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetSync(System.Int32,ManagedBass.DShow.VideoSyncProcedure,System.IntPtr)" /> for details).
            </summary>
            <param name="Channel">The channel that the sync applies to.</param>
            <param name="Sync">The sync occurred (one of <see cref="T:ManagedBass.DShow.BassDShowSync" />).</param>
            <param name="Data">The data associated with the sync (see <see cref="T:ManagedBass.DShow.BassDShowSync" /> for details).</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetSync(System.Int32,ManagedBass.DShow.VideoSyncProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowAttribute">
            <summary>
            Channel attribute options used by <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetAttribute(System.Int32,ManagedBass.DShow.BassDShowAttribute,System.Single)" /> and <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetAttribute(System.Int32,ManagedBass.DShow.BassDShowAttribute)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowAttribute.Volume">
            <summary>
            The audio volume level.
            <para>volume: The volume level... 0 (silent) to 1 (full).</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowAttribute.Pan">
            <summary>
            The audio panning/balance position.
            <para>pan: The pan position... -1 (full left) to +1 (full right), 0 = centre.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowAttribute.Rate">
            <summary>
            The video graph rate.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowAttribute.Alpha">
            <summary>
            The main video alpha bland value.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowCallbackItem">
            <summary>
            Option to be used with <see cref="M:ManagedBass.DShow.BassDShow.CallbackItemByIndex(ManagedBass.DShow.BassDShowCallbackItem,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowCallbackItem.AudioCapture">
            <summary>
            Used to get the audio capture device.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowCallbackItem.VideoCapture">
            <summary>
            Used to get the video capture device.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowCallbackItem.AudioRenderer">
            <summary>
            Used to get the audio renderer device.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowCapture">
            <summary>
            Capture options to be used with <see cref="M:ManagedBass.DShow.BassDShow.CaptureGetDevices(ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumDevicesProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.DShow.BassDShow.CaptureDeviceProfiles(System.Int32,ManagedBass.DShow.BassDShowCapture,ManagedBass.DShow.EnumProfilesProcedure,System.IntPtr)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowCapture.CaptureAudio">
            <summary>
            Capture Audio.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowCapture.CaptureVideo">
            <summary>
            Capture Video.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowColorControl">
            <summary>
            Flags to be used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetColors(System.Int32,ManagedBass.DShow.BassDShowColorControl,ManagedBass.DShow.BassDShowVideoColors)" /> and <see cref="M:ManagedBass.DShow.BassDShow.ChannelColorRange(System.Int32,ManagedBass.DShow.BassDShowColorControl,ManagedBass.DShow.BassDShowColorRange@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorControl.Brightness">
            <summary>
            Gets of sets the Brightness value.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorControl.Contrast">
            <summary>
            Gets of sets the Contrast value.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorControl.Hue">
            <summary>
            Gets of sets the Hue value.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorControl.Saturation">
            <summary>
            Gets of sets the Saturatio value.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowConfig">
            <summary>
            Configuration options to be used with <see cref="M:ManagedBass.DShow.BassDShow.SetConfig(ManagedBass.DShow.BassDShowConfig,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer">
            <summary>
            Selects the video renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfig.WindowLessHandle">
            <summary>
            VMR7/VMR9 WindowLess Mode need an initial window so set a HWND to use properly VMR.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfig.WindowLessStreams">
            <summary>
            Sets the number of streams in a VMR7/9 windows less mode.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfig.AudioRenderer">
            <summary>
            Selects audio renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfig.FloatDsp">
            <summary>
            Enables/disables floating point processing DSP.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowConfigFlag">
            <summary>
            Configuration option flags to be used with <see cref="M:ManagedBass.DShow.BassDShow.SetConfig(ManagedBass.DShow.BassDShowConfig,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.VMR7">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer" /> to select the VMR7 Windowed renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.VMR9">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer" /> to select the VMR9 Windowed renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.VMR7WindowsLess">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer" /> to select the VMR7 window less renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.VMR9WindowsLess">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer" /> to select the VMR9 window less renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.EVR">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer" /> to select the Enhanced video renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.NullVideo">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.VideoRenderer" /> to select the NULL video renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.NullAudio">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.AudioRenderer" /> to select the NULL audio renderer.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowConfigFlag.BASS_DSHOW_DefaultAudio">
            <summary>
            Used with <see cref="F:ManagedBass.DShow.BassDShowConfig.AudioRenderer" /> to select the Windows default audio device.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowDVDGetProperty">
            <summary>
            DVD property options used by <see cref="M:ManagedBass.DShow.BassDShow.DVDGetProperty(System.Int32,ManagedBass.DShow.BassDShowDVDGetProperty,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentTitleDuration">
            <summary>
            Flag to be used as the 'value' parameter with the <see cref="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentDVDTitle" /> option to get the current title duration.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentTitlePosition">
            <summary>
            Flag to be used as the 'value' parameter with the <see cref="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentDVDTitle" /> option to get the current title position.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentDVDTitle">
            <summary>
            Gets either the current title duration or position (see <see cref="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentTitleDuration" /> and <see cref="F:ManagedBass.DShow.BassDShowDVDGetProperty.CurrentTitlePosition" />).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDGetProperty.DVDTitles">
            <summary>
            Gets the number of titles of a DVD stream.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDGetProperty.DVDTitleChapters">
            <summary>
            Gets the number of chapters of a title.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowDVDMenu">
            <summary>
            DVD menu options used by <see cref="M:ManagedBass.DShow.BassDShow.DVDChannelMenu(System.Int32,ManagedBass.DShow.BassDShowDVDMenu,System.Int32,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDMenu.SelectAtPos">
            <summary>
            Select MENU from Point.
            <para>value1 parameter should be the x coordonate.</para>
            <para>value2 parameter should be the y coordonate.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDMenu.ActionAtPos">
            <summary>
            Activate Button from Point.
            <para>value1 parameter should be the x coordonate.</para>
            <para>value2 parameter should be the y coordonate.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDMenu.ActivateButton">
            <summary>
            Handle a enter key down event.
            <para>value1 parameter is ignored (should be 0).</para>
            <para>value2 parameter is ignored (should be 0).</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDMenu.SelectButton">
            <summary>
            Handle arrow key events.
            <para>value1: 0=VK_LEFT, -1=VK_RIGHT, -2=VK_UP, -3=VK_DOWN.</para>
            <para>value2 parameter is ignored (should be 0).</para>
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowDVDSetProperty">
            <summary>
            DVD property options used by <see cref="M:ManagedBass.DShow.BassDShow.DVDSetProperty(System.Int32,ManagedBass.DShow.BassDShowDVDSetProperty,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.TitleMenu">
            <summary>
            Go to DVD title menu.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.Root">
            <summary>
            Go to DVD root.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.NextChapter">
            <summary>
            Go to dvd next chapter.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.PreviousChapter">
            <summary>
            Go to dvd previous chapter.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.Title">
            <summary>
            Go to dvd title.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.TitleChapter">
            <summary>
            Play chapter in current title.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDVDSetProperty.CurrentTitlePosition">
            <summary>
            Sets the current title playing position.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowDvpType">
            <summary>
            Channel DVP type used with a <see cref="T:ManagedBass.DShow.DvpProcedure" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.RGB24">
            <summary>
            RGB24. Rgb24 is a sRGB format with 24 bits per pixel (BPP). Each color channel (red, green, and blue) is allocated 8 bits per pixel (BPP).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.RGB32">
            <summary>
            RGB32. Rgb32 is a sRGB format with 32  bits per pixel (BPP). Each color channel (red, green, and blue) is allocated 8 bits per pixel (BPP).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.YUYV">
            <summary>
            YUYV.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.IYUV">
            <summary>
            IYUV.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.YVU9">
            <summary>
            YVU9.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.YV12">
            <summary>
            YV12.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.NV12">
            <summary>
            NV12.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowDvpType.UYVY">
            <summary>
            UYVY,
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowError">
            <summary>
            BASS_DSHOW error codes as returned by <see cref="P:ManagedBass.DShow.BassDShow.LastError" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.OK">
            <summary>
            All is OK.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.InvalidChannel">
            <summary>
            Invalid channel.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.Unknown">
            <summary>
            Unknown error.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.NotInitialized">
            <summary>
            Not initialized.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.PositionNotAvailable">
            <summary>
            Position not available.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.NoDShow">
            <summary>
            No DSHOW/xVideo.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.InvalidWindow">
            <summary>
            Invalid window.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.NoAudio">
            <summary>
            No Audio.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.NoVideo">
            <summary>
            No Video.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.Memory">
            <summary>
            Memory error.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.Callback">
            <summary>
            Invalid callback.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.Flag">
            <summary>
            Invalid flag(s).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.NotAvailable">
            <summary>
            Not available.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.Init">
            <summary>
            Not initialized.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.AlreadyRegistered">
            <summary>
            Already registered.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowError.InvalidRegistration">
            <summary>
            Invalid Registration.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowInit">
            <summary>
            Initialization flags to be used with <see cref="M:ManagedBass.DShow.BassDShow.Init(System.IntPtr,ManagedBass.DShow.BassDShowInit)" />
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowInit.Default">
            <summary>
            Normal mode.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowInit.MultiThread">
            <summary>
            Enable multithread support.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowMode">
            <summary>
            Channel Position Mode flags to be used with e.g. <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetLength(System.Int32,ManagedBass.DShow.BassDShowMode)" />, <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetPosition(System.Int32,ManagedBass.DShow.BassDShowMode)" /> or <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetPosition(System.Int32,System.Double,ManagedBass.DShow.BassDShowMode)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowMode.Seconds">
            <summary>
            Position in seconds.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowMode.Frames">
            <summary>
            Position in frames.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowMode.Milliseconds">
            <summary>
            Position in milliseconds.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowMode.RefTime">
            <summary>
            MOD Music Flag: Stop all notes when moving position.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowState">
            <summary>
            <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetState(System.Int32)" /> return values.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowState.Unknown">
            <summary>
            The channel state is unknown.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowState.Playing">
            <summary>
            The channel is playing.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowState.Paused">
            <summary>
            The channel is paused.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowState.Stopped">
            <summary>
            The channel is stopped.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowSync">
            <summary>
            Channel Sync type to be used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetSync(System.Int32,ManagedBass.DShow.VideoSyncProcedure,System.IntPtr)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowSync.End">
            <summary>
            Triggered when the stream ends.
            <para>data: alwqays 0.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowSync.DvdChapterStart">
            <summary>
            Triggered when a new DVD chapter starts.
            <para>data: the new chapter index.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowSync.DvdTitleChange">
            <summary>
            Triggered when a title change occured in a DVD stream.
            <para>data: new title number.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowSync.DvdError">
            <summary>
            Triggered when an error occured on a DVD stream.
            <para>data: alwqays 0.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowSync.Repaint">
            <summary>
            Triggered by video renderers when it needs a repaint. A call to <see cref="M:Un4seen.Bass.AddOn.DShow.BassDShow.BASS_DSHOW_ChannelRepaint(System.Int32,System.IntPtr,System.IntPtr)" /> should be done, but not necessary.
            <para>data: alwqays 0.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowSync.VideoSizeChanged">
            <summary>
            Triggered by video renderers when the video size changed.
            <para>data: the new video width/height (the HiWord represents the new width; the LoWord represents the new height).</para>
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowChannelInfo">
            <summary>
            Used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetInfo(System.Int32,ManagedBass.DShow.BassDShowChannelInfo@)" /> to retrieve information about a video.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.AvgTimePerFrame">
            <summary>
            The video frames per seconds (0 if no video).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.Height">
            <summary>
            The height of the video in pixel (0 if no video).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.Width">
            <summary>
            The width of the video in pixel (0 if no video).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.ChannelCount">
            <summary>
            Number of audio channels (0 if no audio).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.Frequency">
            <summary>
            Audio sample rate (0 if no audio).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.BitsPerSample">
            <summary>
            Audio resolution (8, 16, 32 bits) (0 if no audio).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowChannelInfo.FloatingPoint">
            <summary>
            Indicates if the audio is 32 bit floating point or not (<see langword="false" /> if no audio).
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowColorRange">
            <summary>
            Used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelColorRange(System.Int32,ManagedBass.DShow.BassDShowColorControl,ManagedBass.DShow.BassDShowColorRange@)" /> to retrieve the color controls range.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorRange.MinValue">
            <summary>
            The minimum value that a color control can have.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorRange.MaxValue">
            <summary>
            The maximum value that a color control can have.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorRange.DefaultValue">
            <summary>
            The default value of the color controls (most of the time this is the value that don't affect video).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorRange.StepSize">
            <summary>
            The step size between minimum and maximum values.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowColorRange.Type">
            <summary>
            One of the <see cref="T:ManagedBass.DShow.BassDShowColorControl" /> flags.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowPluginInfo">
            <summary>
            Used with <see cref="M:ManagedBass.DShow.BassDShow.PluginGetInfo(System.Int32,ManagedBass.DShow.BassDShowPluginInfo@)" /> to retrieve information on a plugin.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowPluginInfo.Version">
            <summary>
            Plugin version.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowPluginInfo.decoderType">
            <summary>
            Type of decoder: 1=audio, 2=video.
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowPluginInfo.Description">
            <summary>
            The plugin description.
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowPluginInfo.IsAudio">
            <summary>
            Returns if the plugin is an audio plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowPluginInfo.IsVideo">
            <summary>
            Returns if the plugin is a video plugin.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowStreams">
            <summary>
            Used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelGetStream(System.Int32,System.Int32)" /> to retrieve information of a stream.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowStreams.format">
            <summary>
            0: unknown, 1: video , 2: audio , 3: subtitle
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowStreams.Name">
            <summary>
            The format name.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowStreams.Index">
            <summary>
            The stream index. Use this index to enable or disable it.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowStreams.Enabled">
            <summary>
            Is this stream enabled?
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowStreams.IsSubtitle">
            <summary>
            Returns if the stream is a subtitle format.
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowStreams.IsAudio">
            <summary>
            Returns if the stream is an audio format.
            </summary>
        </member>
        <member name="P:ManagedBass.DShow.BassDShowStreams.IsVideo">
            <summary>
            Returns if the stream is a video format.
            </summary>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowVideoBitmap">
            <summary>
            Used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelOverlayBMP(System.Int32,ManagedBass.DShow.BassDShowVideoBitmap)" /> to overlay a HDC to the video window.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.Visible">
            <summary>
            The overlay bitmap is visible or not?
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.InLeft">
            <summary>
            The left position of the HDC.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.InTop">
            <summary>
            The top position of the HDC.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.InRight">
            <summary>
            The right position of the HDC.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.InBottom">
            <summary>
            The bottom position of the HDC.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.OutLeft">
            <summary>
            The output left destination(0...1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.OutTop">
            <summary>
            The output top destination(0...1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.OutRight">
            <summary>
            The output right destination(0...1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.OutBottom">
            <summary>
            The output bottom destination(0...1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.AlphaValue">
            <summary>
            The blend value of the overlay(0...1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.TransparentColor">
            <summary>
            A RGB value that indicates wich color will not be blend over video.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoBitmap.HDC">
            <summary>
            A valid HDC.
            </summary>
            <remarks>Make sure to release the HDC once not needed anymore to prevent memory leaks.</remarks>
        </member>
        <member name="T:ManagedBass.DShow.BassDShowVideoColors">
            <summary>
            Used with <see cref="M:ManagedBass.DShow.BassDShow.ChannelSetColors(System.Int32,ManagedBass.DShow.BassDShowColorControl,ManagedBass.DShow.BassDShowVideoColors)" /> to set new values for color control.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoColors.Contrast">
            <summary>
            The contrast value of the color.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoColors.Brightness">
            <summary>
            The brightness value of the color.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoColors.Hue">
            <summary>
            The hue value of the color.
            </summary>
        </member>
        <member name="F:ManagedBass.DShow.BassDShowVideoColors.Saturation">
            <summary>
            The saturation value of the color.
            </summary>
        </member>
        <member name="T:ManagedBass.BassWA">
            <summary>
            BassWA is a BASS AddOn allowing the usage of Winamp visual plugins within your applications.
            </summary>
        </member>
        <member name="M:ManagedBass.BassWA.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassWA.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="M:ManagedBass.BassWA.StartVis(System.Int32,System.Int32)">
            <summary>
            Starts the visualization plugin and the selected module within the plugin you provide.
            </summary>
            <param name="Plugin">Plugin Index Number.</param>
            <param name="Module">Module Index Number.</param>
        </member>
        <member name="M:ManagedBass.BassWA.StopVis(System.Int32)">
            <summary>
            Stops the plugin you select using the index number.
            </summary>
            <param name="Plugin">Plugin Index Number.</param>
        </member>
        <member name="M:ManagedBass.BassWA.ConfigVis(System.Int32,System.Int32)">
            <summary>
            Opens the plugin configuration window.
            </summary>
            <param name="Plugin">Plugin Index number.</param>
            <param name="Module">Module Index number.</param>
        </member>
        <member name="M:ManagedBass.BassWA.LoadAllVis">
            <summary>
            This function is the same as <see cref="M:ManagedBass.BassWA.LoadVis(System.Int32)"/>, except using this function you don't have to provide a plugin index number, the function just loads all possible visual plugins.
            This function takes more resources, but makes plugin starting faster.
            </summary>
        </member>
        <member name="M:ManagedBass.BassWA.LoadVis(System.Int32)">
            <summary>
            Loads a specified plugin. You have to call this funcion before you try to start the plugin using the <see cref="M:ManagedBass.BassWA.StartVis(System.Int32,System.Int32)"/> function.
            </summary>
            <param name="Plugin">Plugin Index Number.</param>
        </member>
        <member name="M:ManagedBass.BassWA.FreeVis(System.Int32)">
            <summary>
            Frees the resouces used by a loaded plugin.
            </summary>
            <param name="Plugin">Plugin Index Number.</param>
        </member>
        <member name="M:ManagedBass.BassWA.FreeVisInfo">
            <summary>
            Frees the VisInfo resouces, this function has to be called after you are done loading the plugin names using the <see cref="M:ManagedBass.BassWA.GetWinampPluginInfo(System.Int32)"/> function.
            </summary>
        </member>
        <member name="M:ManagedBass.BassWA.GetModuleCount(System.Int32)">
            <summary>
            Gets the total number of modules that are found in the visual plugin.
            </summary>
            <param name="Plugin">Plugin Index Number.</param>
            <returns>the total number of modules that are found in the visual plugin.</returns>
        </member>
        <member name="P:ManagedBass.BassWA.WinampPluginCount">
            <summary>
            Returns the total number of plugins containd in the plugin directory you provide using the <see cref="M:ManagedBass.BassWA.LoadVisPlugin(System.String)"/> function.
            </summary>
        </member>
        <member name="M:ManagedBass.BassWA.SetHwnd(System.IntPtr)">
            <summary>
            Sets the hwnd of the window you are using.
            It's used for the message boxes and for the plugin to know which window is parent.
            </summary>
            <param name="Hwnd">The Hwnd of your program's main window.</param>
        </member>
        <member name="M:ManagedBass.BassWA.GetVisHwnd">
            <summary>
            Gets the Hwnd of the currently running plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.BassWA.SetElapsed(System.Int32)">
            <summary>
            Let's you send the elepsed time in the in the song to the plugin.
            Some plugins display this kind of information while running.
            </summary>
            <param name="Elapsed">Elapsed time in seconds.</param>
        </member>
        <member name="M:ManagedBass.BassWA.SetLength(System.Int32)">
            <summary>
            Let's you send the song's total length to the plugin.
            Some plugins display this kind of information while running.
            </summary>
            <param name="Length">The songs total length in seconds.</param>
        </member>
        <member name="M:ManagedBass.BassWA.IsPlaying(System.Boolean)">
            <summary>
            Let's the plugin know that you are playing some music.
            </summary>
            <param name="Playing">true for playing, false for not playing.</param>
        </member>
        <member name="M:ManagedBass.BassWA.SetModule(System.Int32)">
            <summary>
            Let's you set the module you like to use.
            This function has always to be called, even when using single-module plugins.
            </summary>
            <param name="Module">Module Index Number.</param>
        </member>
        <member name="M:ManagedBass.BassWA.SetChannel(System.Int32)">
            <summary>
            Sets the current playing channel BASS uses.
            The function has to be called when the channel changes, this happens for example when you load a new file.
            </summary>
            <param name="Channel">The current playing channel.</param>
        </member>
        <member name="M:ManagedBass.BassWA.LoadVisPlugin(System.String)">
            <summary>
            Loads all plugins from a path you provide, the function takes one parameter and returns a boolean value to indicate that the load was succesfull.
            </summary>
            <param name="Path">The path to the plugins you would BASS_WA to load.</param>
            <remarks>The plugin names can later be found using the <see cref="M:ManagedBass.BassWA.GetWinampPluginInfo(System.Int32)"/> function.</remarks>
        </member>
        <member name="M:ManagedBass.BassWA.SetSongTitle(System.String)">
            <summary>
            Let's you send the song's title to the plugin.
            Some plugins display this kind of information while running.
            </summary>
            <param name="Title">The song's title.</param>
        </member>
        <member name="M:ManagedBass.BassWA.GetModuleInfo(System.Int32,System.Int32)">
            <summary>
            Gets the name of a module.
            </summary>
            <param name="Plugin">Plugin Index Number.</param>
            <param name="Module">Module Index Number.</param>
            <returns>the name of the <paramref name="Module"/>.</returns>
        </member>
        <member name="M:ManagedBass.BassWA.GetWinampPluginInfo(System.Int32)">
            <summary>
            Gets the name of the plugin index you provide.
            </summary>
            <param name="Plugin">Module Index Number.</param>
            <returns>the name of <paramref name="Plugin"/>.</returns>
        </member>
        <member name="T:ManagedBass.BassTags">
            <summary>
            BASS audio library has limited support for reading tags, associated with a stream.
            This library extends that functionality, allowing developer/user to extract specific song information from the stream handle used with BASS.
            The extracted tag values are formatted into text ouput according to given format string (including conditional processing).
            </summary>
        </member>
        <member name="M:ManagedBass.BassTags.Load(System.String)">
            <summary>
            Load this library into Memory.
            </summary>
            <param name="Folder">Directory to Load from... <see langword="null"/> (default) = Load from Current Directory.</param>
            <returns><see langword="true" />, if the library loaded successfully, else <see langword="false" />.</returns>
            <remarks>
            <para>
            An external library is loaded into memory when any of its methods are called for the first time.
            This results in the first method call being slower than all subsequent calls.
            </para>
            <para>
            Some BASS libraries and add-ons may introduce new options to the main BASS lib like new parameters.
            But, before using these new options the respective library must be already loaded.
            This method can be used to make sure, that this library has been loaded.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.BassTags.Unload">
            <summary>
            Unloads this library from Memory.
            </summary>
            <returns><see langword="true" />, if the library unloaded successfully, else <see langword="false" />.</returns>
        </member>
        <member name="P:ManagedBass.BassTags.Version">
            <summary>
            Returns Tags library version.
            Current version (in HIBYTE) and build (in LOBYTE).
            </summary>
        </member>
        <member name="P:ManagedBass.BassTags.LastErrorDescription">
            <summary>
            For debug; the text description of the last <see cref="M:ManagedBass.BassTags.Read(System.Int32,System.String)"/>/<see cref="M:ManagedBass.BassTags.Read(System.Int32,System.String,ManagedBass.TagType,System.Int32)"/> call.
            It may say something like: "ID3v2 tag: header is invalid", on poorly-added tags.
            An empty string is returned if there was no error.
            </summary>
        </member>
        <member name="M:ManagedBass.BassTags.Read(System.Int32,System.String)">
            <summary>
            Reads tag values from the stream and formats them according to given format string.
            </summary>
            <param name="Handle">BASS handle, obtained normally via CreateStream call, or any other handle, on which <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/> can be called.</param>
            <param name="Format">format string.</param>
            <returns>
            Empty string when unable to properly read the tag, or when there are no supported tags.
            A string containing extracted values from the song tags, on success.
            A parser error message text, when format string is ill-formed.
            </returns>
            <remarks>
            Ill-formed string causes some error message to appear in the output, but don't count on it too much...
            If a file contains APE, ID3v1 and ID3v2 tags, the order of precedence is: APE, ID3v2, ID3v1.
            </remarks>
        </member>
        <member name="M:ManagedBass.BassTags.Read(System.Int32,System.String,ManagedBass.TagType,System.Int32)">
            <summary>
            Reads tag values from the stream and formats them according to given format string.
            </summary>
            <param name="Handle">BASS handle, obtained normally via CreateStream call, or any other handle, on which <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/> can be called.</param>
            <param name="Format">format string.</param>
            <param name="TagType">limit processing to a particular tag type, -1 = all tag types.</param>
            <param name="CodePage">
            Codepage to use when reading "ISO-8859-1" tags.
            If an invalid/unavailable codepage is requested, then 1252 (Latin 1) will be used.
            0 can be used to request Windows' default codepage.
            </param>
            <returns>
            Empty string when unable to properly read the tag, or when there are no supported tags.
            A string containing extracted values from the song tags, on success.
            A parser error message text, when format string is ill-formed.
            </returns>
            <remarks>See <see cref="M:ManagedBass.BassTags.Read(System.Int32,System.String)"/></remarks>
        </member>
    </members>
</doc>
